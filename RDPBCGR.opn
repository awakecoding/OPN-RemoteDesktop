protocol RDPBCGR with
Visualization{AliasName = "RDP"},
Documentation
{
    ProtocolName = "Remote Desktop Protocol: Basic Connectivity and Graphics Remoting Specification",
    ShortName = "RDPBCGR",
    Description = ""
},
OPNAuthoring
{
    Copyright = "(c) Microsoft Corporation",
    References =
        [
            new Reference{Name = "MS-RDPBCGR", Version = "34.0", Date = "01/31/2013", ProgramName = ProgramName.MCPP},
        ],
    RevisionSummary =
        [
            new Revision{Class=RevisionClass.Major, Version="372482", Date="12/16/2014"}
        ]
};

using Standard;
using Utility;
using IANA;
using ISOTS;
using ReassembledTCP;
using Reassembly;
using X224;
using T124;
using T125;
using RDPNSC;
using RemoteDesktopResources;
using Diagnostics;
using EMFPLUS;
using RDPEUDP;
using InfrastructureResources;

endpoint Server over X224.Server | over T125.Node | over T124.Node
                accepts ClientX224ConnectionRequestPdu issues ServerX224ConnectionConfirmPdu
                issues EarlyUserAuthorizationResultPdu
                accepts ClientMcsConnectInitialPduWithGccConferenceCreateRequest issues ServerMCSConnectResponsePDUWithGccConferenceCreateResponse
                accepts ClientMCSErectDomainRequestPdu
                accepts ClientMCSAttachUserRequestPdu issues ServerMCSAttachUserConfirmPdu
                accepts ClientMCSChannelJoinRequestPdu issues ServerMCSChannelJoinConfirmPdu
                accepts ClientSecurityExchangePdu
                accepts ClientInfoPdu
                issues mutable ServerDemandActivePdu accepts mutable ClientConfirmActivePdu
                accepts ClientSynchronizePdu issues ServerSynchronizePdu
                accepts ClientControlPduCoOperate issues ServerControlPduCoOperate
                accepts ClientControlPduRequestControl issues ServerControlPduGrantedControl
                accepts ClientPersistentKeyListPdu
                accepts ClientFontListPdu
                issues ServerFontMapPdu
                accepts VirtualChannelPdu issues VirtualChannelPdu
                accepts ClientShutdownRequestPdu issues ServerShutdownRequestDeniedPdu
                accepts ClientAutoDetectResponsePdu issues ServerAutoDetectRequestPdu
                issues TSEnhancedSecurityServerRedirection
                issues TSStandardSecurityServerRedirectionPdu
                issues MonitorLayoutPdu
                accepts ClientSuppressOutputPdu
                accepts ClientRefreshRectPdu
                issues ServerSaveSessionInfoPdu
                issues ServerPlaySoundPdu
                issues TSPointerPdu
                issues TSGraphicsPdu
                issues ServerSetKeyboardIMEStatusPdu
                issues ServerSetKeyboardIndicatorsPdu
                accepts TSInputPDU
                issues ServerStatusInfoPdu
                issues ServerSetErrorInfoPdu
                issues ServerAutoReconnectStatusPdu
                issues ServerDeactivateAllPdu
                accepts McsDisconnectProviderUltimatumPdu issues McsDisconnectProviderUltimatumPdu
                accepts EncryptedMessage issues EncryptedMessage
                accepts TSFPInputEventPdu issues mutable TSFPUpdatePdu
                accepts ClientInitiateMultitransportError issues ServerInitiateMultitransportRequest
{
    map<uint, string> channelNameMap = {};
    // Record the keys of multi-transport
    set<binary> multiTransportIdSet = {};

    DummyEndpoint dummyEndpoint = endpoint DummyEndpoint;
    
    // observe rule to deal with multi-transport request
    observe this issues mreq:ServerInitiateMultitransportRequest
    {
        binary id = ConstructId(mreq.RequestId, mreq.SecurityCookie);
        multiTransportIdSet[id] = true;
        dummyEndpoint.multiTransportMap[id] = this;
    }

    ~endpoint(RDPBCGR.Server server)
    {
        ClearKeysForDummyEndpoint();
    }

    void ClearKeysForDummyEndpoint()
    {
        foreach (var id in multiTransportIdSet)
        {
            if (id in dummyEndpoint.multiTransportMap)
            {
                dummyEndpoint.multiTransportMap = 
                    dummyEndpoint.multiTransportMap.Remove(id);
            }
        }
        multiTransportIdSet = {};
    }
};

// Dummy endpoint contains global variable
endpoint DummyEndpoint accepts any message issues any message
{
    // map used by multi-transport.
    // Key: RequestID.ToBinary() + SecurityCookie;
    // Value: RDPBCGR Server;
    map<binary, Server> multiTransportMap = {};
};

// Construct key used by edycEndpointMap
binary ConstructId(uint reqId, binary cookie)
{
    return reqId.ToBinary() + cookie;
}
                
client endpoint Client connected to Server;
annotation string VirtualChannelPdu#ChannelName;

// Record the state for multiple RDP connections, use RDP client port number as index
map<ulong, TSUDSCSec1EncryptionLevel> encryptionLevels = {};
map<ulong, TSUDSCSec1EncryptionMethod> encryptionMethods = {};
map<ulong, bool> ServerMCSConnectResponsePDUReceivedFlags = {};
map<ulong, long> selectedProtocols = {};
map<ulong, array<string>> channelNames = {};
map<ulong, map<long, string>> channelNamesMaps = {};
map<ulong, int> channelCounts = {};
map<ulong, long> mcsChannelIds = {};
map<ulong, long> mcsMessageChannelIds = {};

autostart actor RDPBCGROverX224(X224.Server server)
{
    ulong indexPort = 0;
    
    process server accepts tpdu:X224.TPDU
        where (((tpdu#TpduDestinationPort != nothing) && (tpdu#TpduDestinationPort == Port.RDP))
           || ((tpdu#TpduSourcePort != nothing) && (tpdu#TpduSourcePort == Port.RDP)))
    {
        // 2.2.1.1   Client X.224 Connection Request PDU
        if (tpdu is req:ConnectionRequest && (req.ClassOption & 0xF0) == 0)
        {
            bool stringPresent = req.LengthIndicator > 14;     
            // if req.UserData is nothing and stringPresent is false, it will be decoded to an empty message
            // because fields of ClientX224ConnectionRequestPdu are optional 
            binary payload =  req.UserData is data:binary ? data : $[];
                    
            if (BinaryDecoder<ClientX224ConnectionRequestPdu[stringPresent]>(payload) is msg:ClientX224ConnectionRequestPdu)
            {
                dispatch endpoint Server accepts msg;
            }
            else
            {
                ThrowDecodingException("RDPBCGR", "ClientX224ConnectionRequestPdu");
            }
        }
        else
        {
            reject;
        }
    }

    process server issues tpdu:X224.TPDU
        where (((tpdu#TpduDestinationPort != nothing) && (tpdu#TpduDestinationPort == Port.RDP))
           || ((tpdu#TpduSourcePort != nothing) && (tpdu#TpduSourcePort == Port.RDP)))
    {
        // 2.2.1.2   Server X.224 Connection Confirm PDU
        if (tpdu is res:ConnectionConfirm && (res.ClassOption & 0xF0) == 0)
        {
            // if res.UserData is nothing, it will be decoded to an empty message, because fields of ServerX224ConnectionConfirmPdu are optional 
            binary payload = res.UserData is data:binary ? data : $[];
                    
            if (BinaryDecoder<ServerX224ConnectionConfirmPdu>(payload) is msg:ServerX224ConnectionConfirmPdu)
            {
                if (msg.RdpNegData != nothing && msg.RdpNegData is RdpNegRsp)
                {
                    indexPort = (tpdu#TpduDestinationPort != nothing) ? (tpdu#TpduDestinationPort as ulong) : 0;
                    selectedProtocols[indexPort] = (msg.RdpNegData as RdpNegRsp).SelectedProtocol;
                }
                dispatch endpoint Server issues msg;
            }
            else
            {
                ThrowDecodingException("RDPBCGR", "ServerX224ConnectionConfirmPdu");
            }
        }
        else
        {
            reject;
        }
    }
    
    ~endpoint(X224.Server server)
    {
        if (indexPort in selectedProtocols)
        {
            selectedProtocols = selectedProtocols.Remove(indexPort);
        }
    }
}

autostart actor RDPBCGROverT124(T124.Node node)
{   
    ulong indexPort = 0;
     
    process node accepts connectGccPdu:T124.ConnectGccPdu
    {
        T124.ConferenceCreateRequest conferenceCreateRequest;
        indexPort = (connectGccPdu#T124SourcePort != nothing) ? (connectGccPdu#T124SourcePort as ulong) : 0;

        if (connectGccPdu.ConnectPdu is T124.ConferenceCreateRequest)
        {
            conferenceCreateRequest = connectGccPdu.ConnectPdu as T124.ConferenceCreateRequest;
        }
        else
        {
            reject;
        }
        if (conferenceCreateRequest.UserData != nothing && (conferenceCreateRequest.UserData as set<UserDataType>).Count == 1)
        {
            binary keyIdentifier = $[];
            binary payload = $[];
            set<UserDataType> userdata = conferenceCreateRequest.UserData as set<UserDataType>;
            // There's only one element in set<>, but can not use index to retrieve elements in set, so use foreach() instead.
            foreach(var userDataType in userdata) 
            {
                payload = (userDataType as UserDataType).Value as binary;
                keyIdentifier = (userDataType as UserDataType).Key as binary;
                if (keyIdentifier == $[44756361] && conferenceCreateRequest.UserData != nothing)
                {
                    switch (payload)
                    {
                        case m:ClientMcsConnectInitialPduWithGccConferenceCreateRequest from BinaryDecoder<ClientMcsConnectInitialPduWithGccConferenceCreateRequest> =>
                            int tempCount = 0;
                            if (!(indexPort in channelNames))
                            {
                                channelNames[indexPort] = [];
                            }
                            while (tempCount < m.TSUD.Count)
                            {
                                if (m.TSUD[tempCount] is TSUDCSNet)
                                {
                                    channelCounts[indexPort] = (m.TSUD[tempCount] as TSUDCSNet).ChannelCount as int;
                                    string tempName;
                                    array<ChannelDef> tempChannelDef = (m.TSUD[tempCount] as TSUDCSNet).ChannelDefArray;
                                    int temp = 0;
                                    while (temp < channelCounts[indexPort])
                                    {
                                        tempName = tempChannelDef[temp].Name;
                                        channelNames[indexPort] += [tempName];
                                        temp = temp + 1;
                                    }
                                }
                                tempCount += 1;
                            }
                            dispatch endpoint Server accepts m;
                        default => 
                            ThrowDecodingException("RDPBCGR", "ClientMcsConnectInitialPduWithGccConferenceCreateRequest");
                    }
                }
                else
                {
                    reject;
                }
            }
        }
        else 
        {
            reject;
        }
    }
    
    process node issues connectGccPdu:T124.ConnectGccPdu
    {
        T124.ConferenceCreateResponse conferenceCreateResponse;
        indexPort = (connectGccPdu#T124DestinationPort != nothing) ? (connectGccPdu#T124DestinationPort as ulong) : 0;
        int channelCount = (indexPort in channelCounts) ? channelCounts[indexPort] : -1;

        if (connectGccPdu.ConnectPdu is T124.ConferenceCreateResponse)
        {
            conferenceCreateResponse = connectGccPdu.ConnectPdu as T124.ConferenceCreateResponse;
        }
        else
        {
            reject;
        }
        if (conferenceCreateResponse.UserData != nothing && (conferenceCreateResponse.UserData as set<UserDataType>).Count == 1)
        {
            binary keyIdentifier = $[];
            binary payload = $[];
            set<UserDataType> userdata = conferenceCreateResponse.UserData as set<UserDataType>;
            // There's only one element in set<>, but can not use index to retrieve elements in set, so use foreach() instead.
            foreach(var userDataType in userdata)
            {
                payload = (userDataType as UserDataType).Value as binary;
                keyIdentifier = (userDataType as UserDataType).Key as binary;
                if (keyIdentifier == $[4D63446E] && conferenceCreateResponse.UserData != nothing)
                {
                    switch (payload)
                    {
                        case m:ServerMCSConnectResponsePDUWithGccConferenceCreateResponse from BinaryDecoder<ServerMCSConnectResponsePDUWithGccConferenceCreateResponse> =>
                            int tempCount = 0;
                            // The ServerMCSConnectResponsePDUWithGccConferenceCreateResponse has been recevied
                            ServerMCSConnectResponsePDUReceivedFlags[indexPort] = true;
                            if (!(indexPort in channelNamesMaps))
                            {
                                channelNamesMaps[indexPort] = {};
                            }
                            while (tempCount < m.TSUD.Count)
                            {
                                if (m.TSUD[tempCount] is TSUDSCNet)
                                {
                                    int temp = 0;
                                    while (temp < channelCount)
                                    {
                                        channelNamesMaps[indexPort][(m.TSUD[tempCount] as TSUDSCNet).ChannelIdArray[temp]] = channelNames[indexPort][temp];
                                        temp = temp + 1;
                                    }
                                    mcsChannelIds[indexPort] = (m.TSUD[tempCount] as TSUDSCNet).McsChannelId;
                                }
                                else if (m.TSUD[tempCount] is TSUDSCSec1)
                                {
                                    encryptionLevels[indexPort] = (m.TSUD[tempCount] as TSUDSCSec1).EncryptionLevel;
                                    encryptionMethods[indexPort] = (m.TSUD[tempCount] as TSUDSCSec1).EncryptionMethod;
                                }
                                else if (m.TSUD[tempCount] is TSUDSCMcsMsgChannel) // If TSUD is a TSUDSCMcsMsgChannel, record its channel ID
                                {
                                    mcsMessageChannelIds[indexPort] = (m.TSUD[tempCount] as TSUDSCMcsMsgChannel).MCSChannelID;
                                }
                                tempCount += 1;
                            }
                            dispatch endpoint Server issues m;
                        default => 
                            ThrowDecodingException("RDPBCGR", "ServerMCSConnectResponsePDUWithGccConferenceCreateResponse");
                    }
                }
                else
                {
                    reject;
                }
            }
        }
        else 
        {
            reject;
        }
    }
    
    ~endpoint(T124.Node node)
    {
        if (indexPort in ServerMCSConnectResponsePDUReceivedFlags)
        {
            ServerMCSConnectResponsePDUReceivedFlags = ServerMCSConnectResponsePDUReceivedFlags.Remove(indexPort);
        }
        if (indexPort in channelNames)
        {
            channelNames = channelNames.Remove(indexPort);
        }
        if (indexPort in channelNamesMaps)
        {
            channelNamesMaps = channelNamesMaps.Remove(indexPort);
        }
        if (indexPort in channelCounts)
        {
            channelCounts = channelCounts.Remove(indexPort);
        }
        if (indexPort in mcsChannelIds)
        {
            mcsChannelIds = mcsChannelIds.Remove(indexPort);
        }
        if (indexPort in mcsMessageChannelIds)
        {
            mcsMessageChannelIds = mcsMessageChannelIds.Remove(indexPort);
        }
        if (indexPort in encryptionLevels)
        {
            encryptionLevels = encryptionLevels.Remove(indexPort);
        }
        if (indexPort in encryptionMethods)
        {
            encryptionMethods = encryptionMethods.Remove(indexPort);
        }
    }
}

autostart actor RDPBCGROverT125(T125.Node node)
{    
    bool initialFlag = true;
    // The initial value for the orderType agreed on by both the server and client is TS_ENC_PATBLT_ORDER(0x01).
    byte OrderType = PrimaryDrawingOrderType.TS_ENC_PATBLT_ORDER;

    process node accepts domainMCSPDU:T125.DomainMCSPDU
    {
        ulong indexPort = (domainMCSPDU#T125SourcePort != nothing) ? (domainMCSPDU#T125SourcePort as ulong) : 0;
        bool ServerMCSConnectResponsePDUReceived = (indexPort in ServerMCSConnectResponsePDUReceivedFlags) ? ServerMCSConnectResponsePDUReceivedFlags[indexPort] : false;
        map<long, string> channelNamesMap = (indexPort in channelNamesMaps) ? channelNamesMaps[indexPort] : {};
        long mcsChannelId = (indexPort in mcsChannelIds) ? mcsChannelIds[indexPort] : -1;
        long mcsMessageChannelId = (indexPort in mcsMessageChannelIds) ? mcsMessageChannelIds[indexPort] : -1;
        uint encryptionLevel = (indexPort in encryptionLevels) ? encryptionLevels[indexPort] : 0;
        uint encryptionMethod = (indexPort in encryptionMethods) ? encryptionMethods[indexPort] : 0;
        
        if (domainMCSPDU.DomainMCSPDU is T125.SendDataRequestPattern && ServerMCSConnectResponsePDUReceived)
        {
            binary payload = (domainMCSPDU.DomainMCSPDU as SendDataRequestPattern).UserData as binary;
            long channelId = (domainMCSPDU.DomainMCSPDU as SendDataRequestPattern).ChannelId;
            // Check whether ChannelId is registered
            if (!(channelId in channelNamesMap.Keys || channelId == mcsChannelId || channelId == mcsMessageChannelId))
            {
                ThrowDecodingException("RDPBCGR", UTILITY_UNDEFINED_DATA, ["ChannelId"]);    
            }
            // Encrypted data
            else if (((encryptionLevel != 0) || (encryptionMethod != 0)) && (payload[0] & 0x08) == 0x08)
            {
                var m = BinaryDecoder<EncryptedMessage[encryptionLevel, encryptionMethod]>(payload);
                if (m != nothing)
                {
                    var msg = m as EncryptedMessage;
                    dispatch endpoint Server accepts msg;
                }
                else
                {
                    ThrowDecodingException("RDPBCGR", "EncryptedMessage");
                }
            }
            
            // Distinguish message from channelId
            else if (channelId == mcsChannelId)
            {
                // 2.2.1.13.2   Client Confirm Active PDU
                if (GetPduType(payload, encryptionLevel, encryptionMethod, RDPBCGRMsgType.ClientConfirmActivePdu) == 0x03)
                {
                    var m = BinaryDecoder<ClientConfirmActivePdu[encryptionLevel, encryptionMethod]>(payload);
                    if (m != nothing)
                    {
                        var msg = m as ClientConfirmActivePdu;
                        dispatch endpoint Server accepts msg;
                    }
                    else
                    {
                        ThrowDecodingException("RDPBCGR", "ClientConfirmActivePdu");
                    }
                }
                // 2.2.1.14   Client Synchronize PDU
                else if ((GetPduType(payload, encryptionLevel, encryptionMethod, RDPBCGRMsgType.ClientSynchronizePdu)) == 0x07 &&
                (GetPdu2Type(payload, encryptionLevel, encryptionMethod, RDPBCGRMsgType.ClientSynchronizePdu) == 0x1F))
                {
                    var m = BinaryDecoder<ClientSynchronizePdu[encryptionLevel, encryptionMethod]>(payload);
                    if (m != nothing)
                    {
                        var msg = m as ClientSynchronizePdu;
                        dispatch endpoint Server accepts msg;
                    }
                    else
                    {
                        ThrowDecodingException("RDPBCGR", "ClientSynchronizePdu");
                    }
                }
                // 2.2.1.15   Client Control PDU - Cooperate
                else if ((GetPduType(payload, encryptionLevel, encryptionMethod, RDPBCGRMsgType.ClientControlPduCoOperate)) == 0x07 &&
                (GetPdu2Type(payload, encryptionLevel, encryptionMethod, RDPBCGRMsgType.ClientControlPduCoOperate) == 0x14))
                {
                    var m = BinaryDecoder<ClientControlPduCoOperate[encryptionLevel, encryptionMethod]>(payload);
                    if (m != nothing)
                    {
                        var msg = m as ClientControlPduCoOperate;
                        dispatch endpoint Server accepts msg;
                    }
                    else
                    {
                        // 2.2.1.16   Client Control PDU - Request Control
                        var m2 = BinaryDecoder<ClientControlPduRequestControl[encryptionLevel, encryptionMethod]>(payload);
                        if (m2 != nothing)
                        {
                            var msg = m2 as ClientControlPduRequestControl;
                            dispatch endpoint Server accepts msg;
                        }
                        else
                        {
                            ThrowDecodingException("RDPBCGR", "ClientControlPduCoOperate");
                        }
                    }
                }
                // 2.2.1.17   Client Persistent Key List PDU
                else if ((GetPduType(payload, encryptionLevel, encryptionMethod, RDPBCGRMsgType.ClientPersistentKeyListPdu)) == 0x07 &&
                (GetPdu2Type(payload, encryptionLevel, encryptionMethod, RDPBCGRMsgType.ClientPersistentKeyListPdu) == 0x2B))
                {
                    var m = BinaryDecoder<ClientPersistentKeyListPdu[encryptionLevel, encryptionMethod]>(payload);
                    if (m != nothing)
                    {
                        var msg  = m as ClientPersistentKeyListPdu;
                        dispatch endpoint Server accepts msg;
                    }
                    else
                    {
                        ThrowDecodingException("RDPBCGR", "ClientPersistentKeyListPdu");
                    }
                }
                // 2.2.1.18   Client Font List PDU
                else if ((GetPduType(payload, encryptionLevel, encryptionMethod, RDPBCGRMsgType.ClientFontListPdu)) == 0x07 &&
                (GetPdu2Type(payload, encryptionLevel, encryptionMethod, RDPBCGRMsgType.ClientFontListPdu) == 0x27))
                {
                    var m = BinaryDecoder<ClientFontListPdu[encryptionLevel, encryptionMethod]>(payload);
                    if (m != nothing)
                    {
                        var msg = m as ClientFontListPdu;
                        dispatch endpoint Server accepts msg;
                    }
                    else
                    {
                        ThrowDecodingException("RDPBCGR", "ClientFontListPdu");
                    }
                }
                // 2.2.2.1   Client Shutdown Request PDU
                else if ((GetPduType(payload, encryptionLevel, encryptionMethod, RDPBCGRMsgType.ClientShutdownRequestPdu)) == 0x07 &&
                (GetPdu2Type(payload, encryptionLevel, encryptionMethod, RDPBCGRMsgType.ClientShutdownRequestPdu) == 0x24))
                {
                    var m = BinaryDecoder<ClientShutdownRequestPdu[encryptionLevel, encryptionMethod]>(payload);
                    if (m != nothing)
                    {
                        var msg = m as ClientShutdownRequestPdu;
                        dispatch endpoint Server accepts msg;
                    }
                    else
                    {
                        ThrowDecodingException("RDPBCGR", "ClientShutdownRequestPdu");
                    }
                }
                // 2.2.8.1.1.3   Client Input Event PDU (TS_INPUT_PDU)
                else if ((GetPduType(payload, encryptionLevel, encryptionMethod, RDPBCGRMsgType.TSInputPDU)) == 0x07 &&
                (GetPdu2Type(payload, encryptionLevel, encryptionMethod, RDPBCGRMsgType.TSInputPDU) == 0x1C))
                {
                    var m = BinaryDecoder<TSInputPDU[encryptionLevel, encryptionMethod]>(payload);
                    if (m != nothing)
                    {
                        var msg = m as TSInputPDU;
                        dispatch endpoint Server accepts msg;
                    }
                    else
                    {
                        ThrowDecodingException("RDPBCGR", "TSInputPDU");
                    }
                }
                // 2.2.11.2   Client Refresh Rect PDU
                else if ((GetPduType(payload, encryptionLevel, encryptionMethod, RDPBCGRMsgType.ClientRefreshRectPdu)) == 0x07 &&
                (GetPdu2Type(payload, encryptionLevel, encryptionMethod, RDPBCGRMsgType.ClientRefreshRectPdu) == 0x21))
                {
                    var m = BinaryDecoder<ClientRefreshRectPdu[encryptionLevel, encryptionMethod]>(payload);
                    if (m != nothing)
                    {
                        var msg = m as ClientRefreshRectPdu;
                        dispatch endpoint Server accepts msg;
                    }
                    else
                    {
                        ThrowDecodingException("RDPBCGR", "ClientRefreshRectPdu");
                    }
                }
                // 2.2.11.3   Client Suppress Output PDU
                else if ((GetPduType(payload, encryptionLevel, encryptionMethod, RDPBCGRMsgType.ClientSuppressOutputPdu)) == 0x07 &&
                (GetPdu2Type(payload, encryptionLevel, encryptionMethod, RDPBCGRMsgType.ClientSuppressOutputPdu) == 0x23))
                {
                    var m = BinaryDecoder<ClientSuppressOutputPdu[encryptionLevel, encryptionMethod]>(payload);
                    if (m != nothing)
                    {
                        var msg = m as ClientSuppressOutputPdu;
                        dispatch endpoint Server accepts msg;
                    }
                    else
                    {
                        ThrowDecodingException("RDPBCGR", "ClientSuppressOutputPdu");
                    }
                }                
                // 2.2.1.10   Client Security Exchange PDU
                else if ((payload[0] == 0x01 &&
                payload[1] == 0x02) || 
                (payload[0] == 0x01 &&
                payload[1] == 0x00))
                {
                    switch(payload)
                    {
                        case m:ClientSecurityExchangePdu from BinaryDecoder<ClientSecurityExchangePdu> =>
                            dispatch endpoint Server accepts m;
                        default => 
                            ThrowDecodingException("RDPBCGR", "ClientSecurityExchangePdu");
                    }
                }
                // 2.2.1.11   Client Info PDU
                else if ((payload[0] == 0x40) || (payload[0] == 0x48))
                {
                    var m = BinaryDecoder<ClientInfoPdu[encryptionLevel, encryptionMethod]>(payload);
                    if (m != nothing)
                    {
                        var msg = m as ClientInfoPdu;
                        dispatch endpoint Server accepts msg;
                    }
                    else
                    {
                        ThrowDecodingException("RDPBCGR", "ClientInfoPdu");
                    }
                }
                else 
                {
                    reject;
                }      
            }
            else if (channelId == mcsMessageChannelId) // when channel id is mcsMessageChannelId, the pdu is a Client Auto-Detect Response PDU or Client Initiate Multitransport Error
            {
                // 2.2.14.4   Client Auto-Detect Response PDU
                if (IsAutoDetectMsg(payload, encryptionLevel, encryptionMethod, RDPBCGRMsgType.ClientAutoDetectResponsePdu))
                {
                    var m = BinaryDecoder<ClientAutoDetectResponsePdu[encryptionLevel, encryptionMethod]>(payload);
                    if (m != nothing)
                    {
                        var msg = m as ClientAutoDetectResponsePdu;
                        dispatch endpoint Server accepts msg;
                    }
                    else
                    {
                        ThrowDecodingException("RDPBCGR", "ClientAutoDetectResponsePdu");
                    }
                }
                // 2.2.15.2   Client Initiate Multitransport Error
                else if ((payload[0] & 0x04) == 0x04)
                {
                    var m = BinaryDecoder<ClientInitiateMultitransportError[encryptionLevel, encryptionMethod]>(payload);
                    if (m != nothing)
                    {
                        var msg = m as ClientInitiateMultitransportError;
                        dispatch endpoint Server accepts msg;
                    }
                    else
                    {
                        ThrowDecodingException("RDPBCGR", "ClientInitiateMultitransportError");
                    }
                }
                
                else 
                {
                    reject;
                }
            }
            else // channelId in channelNamesMap
            {
                // 2.2.6.1   Virtual Channel PDU
                if (channelId in channelNamesMap)
                {
                    var m = BinaryDecoder<VirtualChannelPdu[encryptionLevel, encryptionMethod]>(payload);

                    if (m != nothing)
                    {
                        var msg = m as VirtualChannelPdu;
                        msg#ChannelName = channelNamesMap[channelId];  
                        if ((msg.ChannelPduHeader.Flags & ChannelPduHeaderFlags.ChannelPacketCompressed) == ChannelPduHeaderFlags.ChannelPacketCompressed)
                        {
                            // If virtualChannelData is compressed, only show it as top level message
                            DisplayTopLevelMessage(msg);
                        }
                        else
                        {                            
                            dispatch endpoint Server accepts msg;                          
                        }
                        
                    }
                    else
                    {
                        ThrowDecodingException("RDPBCGR", "VirtualChannelPdu");
                    }
                }
            }
        }
        // 2.2.1.5   Client MCS Erect Domain Request PDU
        else if (domainMCSPDU.DomainMCSPDU is T125.ErectDomainRequestPattern)
        {
            ClientMCSErectDomainRequestPdu m = new ClientMCSErectDomainRequestPdu{};
            m.Origins = [domainMCSPDU];
            dispatch endpoint Server accepts m;
        }
        // 2.2.1.6   Client MCS Attach User Request PDU
        else if (domainMCSPDU.DomainMCSPDU is T125.AttachUserRequestPattern)
        {
            ClientMCSAttachUserRequestPdu m = new ClientMCSAttachUserRequestPdu{};
            m.Origins = [domainMCSPDU];
            dispatch endpoint Server accepts m;
        }
        // 2.2.1.8   Client MCS Channel Join Request PDU
        else if (domainMCSPDU.DomainMCSPDU is T125.ChannelJoinRequestPattern)
        {
            ClientMCSChannelJoinRequestPdu m = new ClientMCSChannelJoinRequestPdu{};
            m.Origins = [domainMCSPDU];
            dispatch endpoint Server accepts m;
        }
        // 2.2.2.3   MCS Disconnect Provider Ultimatum PDU
        else if (domainMCSPDU.DomainMCSPDU is T125.DisconnectProviderUltimatumPattern)
        {
            McsDisconnectProviderUltimatumPdu m = new McsDisconnectProviderUltimatumPdu{};
            m.Origins = [domainMCSPDU];
            dispatch endpoint Server accepts m;
        }
        else
        {
            // When ServerMCSConnectResponsePDU is lost, only attach the error message to the first unparsed RDPBCGR message.
            if (initialFlag && !ServerMCSConnectResponsePDUReceived)
            {
                ErrorCodeIf(true, domainMCSPDU, DiagnosisLevel.Warning, "RDPBCGR: Lack of MCS channel IDs, encryptionMethod and encryptionLevel due to missing Server MCS Connect Response PDU message."); 
                initialFlag = false;
            }
            reject;
        }
    }
    
    process node issues domainMCSPDU:T125.DomainMCSPDU
    {
        ulong indexPort = (domainMCSPDU#T125DestinationPort != nothing) ? (domainMCSPDU#T125DestinationPort as ulong) : 0;
        bool ServerMCSConnectResponsePDUReceived = (indexPort in ServerMCSConnectResponsePDUReceivedFlags) ? ServerMCSConnectResponsePDUReceivedFlags[indexPort] : false;
        map<long, string> channelNamesMap = (indexPort in channelNamesMaps) ? channelNamesMaps[indexPort] : {};
        long mcsChannelId = (indexPort in mcsChannelIds) ? mcsChannelIds[indexPort] : -1;
        long mcsMessageChannelId = (indexPort in mcsMessageChannelIds) ? mcsMessageChannelIds[indexPort] : -1;
        uint encryptionLevel = (indexPort in encryptionLevels) ? encryptionLevels[indexPort] : 0;
        uint encryptionMethod = (indexPort in encryptionMethods) ? encryptionMethods[indexPort] : 0;

        if (domainMCSPDU.DomainMCSPDU is T125.SendDataIndicationPattern && ServerMCSConnectResponsePDUReceived)
        {
            binary payload = (domainMCSPDU.DomainMCSPDU as SendDataIndicationPattern).UserData as binary;
            long channelId = (domainMCSPDU.DomainMCSPDU as SendDataIndicationPattern).ChannelId;
            // Check whether ChannelId is registered
            if (!((channelId in channelNamesMap.Keys) || (channelId == mcsChannelId) || (channelId == mcsMessageChannelId)))
            {
                ThrowDecodingException("RDPBCGR", UTILITY_UNDEFINED_DATA, ["ChannelId"]);
            }
            // Encrypted data
            else if (((encryptionLevel != 0) || (encryptionMethod != 0)) && (payload[0] & 0x08) == 0x08)
            {
                var m = BinaryDecoder<EncryptedMessage[encryptionLevel, encryptionMethod]>(payload);
                if (m != nothing)
                {
                    var msg = m as EncryptedMessage;
                    dispatch endpoint Server accepts msg;
                }
                else
                {
                    ThrowDecodingException("RDPBCGR", "EncryptedMessage");
                }
            }
            // Distinguish message from channelId
            else if (channelId == mcsChannelId)
            {
                // 2.2.1.13.1   Server Demand Active PDU
                if (GetPduType(payload, encryptionLevel, encryptionMethod, RDPBCGRMsgType.ServerDemandActivePdu) == 0x01)
                {
                    var m = BinaryDecoder<ServerDemandActivePdu[encryptionLevel, encryptionMethod]>(payload);
                    if (m != nothing)
                    {
                        var msg = m as ServerDemandActivePdu;
                        dispatch endpoint Server issues msg;
                    }
                    else
                    {
                        ThrowDecodingException("RDPBCGR", "ServerDemandActivePdu");
                    }
                }
                // 2.2.1.19   Server Synchronize PDU
                else if (((GetPduType(payload, encryptionLevel, encryptionMethod, RDPBCGRMsgType.ServerSynchronizePdu)) == 0x07 &&
                GetPdu2Type(payload, encryptionLevel, encryptionMethod, RDPBCGRMsgType.ServerSynchronizePdu) == 0x1F))
                {
                    var m = BinaryDecoder<ServerSynchronizePdu[encryptionLevel, encryptionMethod]>(payload);
                    if (m != nothing)
                    {
                        var msg = m as ServerSynchronizePdu;
                        dispatch endpoint Server issues msg;
                    }
                    else
                    {
                        // 2.2.1.21   Server Control PDU - Granted Control
                        var m2 = BinaryDecoder<ServerControlPduGrantedControl[encryptionLevel, encryptionMethod]>(payload);
                        if (m2 != nothing)
                        {
                            var msg = m2 as ServerControlPduGrantedControl;
                            dispatch endpoint Server issues msg;
                        }
                        else
                        {
                            ThrowDecodingException("RDPBCGR", "ServerControlPduGrantedControl");
                        }
                    }
                }
                // 2.2.1.20   Server Control PDU - Cooperate
                else if ((GetPduType(payload, encryptionLevel, encryptionMethod, RDPBCGRMsgType.ClientControlPduCoOperate)) == 0x07 &&
                (GetPdu2Type(payload, encryptionLevel, encryptionMethod, RDPBCGRMsgType.ClientControlPduCoOperate) == 0x14))
                {
                    var m = BinaryDecoder<ServerControlPduCoOperate[encryptionLevel, encryptionMethod]>(payload);
                    if (m != nothing)
                    {
                        var msg = m as ServerControlPduCoOperate;
                        dispatch endpoint Server issues msg;
                    }
                    else
                    {
                        // 2.2.1.21   Server Control PDU - Granted Control
                        var m2 = BinaryDecoder<ServerControlPduGrantedControl[encryptionLevel, encryptionMethod]>(payload);
                        if (m2 != nothing)
                        {
                            var msg = m2 as ServerControlPduGrantedControl;
                            dispatch endpoint Server issues msg;
                        }
                        else
                        {
                            ThrowDecodingException("RDPBCGR", "ServerControlPduCoOperate");
                        }
                    }
                }
                // 2.2.1.22   Server Font Map PDU
                else if ((GetPduType(payload, encryptionLevel, encryptionMethod, RDPBCGRMsgType.ServerFontMapPdu)) == 0x07 &&
                (GetPdu2Type(payload, encryptionLevel, encryptionMethod, RDPBCGRMsgType.ServerFontMapPdu) == 0x28))
                {
                    var m = BinaryDecoder<ServerFontMapPdu[encryptionLevel, encryptionMethod]>(payload);
                    if (m != nothing)
                    {
                        var msg = m as ServerFontMapPdu;
                        dispatch endpoint Server issues msg;
                    }
                    else
                    {
                        ThrowDecodingException("RDPBCGR", "ServerFontMapPdu");
                    }
                }
                // 2.2.2.2   Server Shutdown Request Denied PDU
                else if ((GetPduType(payload, encryptionLevel, encryptionMethod, RDPBCGRMsgType.ServerShutdownRequestDeniedPdu)) == 0x07 &&
                (GetPdu2Type(payload, encryptionLevel, encryptionMethod, RDPBCGRMsgType.ServerShutdownRequestDeniedPdu) == 0x25))
                {
                    var m = BinaryDecoder<ServerShutdownRequestDeniedPdu[encryptionLevel, encryptionMethod]>(payload);
                    if (m != nothing)
                    {
                        var msg = m as ServerShutdownRequestDeniedPdu;
                        dispatch endpoint Server issues msg;
                    }
                    else
                    {
                        ThrowDecodingException("RDPBCGR", "ServerShutdownRequestDeniedPdu");
                    }
                }
                // 2.2.3.1   Server Deactivate All PDU
                else if (GetPduType(payload, encryptionLevel, encryptionMethod, RDPBCGRMsgType.ServerDeactivateAllPdu) == 0x06)// coca
                {
                    var m = BinaryDecoder<ServerDeactivateAllPdu[encryptionLevel, encryptionMethod]>(payload);
                    if (m != nothing)
                    {
                        var msg = m as ServerDeactivateAllPdu;
                        dispatch endpoint Server issues msg;
                    }
                    else
                    {
                        ThrowDecodingException("RDPBCGR", "ServerDeactivateAllPdu");
                    }
                }
                // 2.2.4.1   Server Auto-Reconnect Status PDU
                else if ((GetPduType(payload, encryptionLevel, encryptionMethod, RDPBCGRMsgType.ServerAutoReconnectStatusPdu)) == 0x07 &&
                (GetPdu2Type(payload, encryptionLevel, encryptionMethod, RDPBCGRMsgType.ServerAutoReconnectStatusPdu) == 0x32))
                {
                    var m = BinaryDecoder<ServerAutoReconnectStatusPdu[encryptionLevel, encryptionMethod]>(payload);
                    if (m != nothing)
                    {
                        var msg = m as ServerAutoReconnectStatusPdu;
                        dispatch endpoint Server issues msg;
                    }
                    else
                    {
                        ThrowDecodingException("RDPBCGR", "ServerAutoReconnectStatusPdu");
                    }
                }
                // 2.2.5.1   Server Set Error Info PDU
                else if ((GetPduType(payload, encryptionLevel, encryptionMethod, RDPBCGRMsgType.ServerSetErrorInfoPdu)) == 0x07 &&
                (GetPdu2Type(payload, encryptionLevel, encryptionMethod, RDPBCGRMsgType.ServerSetErrorInfoPdu) == 0x2F))
                {
                    var m = BinaryDecoder<ServerSetErrorInfoPdu[encryptionLevel, encryptionMethod]>(payload);
                    if (m != nothing)
                    {
                        var msg = m as ServerSetErrorInfoPdu;
                        dispatch endpoint Server issues msg;
                    }
                    else
                    {
                        ThrowDecodingException("RDPBCGR", "ServerSetErrorInfoPdu");
                    }
                }
                // 2.2.5.2   Server Status Info PDU
                else if ((GetPduType(payload, encryptionLevel, encryptionMethod, RDPBCGRMsgType.ServerStatusInfoPdu)) == 0x07 &&
                (GetPdu2Type(payload, encryptionLevel, encryptionMethod, RDPBCGRMsgType.ServerStatusInfoPdu) == 0x36))
                {
                    var m = BinaryDecoder<ServerStatusInfoPdu[encryptionLevel, encryptionMethod]>(payload);
                    if (m != nothing)
                    {
                        var msg = m as ServerStatusInfoPdu;
                        dispatch endpoint Server issues msg;
                    }
                    else
                    {
                        ThrowDecodingException("RDPBCGR", "ServerStatusInfoPdu");
                    }
                }
                // 2.2.8.2.1   Server Set Keyboard Indicators PDU
                else if ((GetPduType(payload, encryptionLevel, encryptionMethod, RDPBCGRMsgType.ServerSetKeyboardIndicatorsPdu)) == 0x07 &&
                (GetPdu2Type(payload, encryptionLevel, encryptionMethod, RDPBCGRMsgType.ServerSetKeyboardIndicatorsPdu) == 0x29))
                {
                    var m = BinaryDecoder<ServerSetKeyboardIndicatorsPdu[encryptionLevel, encryptionMethod]>(payload);
                    if (m != nothing)
                    {
                        var msg = m as ServerSetKeyboardIndicatorsPdu;
                        dispatch endpoint Server issues msg;
                    }
                    else
                    {
                        ThrowDecodingException("RDPBCGR", "ServerSetKeyboardIndicatorsPdu");
                    }
                }
                // 2.2.8.2.2   Server Set Keyboard IME Status PDU
                else if ((GetPduType(payload, encryptionLevel, encryptionMethod, RDPBCGRMsgType.ServerSetKeyboardIMEStatusPdu)) == 0x07 &&
                (GetPdu2Type(payload, encryptionLevel, encryptionMethod, RDPBCGRMsgType.ServerSetKeyboardIMEStatusPdu) == 0x2D))
                {
                    var m = BinaryDecoder<ServerSetKeyboardIMEStatusPdu[encryptionLevel, encryptionMethod]>(payload);
                    if (m != nothing)
                    {
                        var msg = m as ServerSetKeyboardIMEStatusPdu;
                        dispatch endpoint Server issues msg;
                    }
                    else
                    {
                        ThrowDecodingException("RDPBCGR", "ServerSetKeyboardIMEStatusPdu");
                    }
                }
                // 2.2.9.1.1.3   Server Graphics Update PDU (TS_GRAPHICS_PDU)
                else if ((GetPduType(payload, encryptionLevel, encryptionMethod, RDPBCGRMsgType.TSGraphicsPdu)) == 0x07 &&
                (GetPdu2Type(payload, encryptionLevel, encryptionMethod, RDPBCGRMsgType.TSGraphicsPdu) == 0x02))
                {
                    var m = BinaryDecoder<TSGraphicsPdu[encryptionLevel, encryptionMethod]>(payload);
                    if (m != nothing)
                    {
                        var msg = m as TSGraphicsPdu;
                        // Decode order data
                        foreach (var update in msg.SlowPathGraphicsUpdates)
                        {
                            if (update is updateOrder:UpdateOrdersPDUData)
                            {
                                binary data = updateOrder.OrderData as binary;
                                int orderNum = 0;
                                stream str = data;
                                array<any> orders = [];
                                while (orderNum < updateOrder.NumberOrders && str.RemainingByteLength > 0)
                                {
                                    var order = DecodingOrderData(str, OrderType);
                                    if (order != nothing)
                                    {
                                        orderNum ++;
                                        orders += [order];
                                        if (order is o:PRIMARY_DRAWING_ORDER && o.orderType != nothing)
                                        {
                                            OrderType = o.orderType as byte;
                                        }
                                    }
                                    else
                                    {
                                        uint len = str.RemainingByteLength as uint;
                                        orders += [(BinaryDecoder<Blob[len]>(str) as Blob[len]).Data];
                                        ValidationCheck(false, null, DiagnosisLevel.Error, () => Format(RDPBCGR_ORDER_DECODE_ERROR_STR, ["UpdateOrdersPDUData"]));
                                        break;
                                    }
                                }
                                updateOrder.OrderData = orders;
                                bool decodeSucceed = true;
                                while (str.RemainingByteLength > 0 && decodeSucceed)
                                {
                                    switch (str)
                                    {
                                        case u:TSUpdateBitmap from BinaryDecoder<TSUpdateBitmap> =>
                                            msg.SlowPathGraphicsUpdates += [u];
                                        case u:TSUpdatePalette from BinaryDecoder<TSUpdatePalette> =>
                                            msg.SlowPathGraphicsUpdates += [u];
                                        case u:TSUpdateSync from BinaryDecoder<TSUpdateSync> =>
                                            msg.SlowPathGraphicsUpdates += [u];
                                        default =>
                                            decodeSucceed = false;
                                    }
                                }
                            }
                        }
                        dispatch endpoint Server issues msg;
                    }
                    else
                    {
                        ThrowDecodingException("RDPBCGR", "TSGraphicsPdu");
                    }
                }
                // 2.2.9.1.1.4   Server Pointer Update PDU (TS_POINTER_PDU)
                else if ((GetPduType(payload, encryptionLevel, encryptionMethod, RDPBCGRMsgType.TSPointerPdu)) == 0x07 &&
                (GetPdu2Type(payload, encryptionLevel, encryptionMethod, RDPBCGRMsgType.TSPointerPdu) == 0x1B))
                {
                    var m = BinaryDecoder<TSPointerPdu[encryptionLevel, encryptionMethod]>(payload);
                    if (m != nothing)
                    {
                        var msg = m as TSPointerPdu;
                        dispatch endpoint Server issues msg;
                    }
                    else
                    {
                        ThrowDecodingException("RDPBCGR", "TSPointerPdu");
                    }
                }
                // 2.2.9.1.1.5   Server Play Sound PDU
                else if ((GetPduType(payload, encryptionLevel, encryptionMethod, RDPBCGRMsgType.ServerPlaySoundPdu)) == 0x07 &&
                (GetPdu2Type(payload, encryptionLevel, encryptionMethod, RDPBCGRMsgType.ServerPlaySoundPdu) == 0x22))
                {
                    var m = BinaryDecoder<ServerPlaySoundPdu[encryptionLevel, encryptionMethod]>(payload);
                    if (m != nothing)
                    {
                        var msg = m as ServerPlaySoundPdu;
                        dispatch endpoint Server issues msg;
                    }
                    else
                    {
                        ThrowDecodingException("RDPBCGR", "ServerPlaySoundPdu");
                    }
                }
                // 2.2.10.1   Server Save Session Info PDU
                else if ((GetPduType(payload, encryptionLevel, encryptionMethod, RDPBCGRMsgType.ServerSaveSessionInfoPdu)) == 0x07 &&
                (GetPdu2Type(payload, encryptionLevel, encryptionMethod, RDPBCGRMsgType.ServerSaveSessionInfoPdu) == 0x26))
                {
                    var m = BinaryDecoder<ServerSaveSessionInfoPdu[encryptionLevel, encryptionMethod]>(payload);
                    if (m != nothing)
                    {
                        var msg = m as ServerSaveSessionInfoPdu;
                        dispatch endpoint Server issues msg;
                    }
                    else
                    {
                        ThrowDecodingException("RDPBCGR", "ServerSaveSessionInfoPdu");
                    }
                }
                // 2.2.12.1   Monitor Layout PDU
                else if ((GetPduType(payload, encryptionLevel, encryptionMethod, RDPBCGRMsgType.MonitorLayoutPdu)) == 0x07 &&
                (GetPdu2Type(payload, encryptionLevel, encryptionMethod, RDPBCGRMsgType.MonitorLayoutPdu) == 0x37))
                {
                    var m = BinaryDecoder<MonitorLayoutPdu[encryptionLevel, encryptionMethod]>(payload);
                    if (m != nothing)
                    {
                        var msg = m as MonitorLayoutPdu;
                        dispatch endpoint Server issues msg;
                    }
                    else
                    {
                        ThrowDecodingException("RDPBCGR", "MonitorLayoutPdu");
                    }
                }                
                // 2.2.13.3.1   Enhanced Security Server Redirection PDU (TS_ENHANCED_SECURITY_SERVER_REDIRECTION)
                else if ((GetPduType(payload, encryptionLevel, encryptionMethod, RDPBCGRMsgType.TSEnhancedSecurityServerRedirection)) == 0x0A)
                {
                    var m = BinaryDecoder<TSEnhancedSecurityServerRedirection>(payload);
                    if (m != nothing)
                    {
                        var msg = m as TSEnhancedSecurityServerRedirection;
                        dispatch endpoint Server issues msg;
                    }
                    else
                    {
                        ThrowDecodingException("RDPBCGR", "TSEnhancedSecurityServerRedirection");
                    }
                } 
                // 2.2.13.2.1   Standard Security Server Redirection PDU (TS_STANDARD_SECURITY_SERVER_REDIRECTION)
                else if ((GetPdu2Type(payload, encryptionLevel, encryptionMethod, RDPBCGRMsgType.TSStandardSecurityServerRedirectionPdu) & 0x04) == 0x04)
                {
                    var m = BinaryDecoder<TSStandardSecurityServerRedirectionPdu[encryptionLevel, encryptionMethod]>(payload);
                    if (m != nothing)
                    {
                        var msg = m as TSStandardSecurityServerRedirectionPdu;
                        dispatch endpoint Server issues msg;
                    }
                    else
                    {
                        ThrowDecodingException("RDPBCGR", "TSStandardSecurityServerRedirectionPdu");
                    }
                }
                else 
                {
                    reject;
                }
            }
            else if (channelId == mcsMessageChannelId) // if channelId is mcsMessageChannelId, the pdu should be Server Auto-Detect Request PDU or Server Initiate Multitransport Request
            {
                // 2.2.14.3   Server Auto-Detect Request PDU
                if (IsAutoDetectMsg(payload, encryptionLevel, encryptionMethod, RDPBCGRMsgType.ServerAutoDetectRequestPdu))
                {
                    var m = BinaryDecoder<ServerAutoDetectRequestPdu[encryptionLevel, encryptionMethod]>(payload);
                    if (m != nothing)
                    {
                        var msg = m as ServerAutoDetectRequestPdu;
                        dispatch endpoint Server issues msg;
                    }
                    else
                    {
                        ThrowDecodingException("RDPBCGR", "ServerAutoDetectRequestPdu");
                    }
                }
                // 2.2.15.1   Server Initiate Multitransport Request
                else if ((payload[0] & 0x02) == 0x02)
                {
                    var m = BinaryDecoder<ServerInitiateMultitransportRequest[encryptionLevel, encryptionMethod]>(payload);
                    if (m != nothing)
                    {
                        var msg = m as ServerInitiateMultitransportRequest;
                        dispatch endpoint Server issues msg;
                    }
                    else
                    {
                        ThrowDecodingException("RDPBCGR", "ServerInitiateMultitransportRequest");
                    }
                }
                else 
                {
                    reject;
                }
            }
            else // channelId in channelNamesMap.Keys
            {
                // 2.2.6.1   Virtual Channel PDU
                if (channelId in channelNamesMap.Keys)
                {
                    var m = BinaryDecoder<VirtualChannelPdu[encryptionLevel, encryptionMethod]>(payload);
                        
                    if (m != nothing)
                    {
                        var msg = m as VirtualChannelPdu;
                        msg#ChannelName = channelNamesMap[channelId];  
                        if ((msg.ChannelPduHeader.Flags & ChannelPduHeaderFlags.ChannelPacketCompressed) == ChannelPduHeaderFlags.ChannelPacketCompressed)
                        {
                           // If virtualChannelData is compressed, only show it as top level message
                            DisplayTopLevelMessage(msg);
                        }
                        else
                        {                            
                            dispatch endpoint Server issues msg;                          
                        }
                    }
                    else
                    {
                        ThrowDecodingException("RDPBCGR", "VirtualChannelPdu");
                    }
                }
            }
        }
        // 2.2.1.7   Server MCS Attach User Confirm PDU
        else if (domainMCSPDU.DomainMCSPDU is T125.AttachUserConfirmPattern)
        {
            ServerMCSAttachUserConfirmPdu m = new ServerMCSAttachUserConfirmPdu{};
            m.Origins = [domainMCSPDU];
            dispatch endpoint Server issues m;
        }
        // 2.2.1.9   Server MCS Channel Join Confirm PDU
        else if (domainMCSPDU.DomainMCSPDU is T125.ChannelJoinConfirmPattern)
        {
            ServerMCSChannelJoinConfirmPdu m = new ServerMCSChannelJoinConfirmPdu{};
            m.Origins = [domainMCSPDU];
            dispatch endpoint Server issues m;
        }
        // 2.2.2.3   MCS Disconnect Provider Ultimatum PDU
        else if (domainMCSPDU.DomainMCSPDU is T125.DisconnectProviderUltimatumPattern)
        {
            McsDisconnectProviderUltimatumPdu m = new McsDisconnectProviderUltimatumPdu{};
            m.Origins = [domainMCSPDU];
            dispatch endpoint Server issues m;
        }
        else
        {
            // When ServerMCSConnectResponsePDU is lost, only attach the error message to the first unparsed RDPBCGR message.
            if (initialFlag && !ServerMCSConnectResponsePDUReceived)
            {
                ErrorCodeIf(true, domainMCSPDU, DiagnosisLevel.Warning, "RDPBCGR: Lack of MCS channel IDs, encryptionMethod and encryptionLevel due to missing Server MCS Connect Response PDU message."); 
                initialFlag = false;
            }
            reject;
        }
    }
}

// This actor is used to handle RDP stream from ReassembledTCP, dispatch slow-path message to ISOTS, and dispath fast-path message to RDPBCGR
autostart actor RDPStreamOverTCP(ReassembledTCP.Server server)
{
    DecodingCache inboundCache = null;
    DecodingCache outboundCache = null;
    
    process server accepts s:ReassembledTCP.VirtualDataSegment 
        where s.DestinationPort == Port.RDP && IsRDPStreamOverTCP(s)
    {
        // Initialize cache if not yet.
        if (inboundCache == null)
        {
            inboundCache = new DecodingCache{ TPKTDispatcher = AcceptTPKTDispatcher, AcceptFPPDUDispatcher = AcceptFPPDUDispatcher };
        }
        
        inboundCache.Add(s);
        inboundCache.TryDecodeMsgAndDispatch(true);
    }

    process server issues s:ReassembledTCP.VirtualDataSegment 
        where s.SourcePort == Port.RDP && IsRDPStreamOverTCP(s)
    {
        // Initialize cache if not yet.
        if (outboundCache == null)
        {
            outboundCache = new DecodingCache{ TPKTDispatcher = IssueTPKTDispatcher, IssueFPPDUDispatcher = IssueFPPDUDispatcher};
        }
        
        if (TryDecodeEarlyUserAuthorizationResultPdu(s.Payload, s.DestinationPort as ulong) is msg:EarlyUserAuthorizationResultPdu)
        {
            dispatch endpoint Server issues msg;
            return;
        }
                
        outboundCache.Add(s);
        outboundCache.TryDecodeMsgAndDispatch(false);
    }
    
    process server issues s:ReassembledTCP.VirtualDataSegment 
        where server.isMissingThreeWayHandshake && s.DestinationPort == Port.RDP && IsRDPStreamOverTCP(s)
    {
        // Initialize cache if not yet.
        if (inboundCache == null)
        {
            inboundCache = new DecodingCache{ TPKTDispatcher = AcceptTPKTDispatcher, AcceptFPPDUDispatcher = AcceptFPPDUDispatcher };
        }
        
        inboundCache.Add(s);
        inboundCache.TryDecodeMsgAndDispatch(true);
    }

    process server accepts s:ReassembledTCP.VirtualDataSegment 
        where server.isMissingThreeWayHandshake && s.SourcePort == Port.RDP && IsRDPStreamOverTCP(s)
    {
        // Initialize cache if not yet.
        if (outboundCache == null)
        {
            outboundCache = new DecodingCache{ TPKTDispatcher = IssueTPKTDispatcher, IssueFPPDUDispatcher = IssueFPPDUDispatcher};
        }

        if (TryDecodeEarlyUserAuthorizationResultPdu(s.Payload, s.DestinationPort as ulong) is msg:EarlyUserAuthorizationResultPdu)
        {
            dispatch endpoint Server issues msg;
            return;
        }
                
        outboundCache.Add(s);
        outboundCache.TryDecodeMsgAndDispatch(false);
    }
        
    void AcceptTPKTDispatcher(ISOTS.TPKT tpkt)
    {
        dispatch endpoint ISOTS.Server over server accepts tpkt;
    }
    
    void IssueTPKTDispatcher(ISOTS.TPKT tpkt)
    {
        dispatch endpoint ISOTS.Server over server issues tpkt;
    }
    
     void AcceptFPPDUDispatcher(TSFPInputEventPdu inputEventPdu)
    {
        dispatch endpoint Server over server accepts inputEventPdu;
    }
    
    void IssueFPPDUDispatcher((TSFPUpdatePdu) updatePdu)
    {
        dispatch endpoint Server over server issues (updatePdu as TSFPUpdatePdu);
    }
    
    ~endpoint(ReassembledTCP.Server server)
    {
        if (inboundCache != null)
        {
            inboundCache.Clear();
        }
        if (outboundCache != null)
        {
            outboundCache.Clear();
        }
    }
    
    bool IsRDPStreamOverTCP(ReassembledTCP.VirtualDataSegment segment)
    {
        // 0x30 is the beginning of CredSSP message
        return segment.Payload[0] != 0x30;
    }
}

optional EarlyUserAuthorizationResultPdu TryDecodeEarlyUserAuthorizationResultPdu(binary data, ulong indexPort)
{
    long selectedProtocol = (indexPort in selectedProtocols) ? selectedProtocols[indexPort] : -1;
    if (selectedProtocol == SelectedProtocol.ProtocolHybridEX &&
        data.Count == 4)
    {
        return BinaryDecoder<EarlyUserAuthorizationResultPdu>(data);
    }
    return nothing;
}

pattern LowerMsg = enum uint
{
    T125ConnectInitial,
    T125ConnectResponse,
    T124ConnectData,
    T124ConferenceCreateRequest,
    T124ConferenceCreateResponse,
    T125SendDataRequest,
    T125SendDataRequestPer,
    T125SendDataIndication,
    T125SendDataIndicationPer
} with Documentation {EmbeddedType = true};

pattern RDPBCGRMsgType = enum uint
{
    ClientMcsConnectInitialPduWithGccConferenceCreateRequest,
    ServerMCSConnectResponsePDUWithGccConferenceCreateResponse,
    ClientSecurityExchangePdu,
    ClientInfoPdu,
    ServerDemandActivePdu,
    ClientConfirmActivePdu,
    ClientSynchronizePdu,
    ClientControlPduCoOperate,
    ClientControlPduRequestControl,
    ClientPersistentKeyListPdu,
    ClientFontListPdu,
    ServerSynchronizePdu,
    ServerControlPduCoOperate,
    ServerControlPduGrantedControl,
    ServerFontMapPdu,
    ClientShutdownRequestPdu,
    ServerShutdownRequestDeniedPdu,
    ServerDeactivateAllPdu,
    ServerAutoReconnectStatusPdu,
    VirtualChannelPduRequest,
    VirtualChannelPduResponse,
    TSInputPDU,
    ServerSetKeyboardIndicatorsPdu,
    ServerSetKeyboardIMEStatusPdu,
    TSGraphicsPdu,
    TSPointerPdu,
    ServerPlaySoundPdu,
    ServerSaveSessionInfoPdu,
    MonitorLayoutPdu,
    ClientRefreshRectPdu,
    ClientSuppressOutputPdu,
    TSStandardSecurityServerRedirectionPdu,
    TSEnhancedSecurityServerRedirection,
    ServerAutoDetectRequestPdu,
    ClientAutoDetectResponsePdu,
    ServerSetErrorInfoPdu,
    ServerStatusInfoPdu,
};

int GetPduType(binary payload, TSUDSCSec1EncryptionLevel encryptionLevel, TSUDSCSec1EncryptionMethod encryptionMethod, RDPBCGRMsgType msgType)
{
    int msgOffset = 0;
    
    if (encryptionLevel == TSUDSCSec1EncryptionLevel.EncryptionLevelLow)
    {
        msgOffset = msgOffset + 4;
    }
    else if (encryptionMethod in {TSUDSCSec1EncryptionMethod.EncryptionMethod40Bit,
                                 TSUDSCSec1EncryptionMethod.EncryptionMethod128Bit,
                                 TSUDSCSec1EncryptionMethod.EncryptionMethod56Bit})
    {
        msgOffset = msgOffset + 12;
    }
    else if (encryptionMethod == TSUDSCSec1EncryptionMethod.EncryptionMethodFips)
    {
        msgOffset = msgOffset + 16;
    }
    msgOffset = msgOffset + 2;
    // If payload length is not greater than msgOffset, return an invalid pdu type.
    if (payload.Count <= msgOffset)
    {
        return 0x00;
    }
    if (msgType == RDPBCGRMsgType.ServerDeactivateAllPdu)
    {
        if (payload[msgOffset] == 0x16)
        {
            return 0x06;
        }
        else
        {
            return 0x00;
        }
    }
    else
    {
        return payload[msgOffset] & 0x0F;
    }
}
    
int GetPdu2Type(binary payload, TSUDSCSec1EncryptionLevel encryptionLevel, TSUDSCSec1EncryptionMethod encryptionMethod, RDPBCGRMsgType msgType)
{
    int msgOffset = 0;
    byte securityFlag = payload[0];
    if (msgType == RDPBCGRMsgType.TSStandardSecurityServerRedirectionPdu)
        return securityFlag;
    if (encryptionLevel == TSUDSCSec1EncryptionLevel.EncryptionLevelLow)
    {
        msgOffset = msgOffset + 4;
    }
    else if (encryptionMethod in {TSUDSCSec1EncryptionMethod.EncryptionMethod40Bit,
                                    TSUDSCSec1EncryptionMethod.EncryptionMethod128Bit,
                                    TSUDSCSec1EncryptionMethod.EncryptionMethod56Bit})
    {
        msgOffset = msgOffset + 12;
    }
       else if (encryptionMethod == TSUDSCSec1EncryptionMethod.EncryptionMethodFips)
    {
        msgOffset = msgOffset + 16;
    }
    if ((msgType != RDPBCGRMsgType.TSStandardSecurityServerRedirectionPdu) && msgType != (RDPBCGRMsgType.ServerAutoDetectRequestPdu))
    {
        msgOffset = msgOffset + 14;
    }
    // If payload length is not greater than msgOffset, return an invalid pdu type.
    if (payload.Count <= msgOffset)
    {
        return 0x00;
    }
    else if (payload.Count == msgOffset + 1)
    {
        return payload[msgOffset];
    }
    if ((msgType == RDPBCGRMsgType.ServerAutoDetectRequestPdu) && 
       ((securityFlag & 0x10) == 0x10) && 
       (payload[msgOffset] == 0x06) && 
       (payload[msgOffset + 1] == 0x00))
        return msgOffset;
    else if ((msgType == RDPBCGRMsgType.ClientAutoDetectResponsePdu) &&
            ((securityFlag & 0x20) == 0x20) && 
            (payload[msgOffset] == 0x06) && 
            (payload[msgOffset + 1] == 0x01))
        return msgOffset;
    else
        return payload[msgOffset];
}

// 2.2.1.1   Client X.224 Connection Request PDU
message ClientX224ConnectionRequestPdu[bool stringPresent]
{
    // Same with cookie
    optional [|stringPresent == true|] string RoutingToken with BinaryEncoding{TextEncoding = TextEncoding.ASCII, TextTerminator = "\n"},
        Documentation
            {Description = "An optional and variable-length routing token (used for load balancing) terminated by a 0x0D0A two-byte sequence. For more information about the routing token format, see [MSFT-SDLBTS] \"Routing Token Format\". The length of the routing token and CR+LF sequence is included in the X.224 Connection Request Length Indicator field. If this field is present, then the cookie field MUST NOT be present."};
  
    optional RdpNegReq RdpNegData
        with Documentation
           {Description = "An optional RDP Negotiation Request structure. The length of this negotiation structure is included in the X.224 Connection Request Length Indicator field."};
    
    override string ToString()
    {
       string summary = "Client X.224 Connection Request PDU";
       if (RdpNegData != nothing)
       {
           summary += ", RequestedProtocols: " + EnumToString((RdpNegData as RdpNegReq).RequestedProtocols, "RDPBCGR.RequestedProtocols");
       }
       return summary;
    }
}
with Documentation
       {Applicability = "2.2.1.1",
        Description = "The X.224 Connection Request PDU is an RDP Connection Sequence PDU sent from client to server during the Connection Initiation phase of the RDP Connection Sequence (see section  for an overview of the RDP Connection Sequence phases)."};

// 2.2.1.1.1   RDP Negotiation Request (RDP_NEG_REQ)
type RdpNegReq
{
    (byte where value == 1) Type
        with Documentation
           {Description = "An 8-bit, unsigned integer. Negotiation packet type. This field MUST be set to 0x01 (TYPE_RDP_NEG_REQ) to indicate that the packet is a Negotiation Request."};
  
    byte Flags where ValidationCheckZero(value == 0, null, true, ReferenceType.Type, "RDPBCGR", "Flags", "RdpNegReq", value)
        with Documentation
           {Description = "An 8-bit, unsigned integer. Negotiation packet flags. There are currently no defined flags so the field MUST be set to 0x00."};
  
    ushort Length where ValidationCheckValue(value == 8, null, true, ReferenceType.Type, "RDPBCGR", "Length", "RdpNegReq", 8, value)
        with Documentation
           {Description = "A 16-bit, unsigned integer. Indicates the packet size. This field MUST be set to 0x0008 (8 bytes)."};
  
    RequestedProtocols RequestedProtocols 
        where ValidationCheckCombinationValueIncludeZero(InRange<RequestedProtocols>(value), null, false, ReferenceType.Type, "RDPBCGR", "RequestedProtocols", "RdpNegReq", "0x00000001, 0x00000002, 0x00000008", value)
        with Documentation
           {Description = "A 32-bit, unsigned integer. Flags indicating the supported security protocols."};
}
with Documentation
       {Applicability = "2.2.1.1.1",
        Description = "The RDP Negotiation Request structure is used by a client to advertise the security protocols which it supports."};

// flags pattern        
pattern RequestedProtocols = flags uint 
{
    ProtocolRdp = 0x00000000
        with Documentation {Description = "Standard RDP Security."},
    ProtocolSsl = 0x00000001
        with Documentation {Description = "TLS 1.0, 1.1 or 1.2"},
    ProtocolHybrid = 0x00000002
        with Documentation
                {Description = "Credential Security Support Provider protocol (CredSSP). If this flag is set, then the ProtocolSsl (0x00000001) SHOULD also be set because Transport Layer Security (TLS) is a subset of CredSSP."},
    ProtocolHybridEX = 0x00000008
        with Documentation {Description = "Credential Security Support Provider protocol (CredSSP) (section 5.4.5.2) coupled with the Early User Authorization Result PDU (section 2.2.10.2).If this flag is set, then the PROTOCOL_HYBRID (0x00000002) flag SHOULD also be set. For more information on the sequencing of the CredSSP messages and the Early User Authorization Result PDU, see sections 5.4.2.1 and 5.4.2.2."},
    ...
} with Documentation {EmbeddedType = true};

// 2.2.1.2   Server X.224 Connection Confirm PDU
message ServerX224ConnectionConfirmPdu
{
    optional (RdpNegRsp | RdpNegFailure) RdpNegData
        with Documentation
           {Description = "Optional RDP Negotiation Response structure or an optional RDP Negotiation Failure structure. The length of the negotiation structure is included in the X.224 Connection Confirm Length Indicator field."};
    
    override string ToString()
    {
        string summary = "Server X.224 Connection Confirm PDU";
        if (RdpNegData != nothing && RdpNegData is RdpNegRsp)
        {
            summary += ", SelectedProtocol: " + EnumToString((RdpNegData as RdpNegRsp).SelectedProtocol, "RDPBCGR.SelectedProtocol");
        }
        return summary;
    }
}
with Documentation
       {Applicability = "2.2.1.2",
        Description = "The X.224 Connection Confirm PDU is an RDP Connection Sequence PDU sent from server to client during the Connection Initiation phase of the RDP Connection Sequence (see section  for an overview of the RDP Connection Sequence phases). It is sent as a response to the X.224 Connection Request PDU."};

// 2.2.1.2.1   RDP Negotiation Response (RDP_NEG_RSP)
type RdpNegRsp
{
    (byte where value == 0x02) Type
        with Documentation
           {Description = "An 8-bit, unsigned integer. Negotiation packet type. This field MUST be set to 0x02 (TYPE_RDP_NEG_RSP) to indicate that the packet is a Negotiation Response."};

    RdpNegRspFlags Flags where ValidationCheckCombinationValueIncludeZero(InRange<RdpNegRspFlags>(value), null, false, ReferenceType.Type, "RDPBCGR", "Flags", "RdpNegRsp", "0x01, 0x02, 0x04", value)
        with Documentation
           {Description = "An 8-bit, unsigned integer. Negotiation packet flags."};
  
    ushort Length where ValidationCheckValue(value == 0x0008, null, true, ReferenceType.Type, "RDPBCGR", "Length", "RdpNegRsp", "0x0008", value)
        with Documentation
           {Description = "A 16-bit, unsigned integer. Indicates the packet size. This field MUST be set to 0x0008 (8 bytes)"};

    SelectedProtocol SelectedProtocol where ValidationCheckEnumValue(InRange<SelectedProtocol>(value), null, false, ReferenceType.Type, "RDPBCGR", "SelectedProtocol", "RdpNegRsp", "0x00000000, 0x00000001, 0x00000002, 0x00000008", value)
        with Documentation
           {Description = "A 32-bit, unsigned integer. Field indicating the selected security protocol."};
}
with Documentation
       {Applicability = "2.2.1.2.1", Description = "windows_8_beta_portion"};

pattern SelectedProtocol = enum uint
{
    ProtocolRdp = 0x00000000
        with Documentation {Description = "Standard RDP Security"},
    ProtocolSsl = 0x00000001
        with Documentation {Description = "TLS 1.0, 1.1 or 1.2"},
    ProtocolHybrid = 0x00000002
        with Documentation {Description = "CredSSP"},
    ProtocolHybridEX = 0x00000008
        with Documentation {Description = "CredSSP coupled with the Early User Authorization Result PDU"},
    ...
} with Documentation {EmbeddedType = true};
  
pattern RdpNegRspFlags = flags byte
{
    EXTENDED_CLIENT_DATA_SUPPORTED = 0x01
        with Documentation
                {Description = "The server supports Extended Client Data Blocks in the GCC Conference Create Request user data."},
    DYNVC_GFX_PROTOCOL_SUPPORTED = 0x02
        with Documentation
                {Description = "The server supports the Graphics Pipeline Extension Protocol described in [MS-RDPEGFX] sections 1 to 3."},
    NEGRSP_FLAG_RESERVED = 0x04
        with Documentation
                {Description = "An unused flag that is reserved for future use."},
    RESTRICTED_ADMIN_MODE_SUPPORTED = 0x08,
    ...
} with Documentation {EmbeddedType = true};

// 2.2.1.2.2   RDP Negotiation Failure (RDP_NEG_FAILURE)
type RdpNegFailure
{
    (byte where value == 0x03) Type
        with Documentation
           {Description = "An 8-bit, unsigned integer. Negotiation packet type. This field MUST be set to 0x03 (TYPE_RDP_NEG_FAILURE) to indicate that the packet is a Negotiation Failure."};
  
    (byte where value == 0x00) Flags
        with Documentation
           {Description = "An 8-bit, unsigned integer. Negotiation packet flags. There are currently no defined flags so the field MUST be set to 0x00."};
  
    (ushort where value == 0x0008) Length
        with Documentation
           {Description = "A 16-bit, unsigned integer. Indicates the packet size. This field MUST be set to 0x0008 (8 bytes)."};
  
    RdpNegFailureFailureCode FailureCode
        with Documentation
           {Description = "A 32-bit, unsigned integer. Field containing the failure code."};
}
with Documentation
       {Applicability = "2.2.1.2.2",
        Description = "The RDP Negotiation Failure structure is used by a server to inform the client of a failure that has occurred while preparing security for the connection."};

pattern RdpNegFailureFailureCode = enum uint
{
    SslRequiredByServer = 0x00000001
        with Documentation
                {Description = "The server requires that the client support Enhanced RDP Security with either TLS 1.0 or CredSSP. If only CredSSP was requested then the server only supports TLS."},
    SslNotAllowedByServer = 0x00000002
        with Documentation
                {Description = "The server is configured to only use Standard RDP Security mechanisms and does not support any External Security Protocols."},
    SslCertNotOnServer = 0x00000003
        with Documentation
                {Description = "The server does not possess a valid authentication certificate and cannot initialize the External Security Protocol Provider."},
    InconsistentFlags = 0x00000004
        with Documentation
                {Description = "The list of requested security protocols is not consistent with the current security protocol in effect. This error is only possible when the Direct Approach (see sections  and ) is used and an External Security Protocol is already being used."},
    HybridRequiredByServer = 0x00000005
        with Documentation
                {Description = "The server requires that the client support Enhanced RDP Security with CredSSP."},
    SslWithUserAuthRequiredByServer = 0x00000006
        with Documentation
                {Description = "The server requires that the client support Enhanced RDP Security with TLS 1.0 and certificate-based client authentication.The SslWithUserAuthRequiredByServer (0x00000006) failure code is only sent by Microsoft RDP 6.0 servers."}
} with Documentation {EmbeddedType = true};

// 2.2.1.3   Client MCS Connect Initial PDU with GCC Conference Create Request
message ClientMcsConnectInitialPduWithGccConferenceCreateRequest
{
    /*TSUDCSCore ClientCoreData
        with Documentation {Description = "Client Core Data structure."};
    
    optional TSUDCSCluster ClientClusterData
        with Documentation
           {Description = "Optional Client Cluster Data structure."};
  
    optional TSUDCSSec ClientSecurityData
        with Documentation {Description = "Client Security Data structure."};
  
    optional TSUDCSNet ClientNetworkData
        with Documentation
           {Description = "Optional and variable-length Client Network Data structure."};
  
    optional TSUDCSMonitor ClientMonitorData
        with Documentation
           {Description = "Optional Client Monitor Data structure. This field MUST NOT be included if the server did not advertise support for Extended Client Data Blocks by using the EXTENDED_CLIENT_DATA_SUPPORTED flag (0x00000001) as described in section ."};*/
    array<TSUDCSType> TSUD;
    
    override string ToString()
    {
        string summary = "Client MCS Connect Initial PDU with GCC Conference Create Request";
        foreach (var tsud in TSUD)
        {
            if (tsud is TSUDCSSec)
            {
                summary += ", EncryptionMethods: " + EnumToString((tsud as TSUDCSSec).EncryptionMethods, "RDPBCGR.TSUDCSSecEncryptionMethods");
            }
            else if (tsud is TSUDCSNet)
            {
                summary += ", " + tsud.ToString(); 
            }
        }
        return summary;
    }
}
with Documentation
       {Applicability = "2.2.1.3",
        Description = "The MCS Connect Initial PDU is an RDP Connection Sequence PDU sent from client to server during the Basic Settings Exchange phase of the RDP Connection Sequence (see section  for an overview of the RDP Connection Sequence phases). It is sent after receiving the X.224 Connection Confirm PDU. The MCS Connect Initial PDU encapsulates a GCC Conference Create Request, which encapsulates concatenated blocks of settings data. A basic high-level overview of the nested structure for the Client MCS Connect Initial PDU is illustrated in section , in the figure specifying MCS Connect Initial PDU. Note that the order of the settings data blocks is allowed to vary from that shown in the previously mentioned figure and the message syntax layout that follows. This is possible because each data block is identified by a User Data Header structure."};

pattern TSUDCSType = TSUDCSCore | TSUDCSCluster | TSUDCSSec | TSUDCSNet | TSUDCSMonitor | TSUDCSMcsMsgChannel | TSUDCSMultiTransPort | TSUDUndefinedType;

// 2.2.1.3.1   User Data Header (TSUDHeader)
type TSUDHeader
{
    TSUDHeaderType Type
        with Documentation
           {Description = "A 16-bit, unsigned integer. The type of the data block that this header precedes."};
  
    ushort Length
        with Documentation
           {Description = "A 16-bit, unsigned integer. The size in bytes of the data block, including this header."};
}
with Documentation
       {Applicability = "2.2.1.3.1",
        Description = "The TSUDHeader precedes all data blocks in the client and server GCC user data."};

pattern TSUDHeaderType = enum ushort
{
    CSCore = 0xC001
        with Documentation
                {Description = "The data block that follows contains Client Core Data."},
    CSSecurity = 0xC002
        with Documentation
                {Description = "The data block that follows contains Client Security Data."},
    CSNet = 0xC003
        with Documentation
                {Description = "The data block that follows contains Client Network Data."},
    CSCluster = 0xC004
        with Documentation
                {Description = "The data block that follows contains Client Cluster Data."},
    CSMonitor = 0xC005
        with Documentation
                {Description = "The data block that follows contains Client Monitor Data."},
    CSMcsMsgChannel = 0xC006
        with Documentation
                {Description = "The data block that follows contains Client Message Channel Data."},
    CSMultitransport = 0xC00A
        with Documentation
                {Description = "The data block that follows contains Client Multitransport Channel Data."},              
    SCCore = 0x0C01
        with Documentation
                {Description = "The data block that follows contains Server Core Data."},
    SCSecurity = 0x0C02
        with Documentation
                {Description = "The data block that follows contains Server Security Data."},
    SCNet = 0x0C03
        with Documentation
                {Description = "The data block that follows contains Server Network Data."},
    SCMcsMsgChannel = 0x0C04
        with Documentation
                {Description = "The data block that follows contains Server Message Channel Data."},
    SCMultiTransport = 0x0C08
        with Documentation
                {Description = "The data block that follows contains Server Multitransport Channel Data."},
} with Documentation {EmbeddedType = true};

// 2.2.1.3.2   Client Core Data (TS_UD_CS_CORE)
type TSUDCSCore
{
    TSUDHeader Header where value.Type == TSUDHeaderType.CSCore
        with Documentation
           {Description = "GCC user data block header, as specified in section . The User Data Headertype field MUST be set to CS_CORE (0xC001)."};
  
    TSUDCSCoreVersion Version
        with Documentation
           {Description = "A 32-bit, unsigned integer. Client version number for the RDP. The major version number is stored in the high 2 bytes, while the minor version number is stored in the low 2 bytes."};
  
    ushort DesktopWidth
        with Documentation
           {Description = "A 16-bit, unsigned integer. The requested desktop width in pixels (MUST be at least 200 pixels and at most 4096 pixelsvalidation of this field is described in section )."};
  
    ushort DesktopHeight
        with Documentation
           {Description = "A 16-bit, unsigned integer. The requested desktop height in pixels (MUST be at least 200 pixels and at most 2048 pixelsvalidation of this field is described in section )."};
  
    TSUDCSCoreColorDepth ColorDepth
        with Documentation
           {Description = "A 16-bit, unsigned integer. The requested color depth. Values in this field MUST be ignored if the postBeta2ColorDepth field is present."};
  
    ushort SasSequence
        with Documentation
           {Description = "A 16-bit, unsigned integer. Secure access sequence. This field SHOULD be set to RNS_UD_SAS_DEL (0xAA03)."};
  
    uint KeyboardLayout
        with Documentation
           {Description = "A 32-bit, unsigned integer. Keyboard layout (active input locale identifier). For a list of input locale identifiers, see [MSFT-DIL]."};
  
    uint ClientBuild
        with Documentation
           {Description = "A 32-bit, unsigned integer. The build number of the client."};
  
    string ClientName with BinaryEncoding{TextEncoding = TextEncoding.UTF16, Length = 16}
        with Documentation
           {Description = "Name of the client computer. This field contains up to 15 Unicode characters plus a null terminator."};
  
    KeyboardType KeyboardType where ValidationCheckValueInRange(InRange<KeyboardType>(value), null, false, ReferenceType.Type, "RDPBCGR", "KeyboardType", "TSUDCSCore", 0x00000000, 0x00000007, value)
        with Documentation
           {Description = "A 32-bit, unsigned integer. The keyboard type."};
  
    uint KeyboardSubType
        with Documentation
           {Description = "A 32-bit, unsigned integer. The keyboard subtype (an original equipment manufacturer-dependent value)."};
  
    uint KeyboardFunctionKey
        with Documentation
           {Description = "A 32-bit, unsigned integer. The number of function keys on the keyboard."};
  
    string ImeFileName with BinaryEncoding{TextEncoding = TextEncoding.UTF16, Length = 32}
        with Documentation
           {Description = "A 64-byte field. The Input Method Editor (IME) file name associated with the input locale. This field contains up to 31 Unicode characters plus a null terminator."};
  
    optional ([|Header.Length > 132|] TSUDCSCorePostBeta2ColorDepth) PostBeta2ColorDepth
        with Documentation
           {Description = "A 16-bit, unsigned integer. The requested color depth. Values in this field MUST be ignored if the highColorDepth field is present."};

    optional ([|Header.Length > 134|] ushort) ClientProductId
        with Documentation
           {Description = "A 16-bit, unsigned integer. The client product ID. This field SHOULD be initialized to 1. If this field is present, all of the preceding fields MUST also be present. If this field is not present, all of the subsequent fields MUST NOT be present."};
  
    optional ([|Header.Length > 136|] uint) SerialNumber
        with Documentation
           {Description = "A 32-bit, unsigned integer. Serial number. This field SHOULD be initialized to 0. If this field is present, all of the preceding fields MUST also be present. If this field is not present, all of the subsequent fields MUST NOT be present."};
  
    optional ([|Header.Length > 140|] TSUDCSCoreHighColorDepth) HighColorDepth
        with Documentation
           {Description = "A 16-bit, unsigned integer. The requested color depth."};
  
    optional ([|Header.Length > 142|] TSUDCSCoreSupportedColorDepths) SupportedColorDepths
        with Documentation
           {Description = "A 16-bit, unsigned integer. Specifies the high color depths that the client is capable of supporting."};
  
    optional ([|Header.Length > 144|] TSUDCSCoreEarlyCapabilityFlags) EarlyCapabilityFlags where ValidationCheck((value == nothing) || (InRange<TSUDCSCoreEarlyCapabilityFlags>(value as TSUDCSCoreEarlyCapabilityFlags)), null, "RDPBCGR: The EarlyCapabilityFlags field in type TSUDCSCore has one or more undefined bits. Please refer to Client Core Data (TS_UD_CS_CORE) in Technical Document MS-RDPBCGR.") 
        with Documentation
           {Description = "A 16-bit, unsigned integer that specifies capabilities early in the connection sequence."};

    optional ([|Header.Length > 146|] binary) ClientDigProductId with BinaryEncoding {Length = 64},
        Documentation
           {Description = "Contains a value that uniquely identifies the client. If this field is present, all of the preceding fields MUST also be present. If this field is not present, all of the subsequent fields MUST NOT be present."};
  
    optional ([|Header.Length > 210|] TSUDCSCoreConnectionType) ConnectionType
        with Documentation
           {Description = "An 8-bit unsigned integer. Hints at the type of network connection being used by the client. This field only contains valid data if the RnsUDCSValidConnectionType (0x0020) flag is present in the earlyCapabilityFlags field."};
  
    optional ([|Header.Length > 211|] byte) Pad1octet
        with Documentation
           {Description = "An 8-bit, unsigned integer. Padding to align the serverSelectedProtocol field on the correct byte boundary. If this field is present, all of the preceding fields MUST also be present. If this field is not present, all of the subsequent fields MUST NOT be present."};

    optional ([|Header.Length > 212|] SelectedProtocol) ServerSelectedProtocol where ValidationCheckEnumValue((value == nothing) || (InRange<SelectedProtocol>(value as SelectedProtocol)), null,  false, ReferenceType.Type, "RDPBCGR", "SelectedProtocol", "TSUDCSCore", "0x00000000, 0x00000001, 0x00000002, 0x00000008", ((value is nothing) ? "": (value as SelectedProtocol)))
        with Documentation
           {Description = "A 32-bit, unsigned integer that contains the value returned by the server in the selectedProtocol field of the RDP Negotiation Response. In the event that an RDP Negotiation Response was not received from the server, this field MUST be initialized to PROTOCOL_RDP (0). This field MUST be present if an RDP Negotiation Request was sent to the server. If this field is present, then all of the preceding fields MUST also be present. If this field is not present, all of the subsequent fields MUST NOT be present."};
  
    optional ([|Header.Length > 216|] uint) DesktopPhysicalWidth
        with Documentation
           {Description = "A 32-bit, unsigned integer. The requested physical width of the desktop, in millimeters (mm). This value MUST be ignored if it is less than 10 mm or greater than 10,000 mm or desktopPhysicalHeight is less than 10 mm or greater than 10,000 mm. If this field is present, then the serverSelectedProtocol and the desktopPhysicalHeight field MUST also be present. If this field is not present, all of the subsequent fields MUST NOT be present. If the desktopPhysicalHeight field is not present, this field MUST be ignored."};
  
    optional ([|Header.Length > 220|] uint) DesktopPhysicalHeight
        with Documentation
           {Description = "A 32-bit, unsigned integer. The requested physical height of the desktop, in millimeters. This value MUST be ignored if it is less than 10 mm or greater than 10,000 mm or desktopPhysicalWidth is less than 10 mm or greater than 10,000 mm. If this field is present, then the desktopPhysicalWidth field MUST also be present. If this field is not present, all of the subsequent fields MUST NOT be present."};
  
    optional ([|Header.Length > 222|] ushort) Reserved
        with Documentation
           {Description = "A 16-bit, unsigned integer. This field is unused and reserved for future use. It MUST be set to zero. If this field is present, then the desktopPhysicalHeight field MUST also be present."};
}
with Documentation
       {Applicability = "2.2.1.3.2", Description = "windows_8_beta_portion"};

pattern TSUDCSCoreVersion = enum uint
{
    TagAnonyEnumField1 = 0x00080001
        with Documentation {Description = "RDP 4.0 clients"},
    TagAnonyEnumField2 = 0x00080004
        with Documentation
                {Description = "RDP 5.0, 5.1, 5.2, 6.0, 6.1, and 7.0 7.0, 7.1, and 8.0 clients"}
} with Documentation {EmbeddedType = true};

pattern TSUDCSCoreColorDepth =
  enum ushort
  {
    RnsUDColor4Bpp = 0xCA00
      with Documentation {Description = "4 bits-per-pixel (bpp)"},
    RnsUDColor8Bpp = 0xCA01 with Documentation {Description = "8 bpp"}
  } with Documentation {EmbeddedType = true};

pattern TSUDCSCorePostBeta2ColorDepth = enum ushort
{
    RnsUDColor4Bpp = 0xCA00
      with Documentation {Description = "4 bits-per-pixel (bpp)"},
    RnsUDColor8Bpp = 0xCA01 with Documentation {Description = "8 bpp"},
    RnsUDColor16Bpp555 = 0xCA02
      with Documentation
             {Description = "15-bit 555 RGB mask (5 bits for red, 5 bits for green, and 5 bits for blue)"},
    RnsUDColor16Bpp565 = 0xCA03
      with Documentation
             {Description = "16-bit 565 RGB mask (5 bits for red, 6 bits for green, and 5 bits for blue)"},
    RnsUDColor24Bpp = 0xCA04
      with Documentation
             {Description = "24-bit RGB mask (8 bits for red, 8 bits for green, and 8 bits for blue)"}
} with Documentation {EmbeddedType = true};

pattern TSUDCSCoreHighColorDepth = enum ushort
{
    HighColor4Bpp = 0x0004 with Documentation {Description = "4 bpp"},
    HighColor8Bpp = 0x0008 with Documentation {Description = "8 bpp"},
    HighColor15Bpp = 0x000F
      with Documentation
             {Description = "15-bit 555 RGB mask (5 bits for red, 5 bits for green, and 5 bits for blue)"},
    HighColor16Bpp = 0x0010
      with Documentation
             {Description = "16-bit 565 RGB mask (5 bits for red, 6 bits for green, and 5 bits for blue)"},
    HighColor24Bpp = 0x0018
      with Documentation
             {Description = "24-bit RGB mask (8 bits for red, 8 bits for green, and 8 bits for blue)"}
} with Documentation {EmbeddedType = true};

pattern TSUDCSCoreSupportedColorDepths = flags ushort
{
    RnsUD24BppSupport = 0x0001
      with Documentation
             {Description = "24-bit RGB mask (8 bits for red, 8 bits for green, and 8 bits for blue)"},
    RnsUD16BppSupport = 0x0002
      with Documentation
             {Description = "16-bit 565 RGB mask (5 bits for red, 6 bits for green, and 5 bits for blue)"},
    RnsUD15BppSupport = 0x0004
      with Documentation
             {Description = "15-bit 555 RGB mask (5 bits for red, 5 bits for green, and 5 bits for blue)"},
    RnsUD32BppSupport = 0x0008
      with Documentation
             {Description = "32-bit RGB mask (8 bits for the alpha channel, 8 bits for red, 8 bits for green, and 8 bits for blue)"},
    Unused = 0xFFF0
} with Documentation {EmbeddedType = true};

pattern TSUDCSCoreEarlyCapabilityFlags = flags ushort
{
    RNS_UD_CS_SUPPORT_ERRINFO_PDU = 0x0001
      with Documentation
             {Description = "Indicates that the client supports the Set Error Info PDU."},
    RNS_UD_CS_WANT_32BPP_SESSION = 0x0002
      with Documentation
             {Description = "Indicates that the client is requesting a session color depth of 32 bpp. This flag is necessary because the highColorDepth field does not support a value of 32. If this flag is set, the highColorDepth field SHOULD be set to 24 to provide an acceptable fallback for the scenario where the server does not support 32 bpp color."},
    RNS_UD_CS_SUPPORT_STATUSINFO_PDU = 0x0004
      with Documentation
             {Description = "Indicates that the client supports the Server Status Info PDU."},
    RNS_UD_CS_STRONG_ASYMMETRIC_KEYS = 0x0008
      with Documentation
             {Description = "Indicates that the client supports asymmetric keys larger than 512 bits for use with the Server Certificate sent in the Server Security Data block."},
    RNS_UD_CS_UNUSED = 0x0010,
    RNS_UD_CS_VALID_CONNECTION_TYPE = 0x0020
      with Documentation
             {Description = "Indicates that the connectionType field contains valid data."},
    RNS_UD_CS_SUPPORT_MONITOR_LAYOUT_PDU = 0x0040
      with Documentation
             {Description = "Indicates that the client supports the Monitor Layout PDU."},
    RNS_UD_CS_SUPPORT_NETCHAR_AUTODETECT = 0x0080
      with Documentation
             {Description = "Indicates that the client supports network characteristics detection using the network characteristics detection PDUs described in section ."},
    RNS_UD_CS_SUPPORT_DYNVC_GFX_PROTOCOL = 0x0100
      with Documentation
             {Description = "Indicates that the client supports the Graphics Pipeline Extension Protocol described in [MS-RDPEGFX] sections 1 to 3."},
    RNS_UD_CS_SUPPORT_DYNAMIC_TIME_ZONE = 0x0200
      with Documentation
             {Description = "that the client supports Dynamic DST. Dynamic DST information is provided by the client in the cbDynamicDSTTimeZoneKeyName, dynamicDSTTimeZoneKeyName and dynamicDaylightTimeDisabled fields of the Extended Info Packet (section 2.2.1.11.1.1.1)."},
    RNS_UD_CS_SUPPORT_HEARTBEAT_PDU = 0x0400
    ...
} with Documentation {EmbeddedType = true};

pattern TSUDCSCoreConnectionType = enum byte
{
    Undefined = 0x00,
    ConnectionTypeModem = 0x01
        with Documentation {Description = "Modem (56 Kbps)"},
    ConnectionTypeBroadbandLow = 0x02
        with Documentation {Description = "Low-speed broadband (256 Kbps - 2 Mbps)"},
    ConnectionTypeSatellite = 0x03
        with Documentation
             {Description = "Satellite (2 Mbps - 16 Mbps with high latency)"},
    ConnectionTypeBroadbandHigh = 0x04
        with Documentation {Description = "High-speed broadband (2 Mbps - 10 Mbps)"},
    ConnectionTypeWan = 0x05
        with Documentation {Description = "WAN (10 Mbps or higher with high latency)"},
    ConnectionTypeLan = 0x06
        with Documentation {Description = "LAN (10 Mbps or higher)"},
    ConnectionTypeAutoDetect = 0x07
        with Documentation
             {Description = "The server SHOULD automatically detect the connection type. If the RNS_UD_CS_SUPPORT_NETWORK_AUTODETECT (0x0080) flag is not set in the earlyCapabilityFlags field, then this value SHOULD be ignored."}
} with Documentation {EmbeddedType = true};

// 2.2.1.3.3   Client Security Data (TS_UD_CS_SEC)
type TSUDCSSec
{
    TSUDHeader Header where value.Type == TSUDHeaderType.CSSecurity
        with Documentation
           {Description = "GCC user data block header as described in User Data Header. The User Data Headertype field MUST be set to CS_SECURITY (0xC002)."};
     
    TSUDCSSecEncryptionMethods EncryptionMethods where ValidationCheckCombinationValue((value == 0x00 && ExtEncryptionMethods !=0) || (value != 0x00 && InRange<TSUDCSSecEncryptionMethods>(value)), null, false, ReferenceType.Type, "RDPBCGR", "EncryptionMethods", "TSUDCSSec", "0x00000001, 0x00000002, 0x00000008, 0x00000010", value)
        with Documentation
           {Description = "A 32-bit unsigned integer. Cryptographic encryption methods supported by the client and used in conjunction with Standard RDP Security. The client MUST specify at least one encryption method, and the server MUST select one of the methods specified by the client."};
  
    TSUDCSSecEncryptionMethods ExtEncryptionMethods where ValidationCheckCombinationValue((value == 0x00 && EncryptionMethods !=0) || (value !=0x00 && InRange<TSUDCSSecEncryptionMethods>(value)), null, false, ReferenceType.Type, "RDPBCGR", "ExtEncryptionMethods", "TSUDCSSec", "0x00000001, 0x00000002, 0x00000008, 0x00000010", value)
        with Documentation
           {Description = "A 32-bit unsigned integer. This field is used exclusively for the French locale. In French locale clients, encryptionMethods MUST be set to 0 and extEncryptionMethods MUST be set to the value to which encryptionMethods would have been set. For non-French locale clients, this field MUST be set to 0."};
}

pattern TSUDCSSecEncryptionMethods = flags uint
{
    Rdpbcgr40BitEncryptionFlag = 0x00000001
        with Documentation
             {Description = "40-bit session keys MUST be used to encrypt data (with RC4) and generate Message Authentication Codes (MAC)."},
    Rdpbcgr128BitEncryptionFlag = 0x00000002
        with Documentation
             {Description = "128-bit session keys MUST be used to encrypt data (with RC4) and generate MACs."},
    Rdpbcgr56BitEncryptionFlag = 0x00000008
        with Documentation
             {Description = "56-bit session keys MUST be used to encrypt data (with RC4) and generate MACs."},
    FipsEncryptionFlag = 0x00000010
        with Documentation
             {Description = "All encryption and Message Authentication Code generation routines MUST be Federal Information Processing Standard (FIPS) 140-1 compliant."},
    ...
} with Documentation {EmbeddedType = true};

// 2.2.1.3.4   Client Network Data (TS_UD_CS_NET)
type TSUDCSNet
{
    TSUDHeader Header where value.Type == TSUDHeaderType.CSNet
        with Documentation
           {Description = "A 32-bit, unsigned integer. GCC user data block header, as specified in User Data Header. The User Data Headertype field MUST be set to CS_NET (0xC003)."};
   
    uint ChannelCount where value >= 0 && value <= 31
        with Documentation
           {Description = "A 32-bit, unsigned integer. The number of requested static virtual channels (the maximum allowed is 31)."};
  
    array<ChannelDef> ChannelDefArray with BinaryEncoding{Length = ChannelCount},
        Documentation
           {Description = "A variable-length array containing the information for requested static virtual channels encapsulated in CHANNEL_DEF structures. The number of CHANNEL_DEF structures which follows is given by the channelCount field."};
    override string ToString()
    {
        string summary = "ChannelDef: ";
        int cnt = 0;
        if (ChannelDefArray.Count > 1)
        {
            summary += "[";
        }            
        foreach (var chanel in ChannelDefArray)
        {
            if (cnt > 4)
            {
                summary += " ...";
                break;
            }
            else if (cnt > 0)
            {
                summary += ", ";
            }
            summary += chanel.Name;
            cnt++;
        }
        if (cnt > 1)
        {
            summary += "]";
        }
        return summary;
    }
}
with Documentation
       {Applicability = "2.2.1.3.4",
        Description = "The TSUDCSNet packet contains a list of requested virtual channels."};

// 2.2.1.3.4.1   Channel Definition Structure (CHANNEL_DEF)
type ChannelDef
{
    string Name with BinaryEncoding{TextEncoding = TextEncoding.ASCII, Length = 8},
             Documentation
           {Description = "An 8-byte array containing a null-terminated collection of seven ANSI characters that uniquely identify the channel."};
  
    ChannelDefOptions options
        with Documentation
           {Description = "A 32-bit, unsigned integer. Channel option flags."};
}
with Documentation
       {Applicability = "2.2.1.3.4.1",
        Description = "The CHANNEL_DEF packet contains information for a particular static virtual channel."};

pattern ChannelDefOptions = flags uint
{
    ChannelOptionInitialized = 0x80000000
        with Documentation
             {Description = "Absence of this flag indicates that this channel is a placeholder and that the server MUST NOT set it up."},
    ChannelOptionEncryptRdp = 0x40000000
        with Documentation
             {Description = "This flag is unused and its value MUST be ignored by the server."},
    ChannelOptionEncryptSC = 0x20000000
        with Documentation
             {Description = "This flag is unused and its value MUST be ignored by the server."},
    ChannelOptionEncryptCS = 0x10000000
        with Documentation
             {Description = "This flag is unused and its value MUST be ignored by the server."},
    ChannelOptionPriHigh = 0x08000000
        with Documentation
             {Description = "Channel data MUST be sent with high MCS priority."},
    ChannelOptionPriMed = 0x04000000
        with Documentation
             {Description = "Channel data MUST be sent with medium MCS priority."},
    ChannelOptionPriLow = 0x02000000
        with Documentation
             {Description = "Channel data MUST be sent with low MCS priority."},
    ChannelOptionCompressRdp = 0x00800000
        with Documentation
             {Description = "Virtual channel data MUST be compressed if RDP data is being compressed."},
    ChannelOptionCompress = 0x00400000
        with Documentation
             {Description = "Virtual channel data MUST be compressed, regardless of RDP compression settings."},
    ChannelOptionShowProtocol = 0x00200000
        with Documentation
             {Description = "The value of this flag MUST be ignored by the server. The visibility of the Channel PDU Header is determined by the CHANNEL_FLAG_SHOW_PROTOCOL (0x00000010) flag as defined in the flags field."},
    RemoteControlPersistent = 0x00100000
        with Documentation
             {Description = "Channel MUST be persistent across remote control transactions."},
    Unused = 0x010FFFFF
} with Documentation {EmbeddedType = true};

// 2.2.1.3.5   Client Cluster Data (TS_UD_CS_CLUSTER)
type TSUDCSCluster
{
    TSUDHeader Header where value.Type == TSUDHeaderType.CSCluster
        with Documentation
           {Description = "GCC user data block header, as specified in User Data Header. The User Data Headertype field MUST be set to CS_CLUSTER (0xC004)."};
    
    TSUDCSClusterFlags Flags
        with Documentation
           {Description = "A 32-bit, unsigned integer. Cluster information flags."};
  
    uint RedirectedSessionID
        with Documentation
           {Description = "A 32-bit unsigned integer. If the RedirectedSessionIDFieldValid flag is set in the Flags field, then the RedirectedSessionID field contains a valid session identifier to which the client requests to connect."};
}
    with Documentation
       {Applicability = "2.2.1.3.5",
            Description = "The TS_UD_CS_CLUSTER data block is sent by the client to the server either to advertise that it can support the Server Redirection PDUs (sections  and ) or to request a connection to a given session identifier."};

pattern TSUDCSClusterFlags = flags uint
{
    RedirectionSupported = 0x00000001
      with Documentation
             {Description = "The client can receive server session redirection packets. If this flag is set, the ServerSessionRedirectionVersionMask MUST contain the server session redirection version that the client supports."},
    ServerSessionRedirectionVersionMask = 0x0000003C
      with Documentation
             {Description = "The server session redirection version that the client supports. See the discussion which follows this table for more information."},
    RedirectedSessionIDFieldValid = 0x00000002
      with Documentation
             {Description = "The RedirectedSessionID field contains an ID that identifies a session on the server to associate with the connection."},
    RedirectedSmartcard = 0x00000040
      with Documentation {Description = "The client logged on with a smart card."},
    Unused = 0xFFFFFF80
} with Documentation {EmbeddedType = true};

// 2.2.1.3.6   Client Monitor Data (TSUDCSMonitor)
type TSUDCSMonitor
{
    TSUDHeader Header where value.Type == TSUDHeaderType.CSMonitor
        with Documentation
           {Description = "GCC user data block header, as specified in User Data Header. The User Data Header type field MUST be set to CS_MONITOR (0xC005)."};
            
    uint Flags where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "RDPBCGR", "Flags", "TSUDCSMonitor", value)
        with Documentation
           {Description = "A 32-bit, unsigned integer. This field is unused and reserved for future use."};
  
    uint MonitorCount where ValidationCheckLessThanOrEqualTo(value <= 16, null, false, ReferenceType.Type, "RDPBCGR", "MonitorCount", "TSUDCSMonitor", 16, value)
        with Documentation
           {Description = "A 32-bit, unsigned integer. The number of display monitor definitions in the monitorDefArray field (the maximum allowed is 16)."};
  
    array<TSMonitorDef> MonitorDefArray with BinaryEncoding{Length = MonitorCount},
        Documentation
           {Description = "A variable-length array containing a series of TS_MONITOR_DEF structures which describe the display monitor layout of the client. The number of TS_MONITOR_DEF structures is given by the monitorCount field."};
}
with Documentation
       {Applicability = "2.2.1.3.6",
        Description = "The TSUDCSMonitor packet describes the client-side display monitor layout. This packet is an Extended Client Data Block and MUST NOT be sent to a server which does not advertise support for Extended Client Data Blocks by using the EXTENDED_CLIENT_DATA_SUPPORTED flag (0x00000001) as described in section ."};

// 2.2.1.3.6.1   Monitor Definition (TS_MONITOR_DEF)
type TSMonitorDef
{
    uint Left
        with Documentation
           {Description = "A 32-bit, signed integer. Specifies the x-coordinate of the upper-left corner of the display monitor."};
  
    uint Top
        with Documentation
           {Description = "A 32-bit, signed integer. Specifies the y-coordinate of the upper-left corner of the display monitor."};
  
    uint Right
        with Documentation
           {Description = "A 32-bit, signed integer. Specifies the inclusive x-coordinate of the lower-right corner of the display monitor."};
  
    uint Bottom
        with Documentation
           {Description = "A 32-bit, signed integer. Specifies the inclusive y-coordinate of the lower-right corner of the display monitor."};
  
    TsMonitorDefFlags Flags
        with Documentation
           {Description = "A 32-bit, unsigned integer. Monitor configuration flags."};
}
with Documentation
       {Applicability = "2.2.1.3.6.1",
        Description = "The TS_MONITOR_DEF packet describes the configuration of a client-side display monitor. The x and y coordinates used to describe the monitor position MUST be relative to the upper-left corner of the monitor designated as the \"primary display monitor\" (the upper-left corner of the primary monitor is always (0, 0))."};

pattern TsMonitorDefFlags = flags uint
{
    TSMonitorPrimary = 0x00000001
      with Documentation
             {Description = "The top, left, right, and bottom fields describe the position of the primary monitor."},
    ...
} with Documentation {EmbeddedType = true};

// 2.2.1.3.7   Client Message Channel Data (TS_UD_CS_MCS_MSGCHANNEL)
type TSUDCSMcsMsgChannel
{
    TSUDHeader Header where value.Type == TSUDHeaderType.CSMcsMsgChannel
        with Documentation
           {Description = "GCC user data block header, as specified in User Data Header (section 2.2.1.3.1). The User Data Header type field MUST be set to CS_MCS_MSGCHANNEL (0xC006)."};
     
    uint Flags where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "RDPBCGR", "Flags", "TSUDCSMcsMsgChannel", value)
        with Documentation
           {Description = "A 32-bit, unsigned integer. This field is unused and reserved for future use. It MUST be set to zero."};
}
with Documentation
       {Applicability = "2.2.1.3.7",
        Description = "The TS_UD_CS_MCS_MSGCHANNEL packet  indicates support for the message channel which is used to transport the Initiate Multitransport Request PDU (section 2.2.15.1)."};

// 2.2.1.3.8   Client Multitransport Channel Data (TS_UD_CS_MULTITRANSPORT)
type TSUDCSMultiTransPort
{
    TSUDHeader Header where value.Type == TSUDHeaderType.CSMultitransport
        with Documentation
           {Description = "GCC user data block header, as specified in User Data Header (section 2.2.1.3.1). The User Data Header type field MUST be set to CS_MULTITRANSPORT (0xC00A)."};
    
    TSUDCSMultiTransPortFlag Flags
        with Documentation
           {Description = "A 32-bit, unsigned integer. This field is unused and reserved for future use. It MUST be set to zero."};
}
with Documentation
       {Applicability = "2.2.1.3.8",
        Description = "The TS_UD_CS_MULTITRANSPORT packet is used to indicate support for the RDP Multitransport Layer ([MS-RDPEMT] section 1.3) and to specify multitransport characteristics."};

pattern TSUDCSMultiTransPortFlag = flags uint
{
    TransportTypeUdpfecr = 0x00000001
      with Documentation
             {Description = "RDP-UDP Forward Error Correction (FEC) reliable transport ([MS-RDPEUDP] sections 1 to 3)."},
    TransportTypeUdpfecl = 0x00000004
      with Documentation
             {Description = "RDP-UDP FEC lossy transport ([MS-RDPEUDP] sections 1 to 3)."},
    TransportTypeUdpPreferred = 0x00000100
      with Documentation
             {Description = "Indicates that tunneling of static virtual traffic over UDP is supported."},
    Unused = 0xFFFFFEFA
};
        
// 2.2.1.4   Server MCS Connect Response PDU with GCC Conference Create Response
message ServerMCSConnectResponsePDUWithGccConferenceCreateResponse
{
    /*TSUDSCCore ServerCoreData
        with Documentation {Description = "Server Core Data structure."};
  
    TSUDSCNet ServerNetworkData
        with Documentation
           {Description = "Variable-length Server Network Data structure."};
  
    TSUDSCSec1 ServerSecurityData
        with Documentation
           {Description = "Variable-length Server Security Data structure."};*/
    array<TSUDSCType> TSUD;
    
    override string ToString()
    {
        string summary = "Server MCS Connect Response PDU with GCC Conference Create Response";
        foreach (var tsud in TSUD)
        {
            if (tsud is TSUDSCSec1)
            {
                summary += ", EncryptionMethod: " + EnumToString((tsud as TSUDSCSec1).EncryptionMethod, "RDPBCGR.TSUDSCSec1EncryptionMethod");
                summary += ", EncryptionLevel: " + EnumToString((tsud as TSUDSCSec1).EncryptionLevel, "RDPBCGR.TSUDSCSec1EncryptionLevel");
            }
            else if (tsud is TSUDSCNet)
            {
                summary += ", " + tsud.ToString();
            }
        }
        return summary;
    }
}
with Documentation
       {Applicability = "2.2.1.4",
        Description = "The MCS Connect Response PDU is an RDP Connection Sequence PDU sent from server to client during the Basic Settings Exchange phase of the RDP Connection Sequence (see section  for an overview of the RDP Connection Sequence phases). It is sent as a response to the MCS Connect Initial PDU. The MCS Connect Response PDU encapsulates a GCC Conference Create Response, which encapsulates concatenated blocks of settings data. A basic high-level overview of the nested structure for the Server MCS Connect Response PDU is illustrated in section , in the figure specifying MCS Connect Response PDU. Note that the order of the settings data blocks is allowed to vary from that shown in the previously mentioned figure and the message syntax layout that follows. This is possible because each data block is identified by a User Data Header structure."};

pattern TSUDSCType = TSUDSCCore | TSUDSCNet | TSUDSCSec1 | TSUDSCMcsMsgChannel | TSUDSCMultiTransport | TSUDUndefinedType;

type TSUDUndefinedType
{
    uint Undefined;
}

// 2.2.1.4.2   Server Core Data (TS_UD_SC_CORE)
type TSUDSCCore
{
    TSUDHeader Header where value.Type == TSUDHeaderType.SCCore
        with Documentation
           {Description = "GCC user data block header, as specified in User Data Header. The User Data Headertype field MUST be set to SC_CORE (0x0C01)."};
    
    TSUDSCCoreVersion Version
        with Documentation
           {Description = "A 32-bit, unsigned integer. The server version number for the RDP. The major version number is stored in the high two bytes, while the minor version number is stored in the low two bytes."};
  
    optional [|Header.Length > 8|] RequestedProtocols ClientRequestedProtocols
        with Documentation
           {Description = "A 32-bit, unsigned integer that contains the flags sent by the client in the requestedProtocols field of the RDP Negotiation Request. In the event that an RDP Negotiation Request was not received from the client, this field MUST be initialized to PROTOCOL_RDP (0). If this field is not present, all of the subsequent fields MUST NOT be present."};
  
    optional [|Header.Length > 12|] TSUDSCCoreEarlyCapabilityFlags EarlyCapabilityFlags where ValidationCheckCombinationValueIncludeZero(value == nothing || InRange<TSUDSCCoreEarlyCapabilityFlags>(value as TSUDSCCoreEarlyCapabilityFlags), null, false, ReferenceType.Type, "RDPBCGR", "EarlyCapabilityFlags", "TSUDSCCore", "0x00000001, 0x00000002", ((value is nothing) ? "": (value as TSUDSCCoreEarlyCapabilityFlags)))
        with Documentation
           {Description = "A 32-bit, unsigned integer that specifies capabilities early in the connection sequence."};
}
with Documentation
       {Applicability = "2.2.1.4.2",
        Description = "The TS_UD_SC_CORE data block contains core server connection-related information."};

pattern TSUDSCCoreVersion = enum uint
{
    TagAnonyEnumField10 = 0x00080001
      with Documentation {Description = "RDP 4.0 servers"},
    TagAnonyEnumField11 = 0x00080004
      with Documentation
             {Description = "RDP 5.0, 5.1, 5.2, 6.0, 6.1, and 7.07.0, 7.1, and 8.0 servers"}
} with Documentation {EmbeddedType = true};

pattern TSUDSCCoreEarlyCapabilityFlags = flags uint
{
    RnsUdScEdgeActionsSupported = 0x00000001
      with Documentation
             {Description = "Indicates that the following key combinations are reserved by the server operating system."},
    RnsUdScDynamicDstSuppported = 0x00000002
      with Documentation
            {Description = "Indicates that the server supports Dynamic DST. Dynamic DST information is provided by the client in the cbDynamicDSTTimeZoneKeyName, dynamicDSTTimeZoneKeyName and dynamicDaylightTimeDisabled fields of the Extended Info Packet (section 2.2.1.11.1.1.1)."},         
    ...
} with Documentation {EmbeddedType = true};

// 2.2.1.4.3   Server Security Data (TS_UD_SC_SEC1)
type TSUDSCSec1
{
    TSUDHeader Header where value.Type == TSUDHeaderType.SCSecurity
        with Documentation
           {Description = "GCC user data block header, as specified in User Data Header. The User Data Headertype field MUST be set to SC_SECURITY (0x0C02)."};
    
    TSUDSCSec1EncryptionMethod EncryptionMethod
        with Documentation
           {Description = "A 32-bit, unsigned integer. The selected cryptographic method to use for the session. When Enhanced RDP Security is being used, this field MUST be set to ENCRYPTION_METHOD_NONE (0)."};
  
    TSUDSCSec1EncryptionLevel EncryptionLevel
        with Documentation
           {Description = "A 32-bit unsigned integer. It describes the encryption behavior to use for the session. When Enhanced RDP Security is being used, this field MUST be set to EncryptionLevelNone (0)."};
  
    optional [|(EncryptionMethod != 0) || (EncryptionLevel != 0)|] uint ServerRandomLen where ValidationCheckValue((value == nothing) || (value as uint == 0x20), null, true, ReferenceType.Type, "RDPBCGR", "ServerRandomLen", "TSUDSCSec1", "0x20", ((value is nothing) ? "": (value as uint)))
                      with Documentation
           {Description = "A 32-bit, unsigned integer. The size in bytes of the serverRandom field. If the encryptionMethod and encryptionLevel fields are both set to 0 then the contents of this field MUST be ignored and the serverRandom field MUST NOT be present. Otherwise, this field MUST be set to 32 bytes."};
  
    optional [|(EncryptionMethod != 0) || (EncryptionLevel != 0)|] uint ServerCertLen
        with Documentation
           {Description = "A 32-bit, unsigned integer. The size in bytes of the serverCertificate field. If the encryptionMethod and encryptionLevel fields are both set to 0 then the contents of this field MUST be ignored and the serverCertificate field MUST NOT be present."};
  
    optional [|((EncryptionMethod != 0) || (EncryptionLevel != 0)) && (ServerRandomLen != nothing)|] binary ServerRandom with BinaryEncoding{Length = ServerRandomLen as uint},
             Documentation
           {Description = "The variable-length server random value used to derive session keys (see sections  and ). The length in bytes is given by the serverRandomLen field. If the encryptionMethod and encryptionLevel fields are both set to 0 then this field MUST NOT be present."};
  
    optional [|((EncryptionMethod != 0) || (EncryptionLevel != 0)) && (ServerCertLen != nothing)|] ServerCertificate ServerCertificate
        with Documentation
           {Description = "The variable-length certificate containing the server\'s public key information. The length in bytes is given by the serverCertLen field. If the encryptionMethod and encryptionLevel fields are both set to 0 then this field MUST NOT be present."};
}
with Documentation
       {Applicability = "2.2.1.4.3",
        Description = "The TS_UD_SC_SEC1 data block returns negotiated security-related information to the client. See section  for a detailed discussion of how this information is used."};

pattern TSUDSCSec1EncryptionMethod = enum uint
{
    EncryptionMethodNone = 0x00000000
        with Documentation
             {Description = "No encryption or Message Authentication Codes (MACs) will be used."},
    EncryptionMethod40Bit = 0x00000001
        with Documentation
             {Description = "40-bit session keys will be used to encrypt data (with RC4) and generate MACs."},
    EncryptionMethod128Bit = 0x00000002
        with Documentation
             {Description = "128-bit session keys will be used to encrypt data (with RC4) and generate MACs."},
    EncryptionMethod56Bit = 0x00000008
        with Documentation
             {Description = "56-bit session keys will be used to encrypt data (with RC4) and generate MACs."},
    EncryptionMethodFips = 0x00000010
        with Documentation
             {Description = "All encryption and Message Authentication Code generation routines will be FIPS 140-1 compliant."}

} with Documentation {EmbeddedType = true};

pattern TSUDSCSec1EncryptionLevel = enum uint
{
    EncryptionLevelNone = 0x00000000,
    EncryptionLevelLow = 0x00000001,
    EncryptionLevelClientCompatible = 0x00000002,
    EncryptionLevelHigh = 0x00000003,
    EncryptionLevelFips = 0x00000004
} with Documentation {EmbeddedType = true};

pattern ServerCertificateDwVersionCertChainVersionLow = enum byte
{
    CertChainVersion1 = 0x01
      with Documentation
             {Description = "The certificate contained in the certData field is a Server Proprietary Certificate."},
    CertChainVersion2 = 0x02
      with Documentation
             {Description = "The certificate contained in the certData field is an X.509 Certificate (see section )."}
} with Documentation {EmbeddedType = true};

type ServerCertificateDwVersion
{
    ServerCertificateDwVersionCertChainVersionLow CertChainVersion
             with Documentation {Description = "A 31-bit field. The certificate version."};
    ushort ServerCertificateDwVersionCertChainVersionMiddle;
    byte T with BinaryEncoding{Width = 1},
             Documentation
           {Description = "A 1-bit field. Indicates whether the certificate contained in the certData field has been permanently or temporarily issued to the server."};

    byte ServerCertificateDwVersionCertChainVersionHigh with BinaryEncoding{Width = 7};
}
with Documentation
       {Description = "A 32-bit, unsigned integer. The format of this field is described by the following bitmask diagram."},
     Documentation {EmbeddedType = true};

// 2.2.1.4.3.1   Server Certificate (SERVER_CERTIFICATE)
type ServerCertificate
{
    ServerCertificateDwVersion DwVersion
        with Documentation
           {Description = "A 32-bit, unsigned integer. The format of this field is described by the following bitmask diagram."};
  
    ([|DwVersion.CertChainVersion == ServerCertificateDwVersionCertChainVersionLow.CertChainVersion1|] ProprietaryCertificate | [|DwVersion.CertChainVersion == ServerCertificateDwVersionCertChainVersionLow.CertChainVersion2|] X509CertificateChain )CertData
        with Documentation
           {Description = "Certificate data. The format of this certificate data is determined by the dwVersion field."};
}
with Documentation
       {Applicability = "2.2.1.4.3.1",
        Description = "The ServerCertificate structure describes the generic server certificate structure to which all server certificates present in the Server Security Data conform."};

// 2.2.1.4.3.1.1   Server Proprietary Certificate (PROPRIETARYSERVERCERTIFICATE)
type ProprietaryCertificate
{
    uint DwSigAlgId where value == 0x00000001
        with Documentation
           {Description = "A 32-bit, unsigned integer. The signature algorithm identifier. This field MUST be set to SIGNATURE_ALG_RSA (0x00000001)."};
  
    uint DwKeyAlgId where value == 0x00000001
        with Documentation
           {Description = "A 32-bit, unsigned integer. The key algorithm identifier. This field MUST be set to KEY_EXCHANGE_ALG_RSA (0x00000001)."};
  
    ushort WPublicKeyBlobType where value == 0x0006
        with Documentation
           {Description = "A 16-bit, unsigned integer. The type of data in the PublicKeyBlob field. This field MUST be set to BB_RSA_KEY_BLOB (0x0006)."};
  
    ushort WPublicKeyBlobLen
        with Documentation
           {Description = "A 16-bit, unsigned integer. The size in bytes of the PublicKeyBlob field."};
  
    RsaPublicKey PublicKeyBlob
        with Documentation
           {Description = "Variable-length server public key bytes, formatted using the Rivest-Shamir-Adleman (RSA) Public Key structure. The length in bytes is given by the wPublicKeyBlobLen field."};
  
    ushort WSignatureBlobType where value == 0x0008
        with Documentation
           {Description = "A 16-bit, unsigned integer. The type of data in the SignatureKeyBlob field. This field is set to BB_RSA_SIGNATURE_BLOB (0x0008)."};
  
    ushort WSignatureBlobLen
        with Documentation
           {Description = "A 16-bit, unsigned integer. The size in bytes of the SignatureKeyBlob field."};
  
    binary SignatureBlob with BinaryEncoding{Length = WSignatureBlobLen},
             Documentation
           {Description = "Variable-length signature of the certificate created with the Terminal Services Signing Key (see sections  and ). The length in bytes is given by the wSignatureBlobLen field."};
}
with Documentation
       {Applicability = "2.2.1.4.3.1.1",
        Description = "The PROPRIETARYSERVERCERTIFICATE structure describes a signed certificate containing the server\'s public key and conforming to the structure of a Server Certificate. For a detailed description of Proprietary Certificates, see section ."};

// 2.2.1.4.3.1.1.1   RSA Public Key (RSA_PUBLIC_KEY)
type RsaPublicKey
{
    uint Magic where value == 0x31415352
        with Documentation
           {Description = "A 32-bit, unsigned integer. The sentinel value. This field MUST be set to 0x31415352."};
  
    uint KeyLen
        with Documentation
           {Description = "A 32-bit, unsigned integer. The size in bytes of the modulus field. This value is directly related to the bitlen field and MUST be ((bitlen / 8) + 8) bytes."};
  
    uint BitLen
        with Documentation
           {Description = "A 32-bit, unsigned integer. The number of bits in the public key modulus."};
  
    uint DataLen
        with Documentation
           {Description = "A 32-bit, unsigned integer. The maximum number of bytes that can be encoded using the public key."};
  
    uint PubExp
        with Documentation
           {Description = "A 32-bit, unsigned integer. The public exponent of the public key."};
  
    array<byte> Modulus with BinaryEncoding{Length = KeyLen},
             Documentation
           {Description = "A variable-length array of bytes containing the public key modulus. The length in bytes of this field is given by the keylen field. The modulus field contains all (bitlen / 8) bytes of the public key modulus and 8 bytes of zero padding (which MUST follow after the modulus bytes)."};

    optional [|KeyLen % 8 != 0|] array<byte> Pad with BinaryEncoding{Length = ((8 - KeyLen % 8) % 8)};}
        with Documentation
       {Applicability = "2.2.1.4.3.1.1",
        Description = "The structure used to describe a public key in a Proprietary Certificate."};

// 2.2.1.4.4   Server Network Data (TS_UD_SC_NET)
type TSUDSCNet
{
    TSUDHeader Header where value.Type == TSUDHeaderType.SCNet
        with Documentation
           {Description = "A GCC user data block header, as specified in section User Data Header. The User Data Headertype field MUST be set to SC_NET (0x0C03)."};
    
    ushort McsChannelId
        with Documentation
           {Description = "A 16-bit, unsigned integer. The MCS channel identifier which the client MUST join to receive display data and send client input (I/O channel)."};
  
    ushort ChannelCount
        with Documentation
           {Description = "A 16-bit, unsigned integer. The number of 16-bit, unsigned integer MCS channel IDs in the channelIdArray field."};
  
    array<ushort> ChannelIdArray with BinaryEncoding{Length = ChannelCount},
             Documentation
           {Description = "A variable-length array of MCS channel IDs (each channel ID is a 16-bit, unsigned integer) which have been allocated (the number is given by the channelCount field). Each MCS channel ID corresponds in position to the channels requested in the Client Network Data structure. A channel value of 0 indicates that the channel was not allocated."};
  
    optional [|(ChannelIdArray.Count % 2) == 1|]ushort Pad
        with Documentation
           {Description = "A 16-bit, unsigned integer. Optional padding. Values in this field MUST be ignored. The size in bytes of the Server Network Data structure MUST be a multiple of 4. If the channelCount field contains an odd value, then the size of the channelIdArray (and by implication the entire Server Network Data structure) will not be a multiple of 4. In this scenario, the Pad field MUST be present and it is used to add an additional 2 bytes to the size of the Server Network Data structure. If the channelCount field contains an even value, then the Pad field is not required and MUST NOT be present."};
    override string ToString()
    {
        int cnt = 0;
        string summary = "ChannelId: ";
        if (ChannelIdArray.Count > 1)
        {
            summary += "[";
        }
        foreach (var chanelid in ChannelIdArray)
        {
            if (cnt > 4)
            {
                summary += " ...";
                break;
            }
            else if (cnt > 0)
            {
                summary += ", ";
            }
            summary += (chanelid as string);
            cnt++;
        }
        if (cnt > 1)
        {
            summary += "]";
        }
        return summary;
    }
}
with Documentation
       {Applicability = "2.2.1.4.4",
        Description = "The TSUDSCNet data block is a reply to the static virtual channel list presented in the Client Network Data structure."};

// 2.2.1.4.5   Server Message Channel Data (TS_UD_SC_MCS_MSGCHANNEL)
type TSUDSCMcsMsgChannel
{
    TSUDHeader Header where value.Type == TSUDHeaderType.SCMcsMsgChannel
        with Documentation
           {Description = "GCC user data block header, as specified in User Data Header (section 2.2.1.4.1). The User Data Header type field MUST be set to SC_MCS_MSGCHANNEL (0x0C04)."};

    ushort MCSChannelID
        with Documentation
           {Description = "A 16-bit, unsigned integer that specifies the MCS channel identifier of the MCS message channel. If this value is zero, then the channel MUST NOT be joined (section 3.2.5.3.8), and the PDUs which are transported on this channel cannot be transmitted."};    
}
with Documentation
       {Applicability = "2.2.1.4.5",
        Description = "The TS_UD_SC_MCS_MSGCHANNEL packet is used to specify the ID of the MCS channel which transports the Initiate Multitransport Request PDU (section 2.2.15.1)."};

// 2.2.1.4.6   Server Multitransport Channel Data (TS_UD_SC_MULTITRANSPORT)        
type TSUDSCMultiTransport
{
    TSUDHeader Header where value.Type == TSUDHeaderType.SCMultiTransport
        with Documentation
           {Description = "GCC user data block header, as specified in User Data Header (section 2.2.1.3.1). The User Data Header type field MUST be set to SC_MULTITRANSPORT (0x0C08)."};

    TSUDSCMultiTransportFlag Flags where ValidationCheckCombinationValueIncludeZero(InRange<TSUDSCMultiTransportFlag>(value), null, false, ReferenceType.Type, "RDPBCGR", "Flags", "TSUDSCMultiTransport", "0x00000001, 0x00000004, 0x00000100", value)
        with Documentation
           {Description = "A 16-bit, unsigned integer that specifies the ID of the MCS channel which transports the Initiate Multitransport Request PDU (section 2.2.15.1)."};    
}
with Documentation
       {Applicability = "2.2.1.4.6",
        Description = "The TS_UD_SC_MULTITRANSPORT packet is used to specify the ID of the MCS channel which transports the Initiate Multitransport Request PDU (section 2.2.15.1)."};

pattern TSUDSCMultiTransportFlag = flags uint
{
    TransportTypeUdpfecr = 0x00000001
      with Documentation
             {Description = "RDP-UDP Forward Error Correction (FEC) reliable transport ([MS-RDPEUDP] sections 1 to 3)."},
    TransportTypeUdpfecl = 0x00000004
      with Documentation
             {Description = "RDP-UDP FEC lossy transport ([MS-RDPEUDP] sections 1 to 3)."},
    TransportUDPPreferred = 0x00000100
      with Documentation
             {Description = "Indicates that tunneling of static virtual channel traffic over UDP is supported."},     
    ...
};

// 2.2.1.5   Client MCS Erect Domain Request PDU
message ClientMCSErectDomainRequestPdu
{
    override string ToString()
    {
        return "Client MCS Erect Domain Request PDU";
    }
}
with Documentation
       {Applicability = "2.2.1.5",
        Description = "The MCS Erect Domain Request PDU is an RDP Connection Sequence PDU sent from client to server during the Channel Connection phase of the RDP Connection Sequence (see section  for an overview of the RDP Connection Sequence phases). It is sent after receiving the MCS Connect Response PDU."};

// 2.2.1.6   Client MCS Attach User Request PDU
message ClientMCSAttachUserRequestPdu
{
    override string ToString()
    {
        return "Client MCS Attach User Request PDU";
    }
}
with Documentation
       {Applicability = "2.2.1.6",
        Description = "The MCS Attach User Request PDU is an RDP Connection Sequence PDU sent from client to server during the Channel Connection phase of the RDP Connection Sequence to request a User Channel ID (see section  for an overview of the RDP Connection Sequence phases). It is sent after transmitting the MCS Erect Domain Request PDU."};

// 2.2.1.7   Server MCS Attach User Confirm PDU
message ServerMCSAttachUserConfirmPdu
{
    override string ToString()
    {
        return "Server MCS Attach User Confirm PDU";
    }
}
with Documentation
       {Applicability = "2.2.1.7",
        Description = "The MCS Attach User Confirm PDU is an RDP Connection Sequence PDU sent from server to client during the Channel Connection phase of the RDP Connection Sequence (see section  for an overview of the RDP Connection Sequence phases). It is sent as a response to the MCS Attach User Request PDU."};

// 2.2.1.8   Client MCS Channel Join Request PDU
message ClientMCSChannelJoinRequestPdu
{
    override string ToString()
    {
        return "Client MCS Channel Join Request PDU";
    }
}
with Documentation
       {Applicability = "2.2.1.8",
        Description = "The MCS Channel Join Request PDU is an RDP Connection Sequence PDU sent from client to server during the Channel Connection phase of the RDP Connection Sequence (see section  for an overview of the RDP Connection Sequence phases). It is sent after receiving the MCS Attach User Confirm PDU. The client uses the MCS Channel Join Request PDU to join the user channel obtained from the Attach User Confirm PDU, the I/O channel and all of the static virtual channels obtained from the Server Network Data structure."};

// 2.2.1.9   Server MCS Channel Join Confirm PDU
message ServerMCSChannelJoinConfirmPdu
{
    override string ToString()
    {
        return "Server MCS Channel Join Confirm PDU";
    }
}
with Documentation
       {Applicability = "2.2.1.9",
        Description = "The MCS Channel Join Confirm PDU is an RDP Connection Sequence PDU sent from server to client during the Channel Connection phase of the RDP Connection Sequence (see section  for an overview of the RDP Connection Sequence phases). It is sent as a response to the MCS Channel Join Request PDU."};

// 2.2.1.10   Client Security Exchange PDU
message ClientSecurityExchangePdu
{
    BasicSecurityHeader BasicSecurityHeader
        with Documentation
           {Description = "A Basic Security Header. The flags field of the security header MUST contain the SEC_EXCHANGE_PKT flag (0x0001)."};
  
    uint Length
        with Documentation
           {Description = "A 32-bit, unsigned integer. The size in bytes of the buffer containing the encrypted client random value, not including the header length."};
  
    binary EncryptedClientRandom with BinaryEncoding{Length = Length},
             Documentation
           {Description = "The client random value encrypted with the public key of the server (see section )."};

    override string ToString()
    {
        return "Client Security Exchange PDU";
    }
}
with Documentation
       {Applicability = "2.2.1.10.1",
        Description = "The TS_SECURITY_PACKET structure contains the encrypted client random value which is used together with the server random (see section ) to derive session keys to secure the connection (see sections  and )."};

// 2.2.1.11   Client Info PDU
message ClientInfoPdu[TSUDSCSec1EncryptionLevel EncryptionLevel, TSUDSCSec1EncryptionMethod EncryptionMethod]
{
    optional (
              ([|EncryptionLevel == TSUDSCSec1EncryptionLevel.EncryptionLevelNone|] BasicSecurityHeader) |
              ([|EncryptionMethod in {TSUDSCSec1EncryptionMethod.EncryptionMethod40Bit,
                                      TSUDSCSec1EncryptionMethod.EncryptionMethod128Bit,
                                      TSUDSCSec1EncryptionMethod.EncryptionMethod56Bit}|] NonFipsSecurityHeader) |
              ([|(EncryptionMethod == TSUDSCSec1EncryptionMethod.EncryptionMethodFips)|] FipsSecurityHeader)
             ) SecurityHeader
        with Documentation
           {Description = "Security header. The format of the security header depends on the Encryption Level and Encryption Method selected by the server (sections  and ). This field MUST contain one of the following headers:"};

    TSInfoPacket InfoPacket
    with Documentation
           {Description = "Client information, as specified in TS_INFO_PACKET."};
    
    override string ToString()
    {
        return "Client Info PDU, UserName: " + InfoPacket.UserName + ", Domain: " + InfoPacket.Domain + ", ClientAddress: " + InfoPacket.ExtraInfo.ClientAddress;   
    }
}
with Documentation
       {Applicability = "2.2.1.11.1",
        Description = "The CLIENT_INFO_PDU structure serves as a wrapper for a Security Header and the actual client information contained in a TS_INFO_PACKET structure."};

// 2.2.1.11.1.1   Info Packet (TS_INFO_PACKET)
type TSInfoPacket
{
    uint CodePage
        with Documentation
           {Description = "A 32-bit, unsigned integer. If the flags field does not contain the INFO_UNICODE flag (0x00000010), then this field MUST contain the ANSI code page descriptor being used by the client (for a list of code pages, see [MSDN-CP]) to encode the character fields in the Info Packet and Extended Info Packet. However, if the flags field contains the INFO_UNICODE flag, then the CodePage field contains the active input locale identifier (for a list of input locale identifiers, see [MSFT-DIL])."};
  
    TSInfoPacketFlags Flags
        with Documentation {Description = "A 32-bit, unsigned integer. Option flags."};
  
    ushort CbDomain
        with Documentation
           {Description = "A 16-bit, unsigned integer. The size in bytes of the character data in the Domain field. This size excludes the length of the mandatory null terminator."};
  
    ushort CbUserName
        with Documentation
           {Description = "A 16-bit, unsigned integer. The size in bytes of the character data in the UserName field. This size excludes the length of the mandatory null terminator."};
  
    ushort CbPassword
        with Documentation
           {Description = "A 16-bit, unsigned integer. The size in bytes of the character data in the Password field. This size excludes the length of the mandatory null terminator."};
  
    ushort CbAlternateShell
        with Documentation
           {Description = "A 16-bit, unsigned integer. The size in bytes of the character data in the AlternateShell field. This size excludes the length of the mandatory null terminator."};
  
    ushort CbWorkingDir
        with Documentation
           {Description = "A 16-bit, unsigned integer. The size in bytes of the character data in the WorkingDir field. This size excludes the length of the mandatory null terminator."};
  
    string Domain with BinaryEncoding{TextEncoding = TextEncoding.UTF16},
             Documentation
           {Description = "Variable-length logon domain of the user (the length in bytes is given by the cbDomain field). The maximum length allowed by RDP 4.0 and RDP 5.0 servers is 52 bytes (including the mandatory null terminator). RDP 5.1, 5.2, 6.0, 6.1, and 7.07.0, 7.1, and 8.0 allow a maximum length of 512 bytes (including the mandatory null terminator). The field MUST contain at least a null terminator character in Windows-1252 or Unicode format (depending on the presence of the INFO_UNICODE flag)."};
  
    string UserName with BinaryEncoding{TextEncoding = TextEncoding.UTF16},
             Documentation
           {Description = "Variable-length logon user name of the user (the length in bytes is given by the cbUserName field). The maximum length allowed by RDP 4.0 servers is 44 bytes (including the mandatory null terminator). RDP 5.0, 5.1, 5.2, 6.0, 6.1, and 7.07.0, 7.1, and 8.0 allow a maximum length of 512 bytes (including the mandatory null terminator). The field MUST contain at least a null terminator character in Windows-1252 or Unicode format (depending on the presence of the INFO_UNICODE flag)."};
  
    string Password with BinaryEncoding{TextEncoding = TextEncoding.UTF16},
             Documentation
           {Description = "Variable-length logon password of the user (the length in bytes is given by the cbPassword field). The maximum length allowed by RDP 4.0 and RDP 5.0 servers is 32 bytes (including the mandatory null terminator). RDP 5.1, 5.2, 6.0, 6.1, and 7.07.0, 7.1, and 8.0 allow a maximum length of 512 bytes (including the mandatory null terminator). The field MUST contain at least a null terminator character in Windows-1252 or Unicode format (depending on the presence of the INFO_UNICODE flag)."};
  
    string AlternateShell with BinaryEncoding{TextEncoding = TextEncoding.UTF16},
             Documentation
           {Description = "Variable-length path to the executable file of an alternate shell, e.g. \"c:\\dir\\prog.exe\" (the length in bytes is given by the cbAlternateShell field). The maximum allowed length is 512 bytes (including the mandatory null terminator). This field MUST only be initialized if the client is requesting a shell other than the default. The field MUST contain at least a null terminator character in Windows-1252 or Unicode format (depending on the presence of the INFO_UNICODE flag)."};
  
    string WorkingDir with BinaryEncoding{TextEncoding = TextEncoding.UTF16},
             Documentation
           {Description = "Variable-length directory that contains the executable file specified in the AlternateShell field or any related files (the length in bytes is given by the cbWorkingDir field). The maximum allowed length is 512 bytes (including the mandatory null terminator). This field MAY be initialized if the client is requesting a shell other than the default. The field MUST contain at least a null terminator character in Windows-1252 or Unicode format (depending on the presence of the INFO_UNICODE flag)."};
  
    TSExtendedInfoPacket ExtraInfo
        with Documentation
           {Description = "Optional and variable-length extended information used in RDP 5.0, 5.1, 5.2, 6.0, 6.1, and 7.07.0, 7.1, and 8.0, and specified in section ."};
}
with Documentation
       {Applicability = "2.2.1.11.1.1",
        Description = "The TS_INFO_PACKET structure contains sensitive information (such as autologon password data) not passed to the server during the Basic Settings Exchange phase of the RDP Connection Sequence (see section  for an overview of the RDP Connection Sequence phases). The Info Packet is embedded in a Client Info PDU Data structure and SHOULD be encrypted (see sections  and  for an overview of RDP security mechanisms)."};

pattern TSInfoPacketFlags = flags uint
{
    InfoMouse = 0x00000001
      with Documentation
             {Description = "Indicates that the client machine has a mouse attached."},
    InfoDisableCtrlAltDel = 0x00000002
      with Documentation
             {Description = "Indicates that the CTRL+ALT+DEL (or the equivalent) secure access keyboard sequence is not required at the logon prompt."},
    InfoAutoLogon = 0x00000008
      with Documentation
             {Description = "The client requests auto logon using the included user name, password and domain."},
    InfoUnicode = 0x00000010
      with Documentation
             {Description = "Indicates that the character set for strings in the Info Packet and Extended Info Packet is Unicode. If this flag is absent, then the ANSI character set that is specified by the ANSI code page descriptor in the CodePage field is used for strings in the Info Packet and Extended Info Packet."},
    InfoMaximizeShell = 0x00000020
      with Documentation
             {Description = "Indicates that the alternate shell (specified in the AlternateShell field of the Info Packet structure) MUST be started in a maximized state."},
    InfoLogonNotify = 0x00000040
      with Documentation
             {Description = "Indicates that the client wants to be informed of the user name and domain used to log on to the server, as well as the ID of the session to which the user connected. The Save Session Info PDU is sent from the server to notify the client of this information using a Logon Info Version 1 or Logon Info Version 2 structure."},
    InfoCompression = 0x00000080
      with Documentation
             {Description = "Indicates that the CompressionTypeMask is valid and contains the highest compression package type supported by the client."},
    CompressionTypeMask = 0x00001E00
      with Documentation
             {Description = "Indicates the highest compression package type supported. See the discussion which follows this table for more information."},
    InfoEnableWindowsKey = 0x00000100
      with Documentation
             {Description = "Indicates that the client uses the Windows key on Windows-compatible keyboards."},
    InfoRemoteConsoleAudio = 0x00002000
      with Documentation
             {Description = "Requests that audio played in a session hosted on a remote server be played on the server using the protocol defined in [MS-RDPEA] sections  and ."},
    InfoForceEncryptedCsPdu = 0x00004000
      with Documentation
             {Description = "Indicates that all client-to-server traffic is encrypted when encryption is in force. Setting this flag prevents the server from processing unencrypted packets in man-in-the-middle attack scenarios. This flag is only supported by RDP 5.2, 6.0, 6.1, and 7.07.0, 7.1, and 8.0 servers."},
    InfoRail = 0x00008000
      with Documentation
             {Description = "Indicates that the remote connection being established is for the purpose of launching remote programs using the protocol defined in [MS-RDPERP] sections  and . This flag is only supported by RDP 6.0, 6.1, and 7.07.0, 7.1, and 8.0 servers."},
    InfoLogonErrors = 0x00010000
      with Documentation
             {Description = "Indicates a request for logon error notifications using the Save Session Info PDU. This flag is only supported by RDP 6.0, 6.1, and 7.07.0, 7.1, and 8.0 servers."},
    InfoMouseHasWheel = 0x00020000
      with Documentation
             {Description = "Indicates that the mouse which is connected to the client machine has a scroll wheel. This flag is only supported by RDP 6.0, 6.1, and 7.07.0, 7.1, and 8.0 servers."},
    InfoPasswordISSCPin = 0x00040000
      with Documentation
             {Description = "Indicates that the Password field in the Info Packet contains a smart card personal identification number (PIN). This flag is only supported by RDP 6.0, 6.1, and 7.07.0, 7.1, and 8.0 servers."},
    InfoNoAudioPlayback = 0x00080000
      with Documentation
             {Description = "Indicates that audio redirection or playback (using the protocol defined in [MS-RDPEA] sections  and ) MUST NOT take place. This flag is only supported by RDP 6.0, 6.1, and 7.07.0, 7.1, and 8.0 servers."},
    InfoUsingSavedCreds = 0x00100000
      with Documentation
             {Description = "Any user credentials sent on the wire during the RDP Connection Sequence (see sections  and ) have been retrieved from a credential store and were not obtained directly from the user."},
    RnsInfoAudioCapture = 0x00200000
      with Documentation
             {Description = "Indicates that the redirection of client-side audio input to a session hosted on a remote server is supported using the protocol defined in [MS-RDPEAI] sections  and . This flag is only supported by RDP 7.0 servers."},
    RnsInfoVideoDisable = 0x00400000
      with Documentation
             {Description = "Indicates that video redirection or playback (using the protocol defined in [MS-RDPEV] sections  and ) MUST NOT take place. This flag is only supported by RDP 7.0 servers."},
    Unused = 0xFF800004
} with Documentation {EmbeddedType = true};

// 2.2.1.11.1.1.1   Extended Info Packet (TS_EXTENDED_INFO_PACKET)
type TSExtendedInfoPacket
{
    TSExtendedInfoPacketClientAddressFamily ClientAddressFamily
        where ValidationCheckEnumValue(InRange<TSExtendedInfoPacketClientAddressFamily>(value), null, true, ReferenceType.Type, "RDPBCGR", "ClientAddressFamily", "TSExtendedInfoPacket", "0x0002, 0x0017", value)
        with Documentation
           {Description = "A 16-bit, unsigned integer. The numeric socket descriptor for the client address type."};
  
    ushort CbClientAddress
        with Documentation
           {Description = "A 16-bit, unsigned integer. The size in bytes of the character data in the clientAddress field. This size includes the length of the mandatory null terminator."};
  
    string ClientAddress with BinaryEncoding{TextEncoding = TextEncoding.UTF16},
             Documentation
           {Description = "Variable-length textual representation of the client IPv4 or IPv6 address. The maximum allowed length (including the mandatory null terminator) is 64 bytes for RDP 5.0, 5.1, 5.2, and 6.0, and 80 bytes for RDP 6.1 and 7.0."};
  
    ushort CbClientDir
        with Documentation
           {Description = "A 16-bit, unsigned integer. The size in bytes of the character data in the clientDir field. This size includes the length of the mandatory null terminator."};
  
    string ClientDir with BinaryEncoding{TextEncoding = TextEncoding.UTF16},
             Documentation
           {Description = "Variable-length directory that contains either (a) the folder path on the client machine from which the client software is being run, or (b) the full path of the software module implementing the client (see section  for an example). The maximum allowed length is 512 bytes (including the mandatory null terminator)."};
  
    TSTimeZoneInformation ClientTimeZone
        with Documentation
           {Description = "A TS_TIME_ZONE_INFORMATION structure that contains time zone information for a client. This packet is used by RDP 5.2, 6.0, 6.1, and 7.07.0, 7.1, and 8.0 servers."};
  
    optional [|ClientTimeZone != nothing|] uint ClientSessionId
        with Documentation
           {Description = "A 32-bit, unsigned integer. This field was added in RDP 5.1 and is currently ignored by the server. It SHOULD be set to 0."};
  
    optional [|ClientSessionId != nothing|] TSExtendedInfoPacketPerformanceFlags PerformanceFlags
        with Documentation
           {Description = "A 32-bit, unsigned integer. It specifies a list of server desktop shell features to enable or disable in the session (with the goal of optimizing bandwidth usage). It is used by RDP 5.1, 5.2, 6.0, 6.1, and 7.07.0, 7.1, and 8.0 servers."};
  
    optional [|PerformanceFlags != nothing|] ushort cbAutoReconnectCookie
        with Documentation
           {Description = "A 16-bit, unsigned integer. The size in bytes of the cookie specified by the autoReconnectCookie field. This field is only read by RDP 5.2, 6.0, 6.1, and 7.07.0, 7.1, and 8.0 servers."};
  
    optional ([|(cbAutoReconnectCookie != nothing) && (cbAutoReconnectCookie > 0)|] ArcCSPrivatePacket) AutoReconnectCookie
        with Documentation
           {Description = "Buffer containing an ARC_CS_PRIVATE_PACKET structure. This buffer is a unique cookie that allows a disconnected client to seamlessly reconnect to a previously established session (see section  for more details). The autoReconnectCookie field is only read by RDP 5.2, 6.0, 6.1, and 7.07.0, 7.1, and 8.0 servers and the maximum allowed length is 128 bytes."};
  
    optional [|cbAutoReconnectCookie != nothing|] ushort Reserved1
        with Documentation
           {Description = "This field is reserved for future use and has no effect on RDP wire traffic. If this field is present, the reserved2 field MUST be present."};
  
    optional [|Reserved1 != nothing|] ushort Reserved2
        with Documentation
           {Description = "This field is reserved for future use and has no effect on RDP wire traffic. This field MUST be present if the reserved1 field is present."};
           
    optional ushort CbDynamicDSTTimeZoneKeyName where ValidationCheckLessThanOrEqualTo(value == nothing || (value as ushort) <= 254, null, false, ReferenceType.Type, "RDPBCGR", "CbDynamicDSTTimeZoneKeyName", "TSExtendedInfoPacket", 254, ((value is nothing) ? "": (value as ushort)))
        with Documentation
           {Description = "A 16-bit, unsigned integer. The size, in bytes, of the dynamicDSTTimeZoneKeyName field."};

    optional [|(CbDynamicDSTTimeZoneKeyName != nothing)|] string DynamicDSTTimeZoneKeyName with BinaryEncoding{TextEncoding = TextEncoding.UTF16, Length = (CbDynamicDSTTimeZoneKeyName as ushort)/2},
        Documentation
           {Description = "A variable-length array of Unicode characters with no terminating null, containing the descriptive name of the Dynamic DST time zone on the client."};

    optional [|(CbDynamicDSTTimeZoneKeyName != nothing)|] ushort DynamicDaylightTimeDisabled
        with Documentation
           {Description = "A 16-bit, unsigned integer that specifies whether Dynamic DST MUST be disabled in the remote session."};
}
with Documentation
       {Applicability = "2.2.1.11.1.1.1",
        Description = "The TS_EXTENDED_INFO_PACKET structure contains user information specific to RDP 5.0, 5.1, 5.2, 6.0, 6.1, and 7.07.0, 7.1, and 8.0."};

pattern TSExtendedInfoPacketClientAddressFamily = enum ushort
{
    AFInet = 0x0002
      with Documentation
             {Description = "The clientAddress field contains an IPv4 address."},
    AFInet6 = 0x0017
      with Documentation
             {Description = "The clientAddress field contains an IPv6 address."},
    ...
} with Documentation {EmbeddedType = true};

// 2.2.1.11.1.1.1.1   Time Zone Information (TS_TIME_ZONE_INFORMATION)
type TSTimeZoneInformation
{
    uint Bias
        with Documentation
           {Description = "A 32-bit, unsigned integer that contains the current bias for local time translation on the client. The bias is the difference, in minutes, between Coordinated Universal Time (UTC) and local time. All translations between UTC and local time are based on the following formula:"};
  
    string StandardName with BinaryEncoding{TextEncoding = TextEncoding.UTF16, Length = 32},
             Documentation
           {Description = "An array of 32 Unicode characters. The descriptive name for standard time on the client."};
  
    TSSystemTime StandardDate
        with Documentation
           {Description = "A TS_SYSTEMTIME structure that contains the date and local time when the transition from daylight saving time to standard time occurs on the client. If this field contains a valid date and time, then the DaylightDate field MUST also contain a valid date and time. If the wYear, wMonth, wDayOfWeek, wDay, wHour, wMinute, wSecond, and wMilliseconds fields are all set to zero, then the client does not support daylight saving time."};
  
    uint StandardBias
        with Documentation
           {Description = "A 32-bit, unsigned integer that contains the bias value to be used during local time translations that occur during standard time. This value is added to the value of the Bias field to form the bias used during standard time. This field MUST be ignored if a valid date and time is not specified in the StandardDate field or the wYear, wMonth, wDayOfWeek, wDay, wHour, wMinute, wSecond, and wMilliseconds fields of the StandardDate field are all set to zero."};
  
    string DaylightName with BinaryEncoding{TextEncoding = TextEncoding.UTF16, Length = 32},
             Documentation
           {Description = "An array of 32 Unicode characters. The descriptive name for daylight saving time on the client."};
  
    TSSystemTime DaylightDate
        with Documentation
           {Description = "A TS_SYSTEMTIME structure that contains a date and local time when the transition from standard time to daylight saving time occurs on the client. If this field contains a valid date and time, then the StandardDate field MUST also contain a valid date and time. If the wYear, wMonth, wDayOfWeek, wDay, wHour, wMinute, wSecond, and wMilliseconds fields are all set to zero, then the client does not support daylight saving time."};
  
    uint DaylightBias
        with Documentation
           {Description = "A 32-bit, unsigned integer that contains the bias value to be used during local time translations that occur during daylight saving time. This value is added to the value of the Bias field to form the bias used during daylight saving time. This field MUST be ignored if a valid date and time is not specified in the DaylightDate field or the wYear, wMonth, wDayOfWeek, wDay, wHour, wMinute, wSecond, and wMilliseconds fields of the DaylightDate field are all set to zero."};
}
with Documentation
       {Applicability = "2.2.1.11.1.1.1.1",
        Description = "The TS_TIME_ZONE_INFORMATION structure contains client time zone information."};

// 2.2.1.11.1.1.1.1.1   System Time (TS_SYSTEMTIME)
type TSSystemTime
{
    ushort WYear where ValidationCheckZero(value == 0, null, true, ReferenceType.Type, "RDPBCGR", "WYear", "TSSystemTime", value)
        with Documentation
           {Description = "A 16-bit, unsigned integer. This field MUST be set to zero."};
  
    TSSystemTimeWMonth WMonth
        with Documentation
           {Description = "A 16-bit, unsigned integer. The month when transition occurs."};
  
    TSSystemTimeWDayOfWeek WDayOfWeek
        with Documentation
           {Description = "A 16-bit, unsigned integer. The day of the week when transition occurs."};
  
    TSSystemTimeWDay WDay
        with Documentation
           {Description = "A 16-bit, unsigned integer. The occurrence of wDayOfWeek within the month when the transition takes place."};
  
    ushort WHour where value >= 0 && value <= 23
        with Documentation
           {Description = "A 16-bit, unsigned integer. The hour when transition occurs (0 to 23)."};
  
    ushort WMinute where value >= 0 && value <= 59
        with Documentation
           {Description = "A 16-bit, unsigned integer. The minute when transition occurs (0 to 59)."};
  
    ushort WSecond where value >= 0 && value <= 59
        with Documentation
           {Description = "A 16-bit, unsigned integer. The second when transition occurs (0 to 59)."};
  
    ushort WMilliseconds where value >= 0 && value <= 999
        with Documentation
           {Description = "A 16-bit, unsigned integer. The millisecond when transition occurs (0 to 999)."};
}
with Documentation
       {Applicability = "2.2.1.11.1.1.1.1.1",
        Description = "The TS_SYSTEMTIME structure contains a date and local time when the transition occurs between daylight saving time to standard time occurs or standard time to daylight saving time."};

pattern TSSystemTimeWMonth = enum ushort
{
    Undefined = 0,
    January = 1 with Documentation {Description = "January"},
    February = 2 with Documentation {Description = "February"},
    March = 3 with Documentation {Description = "March"},
    April = 4 with Documentation {Description = "April"},
    May = 5 with Documentation {Description = "May"},
    June = 6 with Documentation {Description = "June"},
    July = 7 with Documentation {Description = "July"},
    August = 8 with Documentation {Description = "August"},
    September = 9 with Documentation {Description = "September"},
    October = 10 with Documentation {Description = "October"},
    November = 11 with Documentation {Description = "November"},
    December = 12 with Documentation {Description = "December"}
} with Documentation {EmbeddedType = true};

pattern TSSystemTimeWDayOfWeek = enum ushort
{
    Sunday = 0 with Documentation {Description = "Sunday"},
    Monday = 1 with Documentation {Description = "Monday"},
    Tuesday = 2 with Documentation {Description = "Tuesday"},
    Wednesday = 3 with Documentation {Description = "Wednesday"},
    Thursday = 4 with Documentation {Description = "Thursday"},
    Friday = 5 with Documentation {Description = "Friday"},
    Saturday = 6 with Documentation {Description = "Saturday"}
} with Documentation {EmbeddedType = true};

pattern TSSystemTimeWDay = enum ushort
{
    Undefined = 0,
    FirstOccurrence  = 1
      with Documentation {Description = "First occurrence of wDayOfWeek"},
    SecondOccurrence = 2
      with Documentation {Description = "Second occurrence of wDayOfWeek"},
    ThirdOccurrence = 3
      with Documentation {Description = "Third occurrence of wDayOfWeek"},
    FourthOccurrence = 4
      with Documentation {Description = "Fourth occurrence of wDayOfWeek"},
    LastOccurrence = 5
      with Documentation {Description = "Last occurrence of wDayOfWeek"}
} with Documentation {EmbeddedType = true};

pattern TSExtendedInfoPacketPerformanceFlags = flags uint
{
    PerfDisableWallpaper = 0x00000001
      with Documentation {Description = "Disable desktop wallpaper."},
    PerfDisableFullWindowDrag = 0x00000002
      with Documentation {Description = "Disable full-window drag (only the window outline is displayed when the window is moved)."},
    PerfDisableMenuanimations = 0x00000004
      with Documentation {Description = "Disable menu animations."},
    PerfDisableTheming = 0x00000008
      with Documentation {Description = "Disable user interface themes."},
    PerfReserved1 = 0x00000010
      with Documentation {Description = "Reserved for future use."},
    PerfDisableCursorShadow = 0x00000020
      with Documentation {Description = "Disable mouse cursor shadows."},
    PerfDisableCursorSettings = 0x00000040
      with Documentation {Description = "Disable cursor blinking."},
    PerfEnableFontSmoothing = 0x00000080
      with Documentation {Description = "Enable font smoothing."},
    PerfEnableDesktopComposition = 0x00000100
      with Documentation {Description = "Enable Desktop Composition."},
    PerfReserved2 = 0x80000000
      with Documentation {Description = "Reserved for future use."},
    Unused = 0X7FFFFE00
} with Documentation {EmbeddedType = true};

// 2.2.1.12.1.1   Licensing Preamble (LICENSE_PREAMBLE)
type LicensePreamble
{
    LicensePreambleBMsgType BMsgType
        with Documentation
           {Description = "An 8-bit, unsigned integer. A type of the licensing packet. For more details about the different licensing packets, see [MS-RDPELE] section ."};
  
    LicensePreambleFlags Flags
        with Documentation
           {Description = "An 8-bit unsigned integer. License preamble flags."};
  
    ushort WMsgSize
        with Documentation
           {Description = "An 16-bit, unsigned integer. The size in bytes of the licensing packet (including the size of the preamble)."};
}
with Documentation
       {Applicability = "2.2.1.12.1",
        Description = "The LICENSE_PREAMBLE structure precedes every licensing packet sent on the wire."};

pattern LicensePreambleBMsgType = enum byte
{
    // Send by server
    LICENSE_REQUEST = 0x01
      with Documentation
             {Description = "Indicates a License Request PDU ([MS-RDPELE] section )."},
    PLATFORM_CHALLENGE = 0x02
      with Documentation
             {Description = "Indicates a Platform Challenge PDU ([MS-RDPELE] section )."},
    NEW_LICENSE = 0x03
      with Documentation
             {Description = "Indicates a New License PDU ([MS-RDPELE] section )."},
    UPGRADE_LICENSE = 0x04
      with Documentation
             {Description = "Indicates an Upgrade License PDU ([MS-RDPELE] section )."},
             
    // Send by client
    LICENSE_INFO = 0x12
      with Documentation
             {Description = "Indicates a License Information PDU ([MS-RDPELE] section 2.2.2.3)."},
    NEW_LICENSE_REQUEST = 0x13
      with Documentation
             {Description = "Indicates a New License Request PDU ([MS-RDPELE] section 2.2.2.2)."},      
    PLATFORM_CHALLENGE_RESPONSE = 0x15
      with Documentation
             {Description = "Indicates a Platform Challenge Response PDU ([MS-RDPELE] section 2.2.2.5)."},
             
    // Sent by either client or server
    ERROR_ALERT = 0xFF
      with Documentation
            {Description = "Indicates a Licensing Error Message PDU (section 2.2.1.12.1.3)."}        
} with Documentation {EmbeddedType = true};

pattern LicenseProtocolVersionMaskValue = enum byte
{
    PREAMBLE_VERSION_2_0 = 0x02
      with Documentation
            {Description = "RDP 4.0"},
    PREAMBLE_VERSION_3_0 = 0x03
      with Documentation
            {Description = "RDP 5.0, 5.1, 5.2, 6.0, 6.1, 7.0, 7.1, and 8.0"}  
            
}with Documentation {EmbeddedType = true};

type LicensePreambleFlags
{    
    bool  ExtendedErrorMsgSupported with BinaryEncoding{Width = 1},
        Documentation
             {Description = "Indicates that extended error information using the License Error Message is supported."};
    
    byte Reserved with BinaryEncoding{Width = 3}, 
        Documentation
             {Description = "Reserved"};
                      
    LicenseProtocolVersionMaskValue LicenseProtocolVersionMask with BinaryEncoding{Width = 4},
        Documentation
             {Description = "The license protocol version. See the discussion which follows this table for more information."};
} with Documentation {EmbeddedType = true};

// 2.2.1.12.1.2   Licensing Binary Blob (LICENSE_BINARY_BLOB)
type LicenseBinaryBlob
{
    LicenseBinaryBlobWBlobType WBlobType
        with Documentation
           {Description = "A 16-bit, unsigned integer. The data type of the binary information. If wBlobLen is set to 0, then the contents of this field SHOULD be ignored."};
  
    ushort WBlobLen
        with Documentation
           {Description = "A 16-bit, unsigned integer. The size in bytes of the binary information in the blobData field. If wBlobLen is set to 0, then the blobData field is not included in the Licensing Binary BLOB structure and the contents of the wBlobType field SHOULD be ignored."};
    
    // extend RDPBCGR accroding to [MS-RDPELE] section 2.2.2.1, 2.2.2.1.2.1
    optional [|WBlobLen > 0|] 
        ( 
            // [MS-RDPELE] 2.2.2.1 SERVER_LICENSE_REQUEST.KeyExchangeList
            ([|WBlobType == LicenseBinaryBlobWBlobType.BBKeyExchgAlgBlob|] array<KeyExchangeAlg>) | 
            // [MS-RDPELE] 2.2.2.1 SERVER_LICENSE_REQUEST.ServerCertificate
            ([|WBlobType == LicenseBinaryBlobWBlobType.BBCertificateBlob|] ServerCertificate) |
            // [MS-RDPELE] 2.2.2.1.2.1 SCOPE.Scope
            // [MS-RDPELE] 2.2.2.2 CLIENT_NEW_LICENSE_REQUEST.ClientUserName and CLIENT_NEW_LICENSE_REQUEST.ClientMachineName 
            ([|WBlobType in { LicenseBinaryBlobWBlobType.BBScopeBlob,
                                              LicenseBinaryBlobWBlobType.BBClientUserNameBlob,
                                              LicenseBinaryBlobWBlobType.BBClientMachineNameBlob
                                            }|] string) |
            binary
        ) BlobData 
            with BinaryEncoding{Length = (WBlobType == LicenseBinaryBlobWBlobType.BBKeyExchgAlgBlob) ? (WBlobLen / 4) : (WBlobLen), TextEncoding = TextEncoding.ASCII}
            with Documentation {Description = "Variable-length binary data. The size of this data in bytes is given by the wBlobLen field. If wBlobLen is set to 0, then this field is not included in the Licensing Binary BLOB structure."};
}
with Documentation
       {Applicability = "2.2.1.12.2",
        Description = "The LICENSE_BINARY_BLOB structure is used to encapsulate arbitrary length binary licensing data."};

pattern LicenseBinaryBlobWBlobType = enum ushort
{
    BBDataBlob = 0x0001
      with Documentation
             {Description = "Used by License Information PDU and Platform Challenge Response PDU ([MS-RDPELE] sections  and )."},
    BBRandomBlob = 0x0002
      with Documentation
             {Description = "Used by License Information PDU and New License Request PDU ([MS-RDPELE] sections  and )."},
    BBCertificateBlob = 0x0003
      with Documentation
             {Description = "Used by License Request PDU ([MS-RDPELE] section )."},
    BBErrorBlob = 0x0004
      with Documentation {Description = "Used by License Error PDU."},
    BBEncryptedDataBlob = 0x0009
      with Documentation
             {Description = "Used by Platform Challenge Response PDU and Upgrade License PDU ([MS-RDPELE] sections  and )."},
    BBKeyExchgAlgBlob = 0x000D
      with Documentation
             {Description = "Used by License Request PDU ([MS-RDPELE] section )."},
    BBScopeBlob = 0x000E
      with Documentation
             {Description = "Used by License Request PDU ([MS-RDPELE] section )."},
    BBClientUserNameBlob = 0x000F
      with Documentation
             {Description = "Used by New License Request PDU ([MS-RDPELE] section )."},
    BBClientMachineNameBlob = 0x0010
      with Documentation
             {Description = "Used by New License Request PDU ([MS-RDPELE] section )."}
    ...
} with Documentation {EmbeddedType = true};

// 2.2.1.12.1.3   Licensing Error Message (LICENSE_ERROR_MESSAGE)
type LicenseErrorMessage
{
    LicenseErrorMessageDwErrorCode dwErrorCode
        with Documentation
           {Description = "A 32-bit, unsigned integer. The error or status code."};
  
    LicenseErrorMessageDwStateTransition dwStateTransition
        with Documentation
           {Description = "A 32-bit, unsigned integer. The licensing state to transition into upon receipt of this message. For more details about how this field is used, see [MS-RDPELE] section ."};
  
    LicenseBinaryBlob bbErrorInfo 
        with Documentation
           {Description = "A LICENSE_BINARY_BLOB structure which MUST contain a BLOB of type BB_ERROR_BLOB (0x0004) that includes information relevant to the error code specified in dwErrorCode."};
}
with Documentation
       {Applicability = "2.2.1.12.3",
        Description = "The LICENSE_ERROR_MESSAGE structure is used to indicate that an error occurred during the licensing protocol. Alternatively, it is also used to notify the peer of important status information."};

pattern LicenseErrorMessageDwErrorCode = enum uint
{
    //Sent by client:
    ERR_INVALID_SERVER_CERTIFICATE = 0x00000001, 
    ERR_NO_LICENSE = 0x00000002,    
    
    //Sent by server:
    ERR_INVALID_SCOPE = 0x00000004,
    ERR_NO_LICENSE_SERVER = 0x00000006,
    STATUS_VALID_CLIENT = 0x00000007,
    ERR_INVALID_CLIENT = 0x00000008,
    ERR_INVALID_PRODUCTID = 0x0000000B,
    ERR_INVALID_MESSAGE_LEN = 0x0000000C,
    
    //Sent by client and server:
    ERR_INVALID_MAC = 0x00000003
} with Documentation {EmbeddedType = true};

pattern LicenseErrorMessageDwStateTransition = enum uint
{
    ST_TOTAL_ABORT = 0x00000001,
    ST_NO_TRANSITION = 0x00000002,
    ST_RESET_PHASE_TO_START = 0x00000003,
    ST_RESEND_LAST_MESSAGE = 0x00000004
} with Documentation {EmbeddedType = true};

// 2.2.1.13.1   Server Demand Active PDU
message ServerDemandActivePdu[TSUDSCSec1EncryptionLevel EncryptionLevel, TSUDSCSec1EncryptionMethod EncryptionMethod]
{
    optional (
              ([|EncryptionLevel == TSUDSCSec1EncryptionLevel.EncryptionLevelLow|] BasicSecurityHeader) |
              ([|EncryptionMethod in {TSUDSCSec1EncryptionMethod.EncryptionMethod40Bit,
                                      TSUDSCSec1EncryptionMethod.EncryptionMethod128Bit,
                                      TSUDSCSec1EncryptionMethod.EncryptionMethod56Bit}|] NonFipsSecurityHeader) |
              ([|(EncryptionMethod == TSUDSCSec1EncryptionMethod.EncryptionMethodFips)|] FipsSecurityHeader)
             ) SecurityHeader
        with Documentation
           {Description = "Optional security header. The presence and format of the security header depends on the Encryption Level and Encryption Method selected by the server (sections  and ). If the Encryption Level selected by the server is greater than ENCRYPTION_LEVEL_NONE (0) and the Encryption Method selected by the server is greater than ENCRYPTION_METHOD_NONE (0), then this field MUST contain one of the following headers:"};

    TSDemandActivePdu DemandActivePduData
        with Documentation
           {Description = "The contents of the Demand Active PDU, as specified in section ."};
           
    override string ToString()
    {
        return "Server Demand Active PDU";
    }
}
with Documentation
       {Applicability = "2.2.1.13.1",
        Description = "The Demand Active PDU is an RDP Connection Sequence PDU sent from server to client during the Capabilities Exchange phase of the RDP Connection Sequence (see section  for an overview of the RDP Connection Sequence phases). It is sent upon successful completion of the Licensing phase of the RDP Connection Sequence."};

// 2.2.1.13.1.1   Demand Active PDU Data (TS_DEMAND_ACTIVE_PDU)
type TSDemandActivePdu
{
    TSShareControlHeader ShareControlHeader
        with Documentation
           {Description = "Share Control Header containing information about the packet. The type subfield of the pduType field of the Share Control Header MUST be set to PDUTYPE_DEMANDACTIVEPDU (1)."};
  
    uint ShareId
        with Documentation
           {Description = "A 32-bit, unsigned integer. The share identifier for the packet (see [T128] section 8.4.2 for more information regarding share IDs)."};
  
    ushort LengthSourceDescriptor
        with Documentation
           {Description = "A 16-bit, unsigned integer. The size in bytes of the sourceDescriptor field."};
  
    ushort LengthCombinedCapabilities
        with Documentation
           {Description = "A 16-bit, unsigned integer. The combined size in bytes of the numberCapabilities, pad2Octets, and capabilitySets fields."};
  
    array<byte> SourceDescriptor with BinaryEncoding{Length = LengthSourceDescriptor},
             Documentation
           {Description = "A variable-length array of bytes containing a source descriptor (see [T128] section 8.4.1 for more information regarding source descriptors)."};
  
    ushort NumberCapabilities
        with Documentation
           {Description = "A 16-bit, unsigned integer. The number of capability sets included in the Demand Active PDU."};
  
    ushort Pad2Octets
        with Documentation
           {Description = "A 16-bit, unsigned integer. Padding. Values in this field MUST be ignored."};
  
    array<TSCapsSetPattern> CapabilitySets with BinaryEncoding{Length = NumberCapabilities}
        with Documentation
           {Description = "An array of Capability Set structures. The number of capability sets is specified by the numberCapabilities field."};
  
    uint SessionId
        with Documentation
           {Description = "A 32-bit, unsigned integer. The session identifier. This field is ignored by the client."};
}
with Documentation
       {Applicability = "2.2.1.13.1.1",
        Description = "The TS_DEMAND_ACTIVE_PDU structure is a standard T.128 Demand Active PDU (see [T128] section 8.4.1)."};

// 2.2.1.13.1.1.1   Capability Set (TS_CAPS_SET)
pattern TSCapsSetPattern = TSGeneralCapabilitySet | TSBitmapCapabilitySet | TSOrderCapabilitySet | TSBitmapCacheCapaibilitySet | TSBitmapCacheCapabilitySetRev2 | 
    TSPointerCapabilitySet | TSInputCapabilitySet | TSBrushCapabilitySet | TSGlyphCacheCapabilitySet | TSOffscreenCapabilitySet | TSVirtualChannelCapabilitySet | 
    TSSoundCapabilitySet | TSBitmapCacheHostSupportCapabilitySet | TSControlCapabilitySet |TSWindowActivationCapabilitySet | TSShareCapabilitySet | TSFontCapabilitySet  | 
    TSMultifragmentUpdateCapabilitySet | TSLargePointerCapabilitySet |  TSCompdeskCapabilitySet |TSSurfCmdsCapabilitySet | TSBitmapCodecsCapabilitySet |
    TSColorTableCapabilitySet | TSDrawNinegridCapabilitySet | TSDrawGDIPlusCapabilitySet | TSRemoteProgramsCapabilitySet | TSWindowListCapabilitySet | 
    UnKnownTSCapsSet;    
        
pattern UnKnownTSCapsSet = TSCapsSet | any;

type TSCapsSet
{
    TSCapsSetCapabilitySetType CapabilitySetType
        with Documentation
           {Description = "A 16-bit, unsigned integer. The type identifier of the capability set."};
  
    ushort LengthCapability
        with Documentation
           {Description = "A 16-bit, unsigned integer. The length in bytes of the capability data, including the size of the capabilitySetType and lengthCapability fields."};
  
    binary CapabilityData with BinaryEncoding{Length = (LengthCapability - 4)},
             Documentation
           {Description = "Capability set data which conforms to the structure of the type given by the capabilitySetType field."};
}
with Documentation
       {Applicability = "2.2.1.13.1.1.1",
        Description = "The TS_CAPS_SET structure is used to describe the type and size of a capability set exchanged between clients and servers. All capability sets conform to this basic structure (see section )."};

pattern TSCapsSetCapabilitySetType = enum ushort
{
    CapstypeGeneral = 0x0001
      with Documentation {Description = "General Capability Set"},
    CapstypeBitmap = 0x0002
      with Documentation {Description = "Bitmap Capability Set"},
    CapstypeOrder = 0x0003
      with Documentation {Description = "Order Capability Set"},
    CapstypeBitmapCache = 0x0004
      with Documentation {Description = "Revision 1 Bitmap Cache Capability Set"},
    CapstypeControl = 0x0005
      with Documentation {Description = "Control Capability Set"},
    CapstypeActivation = 0x0007
      with Documentation {Description = "Window Activation Capability Set"},
    CapstypePointer = 0x0008
      with Documentation {Description = "Pointer Capability Set"},
    CapstypeShare = 0x0009
      with Documentation {Description = "Share Capability Set"},
    CapstypeColorCache = 0x000A
      with Documentation
             {Description = "Color Table Cache Capability Set (see [MS-RDPEGDI] section )"},
    CapstypeSound = 0x000C
      with Documentation {Description = "Sound Capability Set"},
    CapstypeInput = 0x000D
      with Documentation {Description = "Input Capability Set"},
    CapstypeFont = 0x000E
      with Documentation {Description = "Font Capability Set"},
    CapstypeBrush = 0x000F
      with Documentation {Description = "Brush Capability Set"},
    CapstypeGlyphCache = 0x0010
      with Documentation {Description = "Glyph Cache Capability Set"},
    CapstypeOffScreenCache = 0x0011
      with Documentation {Description = "Offscreen Bitmap Cache Capability Set"},
    CapstypeBitmapcacheHostSupport = 0x0012
      with Documentation {Description = "Bitmap Cache Host Support Capability Set"},
    CapstypeBitmapCache_rev2 = 0x0013
      with Documentation {Description = "Revision 2 Bitmap Cache Capability Set"},
    CapstypeVirtualChannel = 0x0014
      with Documentation {Description = "Virtual Channel Capability Set"},
    CapstypeDrawNineGridCache = 0x0015
      with Documentation
             {Description = "DrawNineGrid Cache Capability Set ([MS-RDPEGDI] section )"},
    CapstypeDrawGdiPlus = 0x0016
      with Documentation
             {Description = "Draw GDI+ Cache Capability Set ([MS-RDPEGDI] section )"},
    CapstypeRail = 0x0017
      with Documentation
             {Description = "Remote Programs Capability Set ([MS-RDPERP] section )"},
    CapstypeWindow = 0x0018
      with Documentation
             {Description = "Window List Capability Set ([MS-RDPERP] section )"},
    CapsettypeCompdesk = 0x0019
      with Documentation
             {Description = "Desktop Composition Extension Capability Set"},
    CapsettypeMultiFragmentUpdate = 0x001A
      with Documentation {Description = "Multifragment Update Capability Set"},
    CapsettypeLargePointer = 0x001B
      with Documentation {Description = "Large Pointer Capability Set"},
    CapsettypeSurfaceCommands = 0x001C
      with Documentation {Description = "Surface Commands Capability Set"},
    CapsettypeBitmapCodecs = 0x001D
      with Documentation {Description = "Bitmap Codecs Capability Set"},
    CapssettypeFrameAckNowledge = 0x001E
      with Documentation
             {Description = "Frame Acknowledge Capability Set ([MS-RDPRFX] section )"}
} with Documentation {EmbeddedType = true};

// 2.2.1.13.2   Client Confirm Active PDU
message ClientConfirmActivePdu [TSUDSCSec1EncryptionLevel EncryptionLevel, TSUDSCSec1EncryptionMethod EncryptionMethod]
{
    optional (
              ([|EncryptionMethod in {TSUDSCSec1EncryptionMethod.EncryptionMethod40Bit,
                                      TSUDSCSec1EncryptionMethod.EncryptionMethod128Bit,
                                      TSUDSCSec1EncryptionMethod.EncryptionMethod56Bit}|] NonFipsSecurityHeader) |
              ([|(EncryptionMethod == TSUDSCSec1EncryptionMethod.EncryptionMethodFips)|] FipsSecurityHeader)
             ) SecurityHeader
        with Documentation
           {Description = "Optional security header. The presence and format of the security header depends on the Encryption Level and Encryption Method selected by the server (sections  and ). If the Encryption Level selected by the server is greater than ENCRYPTION_LEVEL_NONE (0) and the Encryption Method selected by the server is greater than ENCRYPTION_METHOD_NONE (0) then this field MUST contain one of the following headers:"};
    
    TSConfirmActivePdu ConfirmActivePduData
        with Documentation
           {Description = "The contents of the Confirm Active PDU, as specified in section ."};
           
    override string ToString()
    {
        return "Client Confirm Active PDU";
    }
}
with Documentation
       {Applicability = "2.2.1.13.2",
        Description = "The Confirm Active PDU is an RDP Connection Sequence PDU sent from client to server during the Capabilities Exchange phase of the RDP Connection Sequence (see section  for an overview of the RDP Connection Sequence phases). It is sent as a response to the Demand Active PDU . Once the Confirm Active PDU has been sent, the client can start sending input PDUs (see section ) to the server."};

// 2.2.1.13.2.1   Confirm Active PDU Data (TS_CONFIRM_ACTIVE_PDU)
type TSConfirmActivePdu
{
    TSShareControlHeader ShareControlHeader
        with Documentation
           {Description = "Share Control Header containing information about the packet. The type subfield of the pduType field of the Share Control Header MUST be set to PDUTYPE_CONFIRMACTIVEPDU (3)."};
  
    uint ShareId
        with Documentation
           {Description = "A 32-bit, unsigned integer. The share identifier for the packet (see [T128] section 8.4.2 for more information regarding share IDs)."};
  
    ushort OriginatorId where ValidationCheckValue(value == 0x03EA, null, true, ReferenceType.Type, "RDPBCGR", "OriginatorId", "TSConfirmActivePdu", "0x03EA", value)
        with Documentation
           {Description = "A 16-bit, unsigned integer. The identifier of the packet originator. This field MUST be set to the server channel ID (0x03EA)."};
  
    ushort LengthSourceDescriptor
        with Documentation
           {Description = "A 16-bit, unsigned integer. The size in bytes of the sourceDescriptor field."};
  
    ushort LengthCombinedCapabilities
        with Documentation
           {Description = "A 16-bit, unsigned integer. The combined size in bytes of the numberCapabilities, pad2Octets and capabilitySets fields."};
  
    array<byte> SourceDescriptor with BinaryEncoding{Length = LengthSourceDescriptor},
             Documentation
           {Description = "A variable-length array of bytes containing a source descriptor (see [T128] section 8.4.1 for more information regarding source descriptors)."};
  
    ushort NumberCapabilities
        with Documentation
           {Description = "A 16-bit, unsigned integer. Number of capability sets included in the Confirm Active PDU."};
  
    ushort Pad2Octets
        with Documentation
           {Description = "A 16-bit, unsigned integer. Padding. Values in this field MUST be ignored."};
  
    array<TSCapsSetPattern> CapabilitySets with BinaryEncoding{Length = NumberCapabilities},
             Documentation
           {Description = "An array of Capability Set structures. The number of capability sets is specified by the numberCapabilities field."};
}
with Documentation
       {Applicability = "2.2.1.13.2.1",
        Description = "The TS_CONFIRM_ACTIVE_PDU structure is a standard T.128 Confirm Active PDU (see [T128] section 8.4.1)."};

// 2.2.1.14   Client Synchronize PDU
message ClientSynchronizePdu[TSUDSCSec1EncryptionLevel EncryptionLevel, TSUDSCSec1EncryptionMethod EncryptionMethod]
{
    optional (
              ([|EncryptionMethod in {TSUDSCSec1EncryptionMethod.EncryptionMethod40Bit,
                                      TSUDSCSec1EncryptionMethod.EncryptionMethod128Bit,
                                      TSUDSCSec1EncryptionMethod.EncryptionMethod56Bit}|] NonFipsSecurityHeader) |
              ([|(EncryptionMethod == TSUDSCSec1EncryptionMethod.EncryptionMethodFips)|] FipsSecurityHeader)
             ) SecurityHeader
        with Documentation
           {Description = "Optional security header. The presence and format of the security header depends on the Encryption Level and Encryption Method selected by the server (sections  and ). If the Encryption Level selected by the server is greater than ENCRYPTION_LEVEL_NONE (0) and the Encryption Method selected by the server is greater than ENCRYPTION_METHOD_NONE (0), then this field MUST contain one of the following headers:"};

    TSSynchronizePdu SynchronizePduData
        with Documentation
           {Description = "The contents of the Synchronize PDU, as specified in section ."};
           
    override string ToString()
    {
        return "Client Synchronize PDU";
    }
}
with Documentation
       {Applicability = "2.2.1.14",
        Description = "The Client Synchronize PDU is an RDP Connection Sequence PDU sent from client to server during the Connection Finalization phase of the RDP Connection Sequence (see section  for an overview of the RDP Connection Sequence phases). It is sent after transmitting the Confirm Active PDU."};

// 2.2.1.14.1   Synchronize PDU Data (TS_SYNCHRONIZE_PDU)
type TSSynchronizePdu
{
    TSShareDataHeader ShareDataHeader
        with Documentation
           {Description = "Share Control Header containing information about the packet. The type subfield of the pduType field of the Share Control Header MUST be set to PDUTYPE_DATAPDU (7). The pduType2 field of the Share Data Header MUST be set to PDUTYPE2_SYNCHRONIZE (31)."};
  
    ushort MessageType where value == 1
        with Documentation
           {Description = "A 16-bit, unsigned integer. The message type. This field MUST be set to SYNCMSGTYPE_SYNC (1)."};
  
    ushort TargetUser
        with Documentation
           {Description = "A 16-bit, unsigned integer. The MCS channel ID of the target user."};
}
with Documentation
       {Applicability = "2.2.1.14.1",
        Description = "The TS_SYNCHRONIZE_PDU structure is a standard T.128 Synchronize PDU ([T128] section 8.6.1)."};

// 2.2.1.15   Client Control PDU - Cooperate
message ClientControlPduCoOperate[TSUDSCSec1EncryptionLevel EncryptionLevel, TSUDSCSec1EncryptionMethod EncryptionMethod]
{
    optional (
              ([|EncryptionMethod in {TSUDSCSec1EncryptionMethod.EncryptionMethod40Bit,
                                      TSUDSCSec1EncryptionMethod.EncryptionMethod128Bit,
                                      TSUDSCSec1EncryptionMethod.EncryptionMethod56Bit}|] NonFipsSecurityHeader) |
              ([|(EncryptionMethod == TSUDSCSec1EncryptionMethod.EncryptionMethodFips)|] FipsSecurityHeader)
             ) SecurityHeader
        with Documentation
           {Description = "Optional security header. The presence and format of the security header depends on the Encryption Level and Encryption Method selected by the server (sections  and ). If the Encryption Level selected by the server is greater than ENCRYPTION_LEVEL_NONE (0) and the Encryption Method selected by the server is greater than ENCRYPTION_METHOD_NONE (0), then this field MUST contain one of the following headers:"};

    TSControlPdu ControlPduData
        with Documentation
           {Description = "The actual contents of the Control PDU, as specified in section . The grantId and controlId fields of the Control PDU Data MUST both be set to zero, while the action field MUST be set to CTRLACTION_COOPERATE (0x0004)."};
    
    invariant ControlPduData.Action == TSControlPduAction. CtrlActionCooperate;
    
    override string ToString()
    {
        return "Client Control PDU - Cooperate";
    }
}
with Documentation
       {Applicability = "2.2.1.15",
        Description = "The Client Control (Cooperate) PDU is an RDP Connection Sequence PDU sent from client to server during the Connection Finalization phase of the RDP Connection Sequence (see section  for an overview of the RDP Connection Sequence phases). It is sent after transmitting the Client Synchronize PDU."};

// 2.2.1.15.1   Control PDU Data (TS_CONTROL_PDU)
type TSControlPdu
{
    TSShareDataHeader ShareDataHeader
        with Documentation
           {Description = "Share Data Header containing information about the packet. The type subfield of the pduType field of the Share Control Header MUST be set to PDUTYPE_DATAPDU (7). The pduType2 field of the Share Data Header MUST be set to PDUTYPE2_CONTROL (20)."};
  
    TSControlPduAction Action
        with Documentation {Description = "A 16-bit, unsigned integer. The action code."};

    ushort GrantId
        with Documentation
           {Description = "A 16-bit, unsigned integer. The grant identifier."};
  
    uint ControlId
        with Documentation
           {Description = "A 32-bit, unsigned integer. The control identifier."};
}
with Documentation
       {Applicability = "2.2.1.15.1",
        Description = "The TS_CONTROL_PDU structure is a standard T.128 Synchronize PDU (see [T128] section 8.12)."};

pattern TSControlPduAction = enum ushort
{
    CtrlActionRequestControl = 0x0001
      with Documentation {Description = "Request control"},
    CtrlActionGrantedControl = 0x0002
      with Documentation {Description = "Granted control"},
    CtrlActionDetach = 0x0003 with Documentation {Description = "Detach"},
    CtrlActionCooperate = 0x0004 with Documentation {Description = "Cooperate"}
} with Documentation {EmbeddedType = true};

// 2.2.1.16   Client Control PDU - Request Control
message ClientControlPduRequestControl[TSUDSCSec1EncryptionLevel EncryptionLevel, TSUDSCSec1EncryptionMethod EncryptionMethod]
{
    optional (
              ([|EncryptionMethod in {TSUDSCSec1EncryptionMethod.EncryptionMethod40Bit,
                                      TSUDSCSec1EncryptionMethod.EncryptionMethod128Bit,
                                      TSUDSCSec1EncryptionMethod.EncryptionMethod56Bit}|] NonFipsSecurityHeader) |
              ([|(EncryptionMethod == TSUDSCSec1EncryptionMethod.EncryptionMethodFips)|] FipsSecurityHeader)
             ) SecurityHeader
        with Documentation
           {Description = "Optional security header. The presence and format of the security header depends on the Encryption Level and Encryption Method selected by the server (sections  and ). If the Encryption Level selected by the server is greater than ENCRYPTION_LEVEL_NONE (0) and the Encryption Method selected by the server is greater than ENCRYPTION_METHOD_NONE (0), then this field MUST contain one of the following headers:"};
  
    TSControlPdu ControlPduData
        with Documentation
           {Description = "The contents of the Control PDU, as specified in section . The grantId and controlId fields of the Control PDU Data MUST both be set to zero, while the action field MUST be set to CTRLACTION_REQUEST_CONTROL (0x0001)."};
    invariant ControlPduData.Action == TSControlPduAction. CtrlActionRequestControl;
    
    override string ToString()
    {
        return "Client Control PDU - Request";
    }
}
with Documentation
       {Applicability = "2.2.1.16",
        Description = "The Client Control (Request Control) PDU is an RDP Connection Sequence PDU sent from client to server during the Connection Finalization phase of the RDP Connection Sequence (see section  for an overview of the RDP Connection Sequence phases). It is sent after transmitting the Client Control (Cooperate) PDU."};

// 2.2.1.17   Client Persistent Key List PDU
message ClientPersistentKeyListPdu[TSUDSCSec1EncryptionLevel EncryptionLevel, TSUDSCSec1EncryptionMethod EncryptionMethod]
{
    optional (
              ([|EncryptionMethod in {TSUDSCSec1EncryptionMethod.EncryptionMethod40Bit,
                                      TSUDSCSec1EncryptionMethod.EncryptionMethod128Bit,
                                      TSUDSCSec1EncryptionMethod.EncryptionMethod56Bit}|] NonFipsSecurityHeader) |
              ([|(EncryptionMethod == TSUDSCSec1EncryptionMethod.EncryptionMethodFips)|] FipsSecurityHeader)
             ) SecurityHeader
        with Documentation
           {Description = "Optional security header. The presence and format of the security header depends on the Encryption Level and Encryption Method selected by the server (sections  and ). If the Encryption Level selected by the server is greater than ENCRYPTION_LEVEL_NONE (0) and the Encryption Method selected by the server is greater than ENCRYPTION_METHOD_NONE (0), then this field MUST contain one of the following headers:"};
  
    TSBitmapCachePersistentListPdu PersistentKeyListPduData
        with Documentation
           {Description = "The contents of the Persistent Key List PDU, as specified in section ."};
           
    override string ToString()
    {
        return "Client Persistent Key List PDU";
    }
}
with Documentation
       {Applicability = "2.2.1.17",
        Description = "The Persistent Key List PDU is an RDP Connection Sequence PDU sent from client to server during the Connection Finalization phase of the RDP Connection Sequence (see section  for an overview of the RDP Connection Sequence phases). A single Persistent Key List PDU or a sequence of Persistent Key List PDUs MUST be sent after transmitting the Client Control (Request Control) PDU if the client has bitmaps that were stored in a Persistent Bitmap Cache, the server advertised support for the Bitmap Host Cache Support Capability Set, and a Deactivation-Reactivation Sequence is not in progress (see section  for an overview of the Deactivation-Reactivation Sequence)."};

// 2.2.1.17.1   Persistent Key List PDU Data (TS_BITMAPCACHE_PERSISTENT_LIST_PDU)
type TSBitmapCachePersistentListPdu
{
    TSShareDataHeader ShareDataHeader
        with Documentation
           {Description = "Share Data Header containing information about the packet. The type subfield of the pduType field of the Share Control Header MUST be set to PDUTYPE_DATAPDU (7). The pduType2 field of the Share Data Header MUST be set to PDUTYPE2_BITMAPCACHE_PERSISTENT_LIST (43)."};
  
    ushort NumEntriesCache0
        with Documentation
           {Description = "A 16-bit, unsigned integer. The number of entries for Bitmap Cache 0 in the current Persistent Key List PDU."};
  
    ushort NumEntriesCache1
        with Documentation
           {Description = "A 16-bit, unsigned integer. The number of entries for Bitmap Cache 1 in the current Persistent Key List PDU."};
  
    ushort NumEntriesCache2
        with Documentation
           {Description = "A 16-bit, unsigned integer. The number of entries for Bitmap Cache 2 in the current Persistent Key List PDU."};
  
    ushort NumEntriesCache3
        with Documentation
           {Description = "A 16-bit, unsigned integer. The number of entries for Bitmap Cache 3 in the current Persistent Key List PDU."};
  
    ushort NumEntriesCache4
        with Documentation
           {Description = "A 16-bit, unsigned integer. The number of entries for Bitmap Cache 4 in the current Persistent Key List PDU."};
  
    ushort TotalEntriesCache0
        with Documentation
           {Description = "A 16-bit, unsigned integer. The total number of entries for Bitmap Cache 0 expected across the entire sequence of Persistent Key List PDUs. This value MUST remain unchanged across the sequence. The sum of the totalEntries0, totalEntries1, totalEntries2, totalEntries3, and totalEntries4 fields MUST NOT exceed 26,2144."};
  
    ushort TotalEntriesCache1
        with Documentation
           {Description = "A 16-bit, unsigned integer. The total number of entries for Bitmap Cache 1 expected across the entire sequence of Persistent Key List PDUs. This value MUST remain unchanged across the sequence. The sum of the totalEntries0, totalEntries1, totalEntries2, totalEntries3, and totalEntries4 fields MUST NOT exceed 26,2144."};
  
    ushort TotalEntriesCache2
        with Documentation
           {Description = "A 16-bit, unsigned integer. The total number of entries for Bitmap Cache 2 expected across the entire sequence of Persistent Key List PDUs. This value MUST remain unchanged across the sequence. The sum of the totalEntries0, totalEntries1, totalEntries2, totalEntries3, and totalEntries4 fields MUST NOT exceed 26,2144."};
  
    ushort TotalEntriesCache3
        with Documentation
           {Description = "A 16-bit, unsigned integer. The total number of entries for Bitmap Cache 3 expected across the entire sequence of Persistent Key List PDUs. This value MUST remain unchanged across the sequence. The sum of the totalEntries0, totalEntries1, totalEntries2, totalEntries3, and totalEntries4 fields MUST NOT exceed 26,2144."};
  
    ushort TotalEntriesCache4
        with Documentation
           {Description = "A 16-bit, unsigned integer. The total number of entries for Bitmap Cache 4 expected across the entire sequence of Persistent Key List PDUs. This value MUST remain unchanged across the sequence."};
  
    TSBitmapcachePersistentListPduBBitMask BBitMask where ValidationCheckCombinationValueIncludeZero(InRange<TSBitmapcachePersistentListPduBBitMask>(value), null, false, ReferenceType.Type, "RDPBCGR", "BBitMask", "TSBitmapCachePersistentListPdu", "0x01, 0x02", value)
        with Documentation
           {Description = "An 8-bit, unsigned integer. The sequencing flag."};
  
    byte Pad2
        with Documentation
           {Description = "An 8-bit, unsigned integer. Padding. Values in this field MUST be ignored."};
  
    ushort Pad3
        with Documentation
           {Description = "A 16-bit, unsigned integer. Padding. Values in this field MUST be ignored."};
  
    optional [|(NumEntriesCache0 + NumEntriesCache1 + NumEntriesCache2 + NumEntriesCache3 + NumEntriesCache4) > 0|]array<TSBitmapCachePersistentListEntry> Entries with BinaryEncoding{Length = ((NumEntriesCache0 + NumEntriesCache1 + NumEntriesCache2 + NumEntriesCache3 + NumEntriesCache4))},
             Documentation
           {Description = "An array of TS_BITMAPCACHE_PERSISTENT_LIST_ENTRY structures which describe 64-bit bitmap keys. The keys MUST be arranged in order from low cache number to high cache number. For instance, if a PDU contains one key for Bitmap Cache 0 and two keys for Bitmap Cache 1, then numEntriesCache0 will be set to 1, numEntriesCache1 will be set to 2, and numEntriesCache2, numEntriesCache3, and numEntriesCache4 will all be set to zero. The keys will be arranged in the following order: (Bitmap Cache 0, Key 1), (Bitmap Cache 1, Key 1), (Bitmap Cache 1, Key 2)."};
}
with Documentation
       {Applicability = "2.2.1.17.1",
        Description = "The TS_BITMAPCACHE_PERSISTENT_LIST_PDU structure contains a list of cached bitmap keys saved from Cache Bitmap (Revision 2) Orders (see [MS-RDPEGDI] section ) that were sent in previous sessions. By including a key in the Persistent Key List PDU Data the client indicates to the server that it has a local copy of the bitmap associated with the key, which means that the server does not need to retransmit the bitmap to the client (for more details about the Persistent Bitmap Cache, see [MS-RDPEGDI] section 3.1.1.1.1). The bitmap keys can be sent in more than one Persistent Key List PDU, with each PDU being marked using flags in the bBitMask field. The number of bitmap keys encapsulated within the Persistent Key List PDU Data SHOULD be limited to 169."};

pattern TSBitmapcachePersistentListPduBBitMask = flags byte
{
    PersistFirstPdu = 0x01
      with Documentation
             {Description = "Indicates that the PDU is the first in a sequence of Persistent Key List PDUs."},
    PersistLastPdu = 0x02
      with Documentation
             {Description = "Indicates that the PDU is the last in a sequence of Persistent Key List PDUs."},
    ...
} with Documentation {EmbeddedType = true};

// 2.2.1.17.1.1   Persistent List Entry (TS_BITMAPCACHE_PERSISTENT_LIST_ENTRY)
type TSBitmapCachePersistentListEntry
{
    uint Key1
        with Documentation
           {Description = "Low 32 bits of the 64-bit persistent bitmap cache key."};
  
    uint Key2
        with Documentation
           {Description = "A 32-bit, unsigned integer. High 32 bits of the 64-bit persistent bitmap cache key."};
}
with Documentation
       {Applicability = "2.2.1.17.1.1",
        Description = "The TS_BITMAPCACHE_PERSISTENT_LIST_ENTRY structure contains a 64-bit bitmap key to be sent back to the server."};

// 2.2.1.18   Client Font List PDU
message ClientFontListPdu[TSUDSCSec1EncryptionLevel EncryptionLevel, TSUDSCSec1EncryptionMethod EncryptionMethod]
{
    optional (
              ([|EncryptionMethod in {TSUDSCSec1EncryptionMethod.EncryptionMethod40Bit,
                                      TSUDSCSec1EncryptionMethod.EncryptionMethod128Bit,
                                      TSUDSCSec1EncryptionMethod.EncryptionMethod56Bit}|] NonFipsSecurityHeader) |
              ([|(EncryptionMethod == TSUDSCSec1EncryptionMethod.EncryptionMethodFips)|] FipsSecurityHeader)
             ) SecurityHeader
        with Documentation
           {Description = "Optional security header. The presence and format of the security header depends on the Encryption Level and Encryption Method selected by the server (sections  and ). If the Encryption Level selected by the server is greater than ENCRYPTION_LEVEL_NONE (0) and the Encryption Method selected by the server is greater than ENCRYPTION_METHOD_NONE (0) then this field MUST contain one of the following headers:"};
  
    TSFontListPdu FontListPduData
        with Documentation
           {Description = "The contents of the Font List PDU, as specified in section ."};
           
    override string ToString()
    {
        return "Client Font List PDU";
    }
}
with Documentation
       {Applicability = "2.2.1.18",
        Description = "The Font List PDU is an RDP Connection Sequence PDU sent from client to server during the Connection Finalization phase of the RDP Connection Sequence (see section  for an overview of the RDP Connection Sequence phases). It is sent after transmitting the Persistent Key List PDUs or, if the Persistent Key List PDUs were not sent, it is sent after transmitting the Client Control (Request Control) PDU."};

// 2.2.1.18.1   Font List PDU Data (TS_FONT_LIST_PDU)
type TSFontListPdu
{
    TSShareDataHeader ShareDataHeader
        with Documentation
           {Description = "Share Data Header containing information about the packet. The type subfield of the pduType field of the Share Control Header MUST be set to PDUTYPE_DATAPDU (7). The pduType2 field of the Share Data Header MUST be set to PDUTYPE2_FONTLIST (39)."};
  
    ushort NumberFonts where ValidationCheckZero(value == 0, null, false, ReferenceType.Type, "RDPBCGR", "NumberFonts", "TSFontListPdu", value)
        with Documentation
           {Description = "A 16-bit, unsigned integer. The number of fonts. This field SHOULD be set to 0."};
  
    ushort TotalNumFonts where ValidationCheckZero(value == 0, null, false, ReferenceType.Type, "RDPBCGR", "TotalNumFonts", "TSFontListPdu", value)
        with Documentation
           {Description = "A 16-bit, unsigned integer. The total number of fonts. This field SHOULD be set to 0."};
  
    ushort ListFlags where ValidationCheckValue(value == 0x0003, null, false, ReferenceType.Type, "RDPBCGR", "ListFlags", "TSFontListPdu", "0x0003", value)
        with Documentation
           {Description = "A 16-bit, unsigned integer. The sequence flags. This field SHOULD be set to 0x0003, which is the logical OR\'ed value of FONTLIST_FIRST (0x0001) and FONTLIST_LAST (0x0002)."};
  
    ushort EntrySize where ValidationCheckValue(value == 0x0032, null, false, ReferenceType.Type, "RDPBCGR", "EntrySize", "TSFontListPdu", "0x0032", value)
        with Documentation
           {Description = "A 16-bit, unsigned integer. The entry size. This field SHOULD be set to 0x0032 (50 bytes)."};
}
with Documentation
       {Applicability = "2.2.1.18.1",
        Description = "The TS_FONT_LIST_PDU structure contains the contents of the Font List PDU, which is a Share Data Header and four fields."};

// 2.2.1.19   Server Synchronize PDU
message ServerSynchronizePdu[TSUDSCSec1EncryptionLevel EncryptionLevel, TSUDSCSec1EncryptionMethod EncryptionMethod]
{
    optional (
              ([|EncryptionLevel == TSUDSCSec1EncryptionLevel.EncryptionLevelLow|] BasicSecurityHeader) |
              ([|EncryptionMethod in {TSUDSCSec1EncryptionMethod.EncryptionMethod40Bit,
                                      TSUDSCSec1EncryptionMethod.EncryptionMethod128Bit,
                                      TSUDSCSec1EncryptionMethod.EncryptionMethod56Bit}|] NonFipsSecurityHeader) |
              ([|(EncryptionMethod == TSUDSCSec1EncryptionMethod.EncryptionMethodFips)|] FipsSecurityHeader)
             ) SecurityHeader
        with Documentation
           {Description = "Optional security header. The presence and format of the security header depends on the Encryption Level and Encryption Method selected by the server (sections  and ). If the Encryption Level selected by the server is greater than ENCRYPTION_LEVEL_NONE (0) and the Encryption Method selected by the server is greater than ENCRYPTION_METHOD_NONE (0), then this field MUST contain one of the following headers:"};
  
    TSSynchronizePdu SynchronizePduData
        with Documentation
           {Description = "The contents of the Synchronize PDU as described in section ."};
           
    override string ToString()
    {
        return "Server Synchronize PDU";
    }
}
with Documentation
       {Applicability = "2.2.1.19",
        Description = "The Server Synchronize PDU is an RDP Connection Sequence PDU sent from server to client during the Connection Finalization phase of the RDP Connection Sequence (see section  for an overview of the RDP Connection Sequence phases). It is sent after receiving the Confirm Active PDU."};

// 2.2.1.20   Server Control PDU - Cooperate
message ServerControlPduCoOperate[TSUDSCSec1EncryptionLevel EncryptionLevel, TSUDSCSec1EncryptionMethod EncryptionMethod]
{
    optional (
              ([|EncryptionLevel == TSUDSCSec1EncryptionLevel.EncryptionLevelLow|] BasicSecurityHeader) |
              ([|EncryptionMethod in {TSUDSCSec1EncryptionMethod.EncryptionMethod40Bit,
                                      TSUDSCSec1EncryptionMethod.EncryptionMethod128Bit,
                                      TSUDSCSec1EncryptionMethod.EncryptionMethod56Bit}|] NonFipsSecurityHeader) |
              ([|(EncryptionMethod == TSUDSCSec1EncryptionMethod.EncryptionMethodFips)|] FipsSecurityHeader)
             ) SecurityHeader
        with Documentation
           {Description = "Optional security header. The presence and format of the security header depends on the Encryption Level and Encryption Method selected by the server (sections  and ). If the Encryption Level selected by the server is greater than ENCRYPTION_LEVEL_NONE (0) and the Encryption Method selected by the server is greater than ENCRYPTION_METHOD_NONE (0) then this field MUST contain one of the following headers:"};
  
    TSControlPdu ControlPduData
        with Documentation
           {Description = "The contents of the Control PDU as described in section . The grantId and controlId fields of the Control PDU Data MUST both be set to zero, while the action field MUST be set to CTRLACTION_COOPERATE (0x0004)."};
    invariant ControlPduData.Action == TSControlPduAction. CtrlActionCooperate;
    
    override string ToString()
    {
        return "Server Control PDU - Cooperate";
    }
}
with Documentation
       {Applicability = "2.2.1.20",
        Description = "The Server Control (Cooperate) PDU is an RDP Connection Sequence PDU sent from server to client during the Connection Finalization phase of the RDP Connection Sequence (see section  for an overview of the RDP Connection Sequence phases). It is sent after transmitting the Server Synchronize PDU."};

// 2.2.1.21   Server Control PDU - Granted Control
message ServerControlPduGrantedControl[TSUDSCSec1EncryptionLevel EncryptionLevel, TSUDSCSec1EncryptionMethod EncryptionMethod]
{
    optional (
              ([|EncryptionLevel == TSUDSCSec1EncryptionLevel.EncryptionLevelLow|] BasicSecurityHeader) |
              ([|EncryptionMethod in {TSUDSCSec1EncryptionMethod.EncryptionMethod40Bit,
                                      TSUDSCSec1EncryptionMethod.EncryptionMethod128Bit,
                                      TSUDSCSec1EncryptionMethod.EncryptionMethod56Bit}|] NonFipsSecurityHeader) |
              ([|(EncryptionMethod == TSUDSCSec1EncryptionMethod.EncryptionMethodFips)|] FipsSecurityHeader)
             ) SecurityHeader
        with Documentation
           {Description = "Optional security header. The presence and format of the security header depends on the Encryption Level and Encryption Method selected by the server (sections  and ). If the Encryption Level selected by the server is greater than ENCRYPTION_LEVEL_NONE (0) and the Encryption Method selected by the server is greater than ENCRYPTION_METHOD_NONE (0) then this field MUST contain one of the following headers:"};
  
    TSControlPdu ControlPduData
        with Documentation
           {Description = "The contents of the Control PDU as described in section . The action field MUST be set to CTRLACTION_GRANTED_CONTROL (0x0002). The grantId field MUST be set to the User Channel ID (see sections  and ), while the controlId field MUST be set to the server channel ID (0x03EA)."};
    invariant ControlPduData.Action == TSControlPduAction. CtrlActionGrantedControl;
    
    override string ToString()
    {
        return "Server Control PDU - Granted Control";
    }
}
with Documentation
       {Applicability = "2.2.1.21",
        Description = "The Server Control (Granted Control) PDU is an RDP Connection Sequence PDU sent from server to client during the Connection Finalization phase of the RDP Connection Sequence (see section  for an overview of the RDP Connection Sequence phases). It is sent after receiving the Client Control (Request Control) PDU."};

// 2.2.1.22   Server Font Map PDU
message ServerFontMapPdu[TSUDSCSec1EncryptionLevel EncryptionLevel, TSUDSCSec1EncryptionMethod EncryptionMethod]
{
    optional (
              ([|EncryptionLevel == TSUDSCSec1EncryptionLevel.EncryptionLevelLow|] BasicSecurityHeader) |
              ([|EncryptionMethod in {TSUDSCSec1EncryptionMethod.EncryptionMethod40Bit,
                                      TSUDSCSec1EncryptionMethod.EncryptionMethod128Bit,
                                      TSUDSCSec1EncryptionMethod.EncryptionMethod56Bit}|] NonFipsSecurityHeader) |
              ([|(EncryptionMethod == TSUDSCSec1EncryptionMethod.EncryptionMethodFips)|] FipsSecurityHeader)
             ) SecurityHeader
        with Documentation
           {Description = "Optional security header. The presence and format of the security header depends on the Encryption Level and Encryption Method selected by the server (sections  and ). If the Encryption Level selected by the server is greater than ENCRYPTION_LEVEL_NONE (0) and the Encryption Method selected by the server is greater than ENCRYPTION_METHOD_NONE (0), then this field MUST contain one of the following headers:"};
  
    TSFontMapPdu FontMapPduData
        with Documentation
           {Description = "The contents of the Font Map PDU, as specified in section ."};
           
    override string ToString()
    {
        return "Server Font Map PDU";
    }
}
with Documentation
       {Applicability = "2.2.1.22",
        Description = "The Font Map PDU is an RDP Connection Sequence PDU sent from server to client during the Connection Finalization phase of the RDP Connection Sequence (see section  for an overview of the RDP Connection Sequence phases). It is sent after receiving the Font List PDU. The Font Map PDU is the last PDU in the connection sequence."};

// 2.2.1.22.1   Font Map PDU Data (TS_FONT_MAP_PDU)
type TSFontMapPdu
{
    TSShareDataHeader ShareDataHeader
        with Documentation
           {Description = "Share Data Header. The type subfield of the pduType field of the Share Control Header MUST be set to PDUTYPE_DATAPDU (7). The pduType2 field of the Share Data Header MUST be set to PDUTYPE2_FONTMAP (40)."};
  
    ushort NumberEntries where ValidationCheckZero(value == 0, null, false, ReferenceType.Type, "RDPBCGR", "NumberEntries", "TSFontMapPdu", value)
        with Documentation
           {Description = "A 16-bit, unsigned integer. The number of fonts. This field SHOULD be set to 0."};
  
    ushort TotalNumEntries where ValidationCheckZero(value == 0, null, false, ReferenceType.Type, "RDPBCGR", "TotalNumEntries", "TSFontMapPdu", value)
        with Documentation
           {Description = "A 16-bit, unsigned integer. The total number of fonts. This field SHOULD be set to 0."};
  
    ushort MapFlags where ValidationCheckValue(value == 0x0003, null, false, ReferenceType.Type, "RDPBCGR", "MapFlags", "TSFontMapPdu", "0x0003", value)
        with Documentation
           {Description = "A 16-bit, unsigned integer. The sequence flags. This field SHOULD be set to 0x0003, which is the logical OR\'ed value of FONTMAP_FIRST (0x0001) and FONTMAP_LAST (0x0002)."};
  
    ushort EntrySize where ValidationCheckValue(value == 0x0004, null, false, ReferenceType.Type, "RDPBCGR", "EntrySize", "TSFontMapPdu", "0x0004", value)
        with Documentation
           {Description = "A 16-bit, unsigned integer. The entry size. This field SHOULD be set to 0x0004 (4 bytes)."};
}
with Documentation
       {Applicability = "2.2.1.22.1",
        Description = "The TS_FONT_MAP_PDU structure contains the contents of the Font Map PDU, which is a Share Data Header and four fields."};

// 2.2.2.1   Client Shutdown Request PDU
message ClientShutdownRequestPdu[TSUDSCSec1EncryptionLevel EncryptionLevel, TSUDSCSec1EncryptionMethod EncryptionMethod]
{
    optional (
              ([|EncryptionMethod in {TSUDSCSec1EncryptionMethod.EncryptionMethod40Bit,
                                      TSUDSCSec1EncryptionMethod.EncryptionMethod128Bit,
                                      TSUDSCSec1EncryptionMethod.EncryptionMethod56Bit}|] NonFipsSecurityHeader) |
              ([|(EncryptionMethod == TSUDSCSec1EncryptionMethod.EncryptionMethodFips)|] FipsSecurityHeader)
             ) SecurityHeader
        with Documentation
           {Description = "Optional security header. The presence and format of the security header depends on the Encryption Level and Encryption Method selected by the server (sections  and ). If the Encryption Level selected by the server is greater than ENCRYPTION_LEVEL_NONE (0) and the Encryption Method selected by the server is greater than ENCRYPTION_METHOD_NONE (0) then this field MUST contain one of the following headers:"};
  
    TSShutdownReqPdu ShutdownRequestPduData
        with Documentation
           {Description = "The contents of the Shutdown Request PDU, as specified in section ."};
           
    override string ToString()
    {
        return "Client Shutdown Request PDU";
    }
}
with Documentation
       {Applicability = "2.2.2.1",
        Description = "The Shutdown Request PDU is sent by the client as part of the User-Initiated on Client Disconnection Sequence (see section  for an overview of the User-Initiated on Client Disconnection Sequence)."};

// 2.2.2.1.1   Shutdown Request PDU Data (TS_SHUTDOWN_REQ_PDU)
type TSShutdownReqPdu
{
    TSShareDataHeader ShareDataHeader
        with Documentation
           {Description = "Share Data Header containing information about the packet. The type subfield of the pduType field of the Share Control Header MUST be set to PDUTYPE_DATAPDU (7). The pduType2 field of the Share Data Header MUST be set to PDUTYPE2_SHUTDOWN_REQUEST (36)."};
}
with Documentation
       {Applicability = "2.2.2.1.1",
        Description = "The TS_SHUTDOWN_REQ_PDU structure contains the contents of the Shutdown Request PDU, which is a Share Data Header with no PDU body."};

// 2.2.2.2   Server Shutdown Request Denied PDU
message ServerShutdownRequestDeniedPdu[TSUDSCSec1EncryptionLevel EncryptionLevel, TSUDSCSec1EncryptionMethod EncryptionMethod]
{
    optional (
              ([|EncryptionLevel == TSUDSCSec1EncryptionLevel.EncryptionLevelLow|] BasicSecurityHeader) |
              ([|EncryptionMethod in {TSUDSCSec1EncryptionMethod.EncryptionMethod40Bit,
                                      TSUDSCSec1EncryptionMethod.EncryptionMethod128Bit,
                                      TSUDSCSec1EncryptionMethod.EncryptionMethod56Bit}|] NonFipsSecurityHeader) |
              ([|(EncryptionMethod == TSUDSCSec1EncryptionMethod.EncryptionMethodFips)|] FipsSecurityHeader)
             ) SecurityHeader
        with Documentation
           {Description = "Optional security header. The presence and format of the security header depends on the Encryption Level and Encryption Method selected by the server (sections  and ). If the Encryption Level selected by the server is greater than ENCRYPTION_LEVEL_NONE (0) and the Encryption Method selected by the server is greater than ENCRYPTION_METHOD_NONE (0) then this field MUST contain one of the following headers:"};
  
    TSShutdownDeniedPdu ShutdownRequestDeniedPduData
        with Documentation
           {Description = "The contents of the Shutdown Request Denied PDU, as specified in section ."};
           
    override string ToString()
    {
        return "Server Shutdown Request Denied PDU";
    }
}
with Documentation
       {Applicability = "2.2.2.2",
        Description = "The Shutdown Request Denied PDU is sent by the server as part of the User-Initiated on Client Disconnection Sequence (see section  for an overview of the User-Initiated on Client Disconnection Sequence)."};

// 2.2.2.2.1   Shutdown Request Denied PDU Data (TS_SHUTDOWN_DENIED_PDU)
type TSShutdownDeniedPdu
{
  TSShareDataHeader ShareDataHeader
    with Documentation
           {Description = "Share Data Header containing information about the packet. The type subfield of the pduType field of the Share Control Header MUST be set to PDUTYPE_DATAPDU (7). The pduType2 field of the Share Data Header MUST be set to PDUTYPE2_SHUTDOWN_DENIED (37)."};
}
with Documentation
       {Applicability = "2.2.2.2.1",
        Description = "The TS_SHUTDOWN_DENIED_PDU structure contains the contents of the Shutdown Request Denied PDU, which is a Share Data Header with no PDU body."};

// 2.2.2.3   MCS Disconnect Provider Ultimatum PDU
message McsDisconnectProviderUltimatumPdu
{
    override string ToString()
    {
        return "MCS Disconnect Provider Ultimatum PDU";
    }
}
with Documentation
       {Applicability = "2.2.2.3",
        Description = "The MCS Disconnect Provider Ultimatum PDU is an MCS PDU sent as part of the Disconnection Sequences, described in section ."};

// 2.2.3
// 2.2.3.1   Server Deactivate All PDU
message ServerDeactivateAllPdu[TSUDSCSec1EncryptionLevel EncryptionLevel, TSUDSCSec1EncryptionMethod EncryptionMethod]
{
    optional (
              ([|EncryptionLevel == TSUDSCSec1EncryptionLevel.EncryptionLevelLow|] BasicSecurityHeader) |
              ([|EncryptionMethod in {TSUDSCSec1EncryptionMethod.EncryptionMethod40Bit,
                                      TSUDSCSec1EncryptionMethod.EncryptionMethod128Bit,
                                      TSUDSCSec1EncryptionMethod.EncryptionMethod56Bit}|] NonFipsSecurityHeader) |
              ([|(EncryptionMethod == TSUDSCSec1EncryptionMethod.EncryptionMethodFips)|] FipsSecurityHeader)
             ) SecurityHeader
        with Documentation
           {Description = "Optional security header. The presence and format of the security header depends on the Encryption Level and Encryption Method selected by the server (sections  and ). If the Encryption Level selected by the server is greater than ENCRYPTION_LEVEL_NONE (0) and the Encryption Method selected by the server is greater than ENCRYPTION_METHOD_NONE (0) then this field MUST contain one of the following headers:"};
  
    TSDeactivateAllPdu DeactivateAllPduData
        with Documentation
           {Description = "The contents of the Deactivate All PDU, as specified in section ."};
           
    override string ToString()
    {
        return "Server Deactivate All PDU";
    }
}
with Documentation
       {Applicability = "2.2.3.1",
        Description = "The Deactivate All PDU is sent from server to client to indicate that the connection will be dropped or that a capability re-exchange using a Deactivation-Reactivation Sequence will occur (see section  for an overview of the Deactivation-Reactivation Sequence)."};

// 2.2.3.1.1   Deactivate All PDU Data (TS_DEACTIVATE_ALL_PDU)
type TSDeactivateAllPdu
{
    TSShareControlHeader ShareControlHeader
        with Documentation
           {Description = "Share Control Header containing information about the packet."};
  
    uint ShareId
        with Documentation
           {Description = "A 32-bit, unsigned integer. The share identifier for the packet (see [T128] section 8.4.2 for more information regarding share IDs)."};
  
    ushort LengthSourceDescriptor
        with Documentation
           {Description = "A 16-bit, unsigned integer. The size in bytes of the sourceDescriptor field."};
  
    binary SourceDescriptor
        with Documentation
           {Description = "Variable number of bytes. The source descriptor. This field SHOULD be set to 0x00."},
           BinaryEncoding{Length = (LengthSourceDescriptor as ushort)};
}
with Documentation
       {Applicability = "2.1.3.1.1",
        Description = "The TS_DEACTIVATE_ALL_PDU structure is a standard T.128 Deactivate All PDU (see [T128] section 8.4.1)."};

        
        
// 2.2.4
// 2.2.4.1   Server Auto-Reconnect Status PDU
message ServerAutoReconnectStatusPdu[TSUDSCSec1EncryptionLevel EncryptionLevel, TSUDSCSec1EncryptionMethod EncryptionMethod]
{
    optional (
              ([|EncryptionLevel == TSUDSCSec1EncryptionLevel.EncryptionLevelLow|] BasicSecurityHeader) |
              ([|EncryptionMethod in {TSUDSCSec1EncryptionMethod.EncryptionMethod40Bit,
                                      TSUDSCSec1EncryptionMethod.EncryptionMethod128Bit,
                                      TSUDSCSec1EncryptionMethod.EncryptionMethod56Bit}|] NonFipsSecurityHeader) |
              ([|(EncryptionMethod == TSUDSCSec1EncryptionMethod.EncryptionMethodFips)|] FipsSecurityHeader)
             ) SecurityHeader
        with Documentation
           {Description = "Optional security header. The presence and format of the security header depends on the Encryption Level and Encryption Method selected by the server (sections  and ). If the Encryption Level selected by the server is greater than ENCRYPTION_LEVEL_NONE (0) and the Encryption Method selected by the server is greater than ENCRYPTION_METHOD_NONE (0) then this field MUST contain one of the following headers:"};
  
    TSAutoReconnectStatusPdu ArcStatusPduData
        with Documentation
           {Description = "The contents of the Auto-Reconnect Status PDU, as specified in section ."};
           
    override string ToString()
    {
        return "Server Auto-Reconnect Status PDU";
    }
}
with Documentation
       {Applicability = "2.2.4.1",
        Description = "The Auto-Reconnect Status PDU is sent by the server to the client to indicate that automatic reconnection using the Client Auto-Reconnection Packet, sent as part of the extended information of the Client Info PDU, has failed."};

// 2.2.4.1.1   Auto-Reconnect Status PDU Data (TS_AUTORECONNECT_STATUS_PDU)
type TSAutoReconnectStatusPdu
{
    TSShareDataHeader ShareDataHeader
        with Documentation
           {Description = "Share Data Header containing information about the packet. The type subfield of the pduType field of the Share Control Header MUST be set to PDUTYPE_DATAPDU (7). The pduType2 field of the Share Data Header MUST be set to PDUTYPE2_ARC_STATUS_PDU (50), and the pduSource field MUST be set to 0."};
  
    uint ArcStatus where ValidationCheckZero(value == 0, null, true, ReferenceType.Type, "RDPBCGR", "ArcStatus", "TSAutoReconnectStatusPdu", value)
        with Documentation
           {Description = "A 32-bit, unsigned integer. This field MUST be set to 0."};
}
with Documentation
       {Applicability = "2.2.4.1.1",
        Description = "The TS_AUTORECONNECT_STATUS_PDU structure contains the contents of the Auto-Reconnect Status PDU, which is a Share Data Header with a status field."};

// 2.2.4.2   Server Auto-Reconnect Packet (ARC_SC_PRIVATE_PACKET)
type ArcSCPrivatePacket
{
    uint CBLen where ValidationCheckValue(value == 0x0000001C, null, true, ReferenceType.Type, "RDPBCGR", "CBLen", "ArcSCPrivatePacket", "0x0000001C", value)
        with Documentation
           {Description = "A 32-bit, unsigned integer. The length in bytes of the Server Auto-Reconnect packet. This field MUST be set to 0x0000001C (28 bytes)."};
  
    ArcSCPrivatePacketVersion Version where ValidationCheckValue(value == ArcSCPrivatePacketVersion.AutoReconnectVersion1, null, false, ReferenceType.Type, "RDPBCGR", "Version", "ArcSCPrivatePacket", "0x00000001", value)
        with Documentation
           {Description = "A 32-bit, unsigned integer. The value representing the auto-reconnect version."};
  
    uint LogonId
        with Documentation
           {Description = "A 32-bit, unsigned integer. The session identifier for reconnection."};
  
    binary ArcRandomBits 
        with Documentation
           {Description = "byte buffer containing a 16-byte, random number generated as a key for secure reconnection (see section 5.5)."},
           BinaryEncoding{Length = 16};
}
with Documentation
       {Applicability = "2.2.4.2",
        Description = "The ARC_SC_PRIVATE_PACKET structure contains server-supplied information used to seamlessly re-establish a connection to a server after network interruption. It is sent as part of the Save Session Info PDU logon information (see section )."};

// 2.2.4.2   Server Auto-Reconnect Packet (ARC_SC_PRIVATE_PACKET)
pattern ArcSCPrivatePacketVersion = enum uint
{
    AutoReconnectVersion1 = 0x00000001
      with Documentation {Description = "Version 1 of auto-reconnect."},
    ...
} with Documentation {EmbeddedType = true};
  
// 2.2.4.3   Client Auto-Reconnect Packet (ARC_CS_PRIVATE_PACKET)
type ArcCSPrivatePacket
{
    uint CBLen where ValidationCheckValue(value == 0x0000001C, null, true, ReferenceType.Type, "RDPBCGR", "CBLen", "ArcCSPrivatePacket", 0x0000001C, value)
        with Documentation
           {Description = "A 32-bit, unsigned integer. The length in bytes of the Client Auto-Reconnect Packet. This field MUST be set to 0x0000001C (28 bytes)."};
  
    ArcCSPrivatePacketVersion Version where ValidationCheckValue(value == ArcCSPrivatePacketVersion.AutoReconnectVersion1 , null, false, ReferenceType.Type, "RDPBCGR", "Version", "ArcCSPrivatePacket", "0x00000001", value)
        with Documentation
           {Description = "A 32-bit, unsigned integer. The value representing the auto-reconnect version."};
  
    uint LogonId
        with Documentation
           {Description = "A 32-bit, unsigned integer. The session identifier for reconnection."};
  
    binary SecurityVerifier
        with Documentation
           {Description = "byte buffer containing a 16-byte verifier value derived using cryptographic methods (as specified in section ) from the ArcRandomBits field of the Server Auto-Reconnect Packet."},
           BinaryEncoding{Length = 16};
}
with Documentation
       {Applicability = "2.2.4.3",
        Description = "The ARC_CS_PRIVATE_PACKET structure contains the client response cookie used to seamlessly re-establish a connection to a server after network interruption. It is sent as part of the extended information of the Client Info PDU."};

// 2.2.4.3   Client Auto-Reconnect Packet (ARC_CS_PRIVATE_PACKET)
pattern ArcCSPrivatePacketVersion = enum uint
{
    AutoReconnectVersion1 = 0x00000001
      with Documentation {Description = "Version 1 of auto-reconnect."},
    ...   
} with Documentation {EmbeddedType = true};

// 2.2.5
// 2.2.5.1   Server Set Error Info PDU
message ServerSetErrorInfoPdu[TSUDSCSec1EncryptionLevel EncryptionLevel, TSUDSCSec1EncryptionMethod EncryptionMethod]
{
    optional (
              ([|EncryptionLevel == TSUDSCSec1EncryptionLevel.EncryptionLevelLow|] BasicSecurityHeader) |
              ([|EncryptionMethod in {TSUDSCSec1EncryptionMethod.EncryptionMethod40Bit,
                                      TSUDSCSec1EncryptionMethod.EncryptionMethod128Bit,
                                      TSUDSCSec1EncryptionMethod.EncryptionMethod56Bit}|] NonFipsSecurityHeader) |
              ([|(EncryptionMethod == TSUDSCSec1EncryptionMethod.EncryptionMethodFips)|] FipsSecurityHeader)
             ) SecurityHeader
        with Documentation
           {Description = "Optional security header. The presence and format of the security header depends on the Encryption Level and Encryption Method selected by the server (sections  and ). If the Encryption Level selected by the server is greater than ENCRYPTION_LEVEL_NONE (0) and the Encryption Method selected by the server is greater than ENCRYPTION_METHOD_NONE (0) then this field MUST contain one of the following headers:"};
  
    TSSetErrorInfoPdu ErrorInfoPduData
        with Documentation
           {Description = "The contents of the Set Error Info PDU, as specified in section ."};
           
    override string ToString()
    {
        return "Server Set Error Info PDU, ErrorInfo: " + EnumToString(ErrorInfoPduData.ErrorInfo, "RDPBCGR.TSSetErrorInfoPduErrorInfo");
    }
}
with Documentation
       {Applicability = "2.2.5.1",
        Description = "The Set Error Info PDU is sent by the server when there is a connection or disconnection failure. This PDU is only sent to clients which have indicated that they are capable of handling error reporting using the RNS_UD_CS_SUPPORT_ERRINFO_PDU flag in the Client Core Data."};

// 2.2.5.1.1   Set Error Info PDU Data (TS_SET_ERROR_INFO_PDU)
type TSSetErrorInfoPdu
{
    TSShareDataHeader ShareDataHeader
        with Documentation
           {Description = "Share Data Header containing information about the packet. The type subfield of the pduType field of the Share Control Header MUST be set to PDUTYPE_DATAPDU (7). The pduType2 field of the Share Data Header MUST be set to PDUTYPE2_SET_ERROR_INFO_PDU (47), and the pduSource field MUST be set to 0."};
  
    TSSetErrorInfoPduErrorInfo ErrorInfo where ValidationCheck(InRange<TSSetErrorInfoPduErrorInfo>(value), null, "RDPBCGR: The ErrorInfo field in type TSSetErrorInfoPdu is an undefined value. Please refer to Set Error Info PDU Data (TS_SET_ERROR_INFO_PDU) in Technical Document MS-RDPBCGR.")
        with Documentation {Description = "A 32-bit, unsigned integer. Error code."};
}
with Documentation
       {Applicability = "2.2.5.1.1",
        Description = "The TS_SET_ERROR_INFO_PDU structure contains the contents of the Set Error Info PDU, which is a Share Data Header with an error value field."};

// 2.2.5.1.1   Set Error Info PDU Data (TS_SET_ERROR_INFO_PDU)
pattern TSSetErrorInfoPduErrorInfo = enum uint
{
    ErrInfoNoError = 0x00000000,
    //Protocol-independent codes
    ErrInfoRpcInitiatedDisconnect = 0x00000001
      with Documentation
             {Description = "The disconnection was initiated by an administrative tool on the server in another session."},
    ErrInfoRpcInitiatedLogoff = 0x00000002
      with Documentation
             {Description = "The disconnection was due to a forced logoff initiated by an administrative tool on the server in another session."},
    ErrInfoIdleTimeout = 0x00000003
      with Documentation
             {Description = "The idle session limit timer on the server has elapsed."},
    ErrInfoLogonTimeout = 0x00000004
      with Documentation
             {Description = "The active session limit timer on the server has elapsed."},
    ErrInfoDisconnectedByOtherConnection = 0x00000005
      with Documentation
             {Description = "Another user connected to the server, forcing the disconnection of the current connection."},
    ErrInfoOutOfMemory = 0x00000006
      with Documentation
             {Description = "The server ran out of available memory resources."},
    ErrInfoServerDeniedConnection = 0x00000007
      with Documentation {Description = "The server denied the connection."},
    ErrInfoServerInsufficientPrivileges = 0x00000009
      with Documentation
             {Description = "The user cannot connect to the server due to insufficient access privileges."},
    ErrInfoServerFreshCredentialsRequired = 0x0000000A
      with Documentation
             {Description = "The server does not accept saved user credentials and requires that the user enter their credentials for each connection."},
    ErrInfoRpcInitiatedDisconnectByuser = 0x0000000B
      with Documentation
             {Description = "The disconnection was initiated by an administrative tool on the server running in the user\'s session."},
    ErrInfoLogoffByUser = 0x0000000C
      with Documentation
             {Description = "The disconnection was initiated by the user logging off his or her session on the server."},

    //Protocol-independent licensing codes
    ErrInfoLicenseInternal =  0x00000100
      with Documentation
             {Description = "An internal error has occurred in the Terminal Services licensing component."},
    ErrInfoLicenseNoLicenseServer =  0x00000101
      with Documentation
             {Description = "A Remote Desktop License Server ([MS-RDPELE] section 1.1) could not be found to provide a license."},
    ErrInfoLicenseNoLicense =  0x00000102
      with Documentation
             {Description = "There are no Client Access Licenses ([MS-RDPELE] section 1.1) available for the target remote computer."},
    ErrInfoLicenseBadClientMsg =  0x00000103
      with Documentation
             {Description = "The remote computer received an invalid licensing message from the client. "},
    ErrInfoLicenseHwidDoestMatchLicense =  0x00000104
      with Documentation
             {Description = "The Client Access License ([MS-RDPELE] section 1.1) stored by the client has been modified. "},
    ErrInfoLicenseBadClientLicense =  0x00000105
      with Documentation
             {Description = "The Client Access License ([MS-RDPELE] section 1.1) stored by the client is in an invalid format."},
    ErrInfoLicenseCantFinishProtocol =  0x00000106
      with Documentation
             {Description = "Network problems have caused the licensing protocol ([MS-RDPELE] section 1.3.3) to be terminated."},
    ErrInfoLicenseClientEndedPorotocol =  0x00000107
      with Documentation
             {Description = "The client prematurely ended the licensing protocol ([MS-RDPELE] section 1.3.3)."},
    ErrInfoLicenseBadClientEncryption =  0x00000108
      with Documentation
             {Description = "A licensing message ([MS-RDPELE] sections 2.2 and 5.1) was incorrectly encrypted."},
    ErrInfoLicenseCantUpgradeLicense =  0x00000109
      with Documentation
             {Description = "The Client Access License ([MS-RDPELE] section 1.1) stored by the client could not be upgraded or renewed."},
    ErrInfoLicenseNoRemoteConnections =  0x0000010A
      with Documentation
             {Description = "The remote computer is not licensed to accept remote connections."},

    //Protocol-independent codes generated by Connection Broker
    ErrInfoCBDestinationNotFound =  0x00000400
      with Documentation
             {Description = "The target endpoint could not be found."},                          
    ErrInfoCBLoadingDestination =  0x00000402
      with Documentation
             {Description = "The target endpoint to which the client is being redirected is disconnecting from the Connection Broker."}, 
    ErrInfoCBRedirectingToDesination =  0x00000404
      with Documentation
             {Description = "An error occurred while the connection was being redirected to the target endpoint."},
    ErrInfoCBSessionOnlineVMWake =  0x00000405
      with Documentation
             {Description = "An error occurred while the target endpoint (a virtual machine) was being awakened."},
    ErrInfoCBSessionOnlineVMBoot =  0x00000406
      with Documentation
             {Description = "An error occurred while the target endpoint (a virtual machine) was being started."},
    ErrInfoCBSessionOnlineVMNoDns =  0x00000407
      with Documentation
             {Description = "The IP address of the target endpoint (a virtual machine) cannot be determined."},
    ErrInfoCBDestinationPoolNotFree =  0x00000408
      with Documentation
             {Description = "There are no available endpoints in the pool managed by the Connection Broker."},
    ErrInfoCBConnectionCancelled =  0x00000409
      with Documentation
             {Description = "Processing of the connection has been cancelled."},
    ErrInfoCBConnectionErrorInvalidSetting =  0x00000410
      with Documentation
             {Description = "The settings contained in the routingToken field of the X.224 Connection Request PDU (section 2.2.1.1) cannot be validated."},
    ErrInfoCBSessionOnlineVMBootTimeout =  0x00000411
      with Documentation
             {Description = "A time-out occurred while the target endpoint (a virtual machine) was being started."},
    ErrInfoCBSessionOnlineVMSessionFailed =  0x00000412
      with Documentation
             {Description = "A session monitoring error occurred while the target endpoint (a virtual machine) was being started."},

    //RDP specific codes         
    ErrInfoUnknownPduType2 =  0x000010C9
      with Documentation
             {Description = "Unknown pduType2 field in a received Share Data Header (section 2.2.8.1.1.1.2)."},
    ErrInfoUnknownPduType =  0x000010CA
      with Documentation
             {Description = "Unknown pduType field in a received Share Control Header (section 2.2.8.1.1.1.1)."},                      
    ErrInfoDataPduSequence =  0x000010CB
      with Documentation
             {Description = "An out-of-sequence Slow-Path Data PDU (section 2.2.8.1.1.1.1) has been received."},
    ErrInfoControlPduSequence =  0x000010CD
      with Documentation
             {Description = "An out-of-sequence Slow-Path Non-Data PDU (section 2.2.8.1.1.1.1) has been received."},
    ErrInfoInvalidControlPduAction =  0x000010CE
      with Documentation
             {Description = "A Control PDU (sections 2.2.1.15 and 2.2.1.16) has been received with an invalid action field."},
    ErrInfoInvalidInputPduType =  0x000010CF
      with Documentation
             {Description = "One of two possible errors: A Slow-Path Input Event (section 2.2.8.1.1.3.1.1) has been received with an invalid messageType field or A Fast-Path Input Event (section 2.2.8.1.2.2) has been received with an invalid eventCode field."},
    ErrInfoInvalidInputPduMouse =  0x000010D0
      with Documentation
             {Description = "One of two possible errors: A Slow-Path Mouse Event (section 2.2.8.1.1.3.1.1.3) or Extended Mouse Event (section 2.2.8.1.1.3.1.1.4) has been received with an invalid pointerFlags field or A Fast-Path Mouse Event (section 2.2.8.1.2.2.3) or Fast-Path Extended Mouse Event (section 2.2.8.1.2.2.4) has been received with an invalid pointerFlags field."},
    ErrInfoInvalidRefreshRectPdu =  0x000010D1
      with Documentation
             {Description = "An invalid Refresh Rect PDU (section 2.2.11.2) has been received."},
    ErrInfoCreateUserDataFailed =  0x000010D2
      with Documentation
             {Description = "The server failed to construct the GCC Conference Create Response user data (section 2.2.1.4)."},
    ErrInfoConnectFailed =  0x000010D3
      with Documentation
             {Description = "Processing during the Channel Connection phase of the RDP Connection Sequence (see section 1.3.1.1 for an overview of the RDP Connection Sequence phases) has failed."},
    ErrInfoConfirmActiveWrongShareId =  0x000010D4
      with Documentation
             {Description = "A Confirm Active PDU (section 2.2.1.13.2) was received from the client with an invalid shareId field."},
    ErrInfoConfirmActiveWrongOriginator =  0x000010D5
      with Documentation
             {Description = "A Confirm Active PDU (section 2.2.1.13.2) was received from the client with an invalid originatorId field."},
    ErrInfoPersistentKeyPduBadLength =  0x000010DA
      with Documentation
             {Description = "There is not enough data to process a Persistent Key List PDU (section 2.2.1.17)."},
    ErrInfoPersistentKeyPduIllegalFirst =  0x000010DB
      with Documentation
             {Description = "A Persistent Key List PDU (section 2.2.1.17) marked as PERSIST_PDU_FIRST (0x01) was received after the reception of a prior Persistent Key List PDU also marked as PERSIST_PDU_FIRST."},
    ErrInfoTooManyTotalKeys =  0x000010DC
      with Documentation
             {Description = "A Persistent Key List PDU (section 2.2.1.17) was received which specified a total number of bitmap cache entries larger than 262144."},
    ErrInfoTooManyCacheKeys =  0x000010DD
      with Documentation
             {Description = "A Persistent Key List PDU (section 2.2.1.17) was received which specified an invalid total number of keys for a bitmap cache (the number of entries that can be stored within each bitmap cache is specified in the Revision 1 or 2 Bitmap Cache Capability Set (section 2.2.7.1.4) that is sent from client to server)."},
    ErrInfoInputPduBadLength =  0x000010DE
      with Documentation
             {Description = "There is not enough data to process Input Event PDU Data (section 2.2.8.1.1.3.1) or a Fast-Path Input Event PDU (section 2.2.8.1.2)."},
    ErrInfoBitmapCacheErrorPduBadLength =  0x000010DF
      with Documentation
             {Description = "There is not enough data to process the shareDataHeader, NumInfoBlocks, Pad1, and Pad2 fields of the Bitmap Cache Error PDU Data ([MS-RDPEGDI] section 2.2.2.3.1.1)."},
    ErrInfoSecurityDataTooShort =  0x000010E0
      with Documentation
             {Description = "One of two possible errors: The dataSignature field of the Fast-Path Input Event PDU (section 2.2.8.1.2) does not contain enough data or The fipsInformation and dataSignature fields of the Fast-Path Input Event PDU (section 2.2.8.1.2) do not contain enough data."},
    ErrInfoVChannelDataTooShort =  0x000010E1
      with Documentation
             {Description = "One of two possible errors: The dataSignature field of the Fast-Path Input Event PDU (section 2.2.8.1.2) does not contain enough data or The fipsInformation and dataSignature fields of the Fast-Path Input Event PDU (section 2.2.8.1.2) do not contain enough data."},
    ErrInfoShareDataTooShort =  0x000010E2
      with Documentation
             {Description = "One of four possible errors: There is not enough data to process Control PDU Data (section 2.2.1.15.1) or There is not enough data to read a complete Share Control Header (section 2.2.8.1.1.1.1) or There is not enough data to read a complete Share Data Header (section 2.2.8.1.1.1.2) of a Slow-Path Data PDU (section 2.2.8.1.1.1.1) or There is not enough data to process Font List PDU Data (section 2.2.1.18.1)."},
    ErrInfoBadSupressOutputPdu =  0x000010E3
      with Documentation
             {Description = "One of two possible errors: There is not enough data to process Suppress Output PDU Data (section 2.2.11.3.1) or The allowDisplayUpdates field of the Suppress Output PDU Data (section 2.2.11.3.1) is invalid."},
    ErrInfoConfirmActivePduTooShort =  0x000010E5
      with Documentation
             {Description = "One of two possible errors: There is not enough data to read the shareControlHeader, shareId, originatorId, lengthSourceDescriptor, and lengthCombinedCapabilities fields of the Confirm Active PDU Data (section 2.2.1.13.2.1) or There is not enough data to read the sourceDescriptor, numberCapabilities, pad2Octets, and capabilitySets fields of the Confirm Active PDU Data (section 2.2.1.13.2.1)."},
    ErrInfoCapbilitySetTooSmall =  0x000010E7
      with Documentation
             {Description = "There is not enough data to read the capabilitySetType and the lengthCapability fields in a received Capability Set (section 2.2.1.13.1.1.1)."},
    ErrInfoCapbilitySetTooLarge =  0x000010E8
      with Documentation
             {Description = "A Capability Set (section 2.2.1.13.1.1.1) has been received with a lengthCapability field that contains a value greater than the total length of the data received."},
    ErrInfoNocursorCache =  0x000010E9
      with Documentation
             {Description = "One of two possible errors: Both the colorPointerCacheSize and pointerCacheSize fields in the Pointer Capability Set (section 2.2.7.1.5) are set to zero or The pointerCacheSize field in the Pointer Capability Set (section 2.2.7.1.5) is not present, and the colorPointerCacheSize field is set to zero."},
    ErrInfoBadCapablities =  0x000010EA
      with Documentation
             {Description = "The capabilities received from the client in the Confirm Active PDU (section 2.2.1.13.2) were not accepted by the server."},
    ErrInfovirtualChannelDecompressionError =  0x000010EC
      with Documentation
             {Description = "An error occurred while using the bulk compressor (section 3.1.8 and [MS-RDPEGDI] section 3.1.8) to decompress a Virtual Channel PDU (section 2.2.6.1) "},
    ErrInfoInvalidDvcCompressionType =  0x000010ED
      with Documentation
             {Description = "An invalid bulk compression package was specified in the flags field of the Channel PDU Header (section 2.2.6.1.1)."},
    ErrInfoInvalidChannelId =  0x000010EF
      with Documentation
             {Description = "An invalid MCS channel ID was specified in the mcsPdu field of the Virtual Channel PDU (section 2.2.6.1)."},
    ErrInfoVChannelsTooMany =  0x000010F0
      with Documentation
             {Description = "The client requested more than the maximum allowed 31 static virtual channels in the Client Network Data (section 2.2.1.3.4)."},
    ErrInfoRemoteAppNotEnabled =  0x000010F3
      with Documentation
             {Description = "The INFO_RAIL flag (0x00008000) MUST be set in the flags field of the Info Packet (section 2.2.1.11.1.1) as the session on the remote server can only host remote applications."},
    ErrInfoCacheNotSet =  0x000010F4
      with Documentation
             {Description = "The client sent a Persistent Key List PDU (section 2.2.1.17) without including the prerequisite Revision 2 Bitmap Cache Capability Set (section 2.2.7.1.4.2) in the Confirm Active PDU (section 2.2.1.13.2)."},
    ErrInfoBitmapCacheErroPduBadLenght2 =  0x000010F5
      with Documentation
             {Description = "The NumInfoBlocks field in the Bitmap Cache Error PDU Data is inconsistent with the amount of data in the Info field ([MS-RDPEGDI] section 2.2.2.3.1.1)."},
    ErrInfoOffScreenErrorBadLength =  0x000010F6
      with Documentation
             {Description = "There is not enough data to process an Offscreen Bitmap Cache Error PDU ([MS-RDPEGDI] section 2.2.2.3.2)."},
    ErrInfoDngCacheErrorPduBadLenght =  0x000010F7
      with Documentation
             {Description = "There is not enough data to process a DrawNineGrid Cache Error PDU ([MS-RDPEGDI] section 2.2.2.3.3)."},
    ErrInfoGdiPlusPduBadLength =  0x000010F8
      with Documentation
             {Description = "There is not enough data to process a GDI+ Error PDU ([MS-RDPEGDI] section 2.2.2.3.4)."},
    ErrInfoSecurityDataTooShort2 =  0x00001111
      with Documentation
             {Description = "There is not enough data to read a Basic Security Header (section 2.2.8.1.1.2.1)."},
    ErrInfoSecurityDataTooShort3 =  0x00001112
      with Documentation
             {Description = "There is not enough data to read a Non-FIPS Security Header (section 2.2.8.1.1.2.2) or FIPS Security Header (section 2.2.8.1.1.2.3)."},
    ErrInfoSecurityDataTooShort4 =  0x00001113
      with Documentation
             {Description = "There is not enough data to read the basicSecurityHeader and length fields of the Security Exchange PDU Data (section 2.2.1.10.1)."},
    ErrInfoSecurityDataTooShort5 =  0x00001114
      with Documentation
             {Description = "There is not enough data to read the CodePage, flags, cbDomain, cbUserName, cbPassword, cbAlternateShell, cbWorkingDir, Domain, UserName, Password, AlternateShell, and WorkingDir fields in the Info Packet (section 2.2.1.11.1.1)."},
    ErrInfoSecurityDataTooShort6 =  0x00001115
      with Documentation
             {Description = "There is not enough data to read the CodePage, flags, cbDomain, cbUserName, cbPassword, cbAlternateShell, and cbWorkingDir fields in the Info Packet (section 2.2.1.11.1.1)."},
    ErrInfoSecurityDataTooShort7 =  0x00001116
      with Documentation
             {Description = "There is not enough data to read the clientAddressFamily and cbClientAddress fields in the Extended Info Packet (section 2.2.1.11.1.1.1)."},
    ErrInfoSecurityDataTooShort8 =  0x00001117
      with Documentation
             {Description = "There is not enough data to read the clientAddress field in the Extended Info Packet (section 2.2.1.11.1.1.1)."},
    ErrInfoSecurityDataTooShort9 =  0x00001118
      with Documentation
             {Description = "There is not enough data to read the cbClientDir field in the Extended Info Packet (section 2.2.1.11.1.1.1)."},
    ErrInfoSecurityDataTooShort10 =  0x00001119
      with Documentation
             {Description = "There is not enough data to read the clientDir field in the Extended Info Packet (section 2.2.1.11.1.1.1)."},
    ErrInfoSecurityDataTooShort11 =  0x0000111A
      with Documentation
             {Description = "There is not enough data to read the clientTimeZone field in the Extended Info Packet (section 2.2.1.11.1.1.1)."},
    ErrInfoSecurityDataTooShort12 =  0x0000111B
      with Documentation
             {Description = "There is not enough data to read the clientSessionId field in the Extended Info Packet (section 2.2.1.11.1.1.1)."},
    ErrInfoSecurityDataTooShort13 =  0x0000111C
      with Documentation
             {Description = "There is not enough data to read the performanceFlags field in the Extended Info Packet (section 2.2.1.11.1.1.1)."},
    ErrInfoSecurityDataTooShort14 =  0x0000111D
      with Documentation
             {Description = "There is not enough data to read the cbAutoReconnectCookie field in the Extended Info Packet (section 2.2.1.11.1.1.1)."},
    ErrInfoSecurityDataTooShort15 =  0x0000111E
      with Documentation
             {Description = "There is not enough data to read the autoReconnectCookie field in the Extended Info Packet (section 2.2.1.11.1.1.1)."},
    ErrInfoSecurityDataTooShort16 =  0x0000111F
      with Documentation
             {Description = "The cbAutoReconnectCookie field in the Extended Info Packet (section 2.2.1.11.1.1.1) contains a value which is larger than the maximum allowed length of 128 bytes."},
    ErrInfoSecurityDataTooShort17 =  0x00001120
      with Documentation
             {Description = "There is not enough data to read the clientAddressFamily and cbClientAddress fields in the Extended Info Packet (section 2.2.1.11.1.1.1)."},
    ErrInfoSecurityDataTooShort18 =  0x00001121
      with Documentation
             {Description = "There is not enough data to read the clientAddress field in the Extended Info Packet (section 2.2.1.11.1.1.1)."},
    ErrInfoSecurityDataTooShort19 =  0x00001122
      with Documentation
             {Description = "There is not enough data to read the cbClientDir field in the Extended Info Packet (section 2.2.1.11.1.1.1)."},
    ErrInfoSecurityDataTooShort20 =  0x00001123
      with Documentation
             {Description = "There is not enough data to read the clientDir field in the Extended Info Packet (section 2.2.1.11.1.1.1)."},
    ErrInfoSecurityDataTooShort21 =  0x00001124
      with Documentation
             {Description = "There is not enough data to read the clientTimeZone field in the Extended Info Packet (section 2.2.1.11.1.1.1)."},
    ErrInfoSecurityDataTooShort22 =  0x00001125
      with Documentation
             {Description = "There is not enough data to read the clientSessionId field in the Extended Info Packet (section 2.2.1.11.1.1.1)."},
    ErrInfoSecurityDataTooShort23 =  0x00001126
      with Documentation
             {Description = "There is not enough data to read the Client Info PDU Data (section 2.2.1.11.1)."},
    ErrInfoBadMonitorData =  0x00001129
      with Documentation
             {Description = "The monitorCount field in the Client Monitor Data (section 2.2.1.3.6) is invalid."},
    ErrInfoVcDecompressedReassembleFailed =  0x0000112A
      with Documentation
             {Description = "The server-side decompression buffer is invalid, or the size of the decompressed VC data exceeds the chunking size specified in the Virtual Channel Capability Set (section 2.2.7.1.10)."},
    ErrInfoVcDataTooLong =  0x0000112B
      with Documentation
             {Description = "The size of a received Virtual Channel PDU (section 2.2.6.1) exceeds the chunking size specified in the Virtual Channel Capability Set (section 2.2.7.1.10)."},
    ErrInfoBadFrameAckData =  0x0000112C
      with Documentation
             {Description = "There is not enough data to read a TS_FRAME_ACKNOWLEDGE_PDU ([MS-RDPRFX] section 2.2.3.1)."},
    ErrInfoGraphicModeNotSupported =  0x0000112D
      with Documentation
             {Description = "The graphics mode requested by the client is not supported by the server."},
    ErrInfoGraphicSubsystemResetFailed =  0x0000112E
      with Documentation
             {Description = "The server-side graphics subsystem failed to reset."},
    ErrInfoGraphicSubsystemFailed =  0x0000112F
      with Documentation
             {Description = "The server-side graphics subsystem is in an error state and unable to continue graphics encoding."},
    ErrInfoTimeZoneKeyNameLengthTooShort =  0x00001130
      with Documentation
             {Description = "There is not enough data to read the cbDynamicDSTTimeZoneKeyName field in the Extended Info Packet (section 2.2.1.11.1.1.1)."},
    ErrInfoTimeZoneKeyNameLengthTooLong =  0x00001131
      with Documentation
             {Description = "The length reported in the cbDynamicDSTTimeZoneKeyName field of the Extended Info Packet (section 2.2.1.11.1.1.1) is too long."},
    ErrInfoDynamicDstDiabledFieldMissing =  0x00001132
      with Documentation
             {Description = "The dynamicDaylightTimeDisabled field is not present in the Extended Info Packet (section 2.2.1.11.1.1.1)."},
    ErrInfoUpdateSessionKeyFailed =  0x00001191
      with Documentation
             {Description = "An attempt to update the session keys while using Standard RDP Security mechanisms (section 5.3.7) failed."},
    ErrInfoDecryptFailed =  0x00001192
      with Documentation
             {Description = "One of two possible error conditions: Decryption using Standard RDP Security mechanisms (section 5.3.6) failed or Session key creation using Standard RDP Security mechanisms (section 5.3.5) failed."},
    ErrInfoEncryptFailed =  0x00001193
      with Documentation
             {Description = "Encryption using Standard RDP Security mechanisms (section 5.3.6) failed."},
    ErrInfoEncpkgMismach =  0x00001194
      with Documentation
             {Description = "Failed to find a usable Encryption Method (section 5.3.2) in the encryptionMethods field of the Client Security Data (section 2.2.1.4.3)."},
    ErrInfoDecryptFailed2 =  0x00001195
      with Documentation
             {Description = "Unencrypted data was encountered in a protocol stream which is meant to be encrypted with Standard RDP Security mechanisms (section 5.3.6)."},
    ...
  } with Documentation {EmbeddedType = true};
        
// 2.2.5.2   Server Status Info PDU
pattern ServerStatusInfoPduStatusCode = enum uint
{
    TSStatusFindingDestination = 0x00000401
      with Documentation {Description = "The destination computer is being located."},
    TSStatusLoadingDestination = 0x00000402
      with Documentation
             {Description = "The destination computer is being prepared for use."},
    TSStatusBringingSessionOnline = 0x00000403
      with Documentation
             {Description = "The destination computer is being prepared to accept a remote connection."},
    TSStatusRedirectingToDestination = 0x00000404
      with Documentation
             {Description = "The client is being redirected to the destination computer."},
    TSStatusWMLoading = 0x00000501
      with Documentation
             {Description = "The destination virtual machine image is being loaded."},
    TSStatusWMWaking = 0x00000502
      with Documentation
             {Description = "The destination virtual machine is being resumed from sleep or hibernation."},
    TSStatusWMBooting = 0x00000503
      with Documentation
             {Description = "The destination virtual machine is being booted."}
} with Documentation {EmbeddedType = true};

// 2.2.5.2   Server Status Info PDU
message ServerStatusInfoPdu[TSUDSCSec1EncryptionLevel EncryptionLevel, TSUDSCSec1EncryptionMethod EncryptionMethod]
{
    optional (
              ([|EncryptionLevel == TSUDSCSec1EncryptionLevel.EncryptionLevelLow|] BasicSecurityHeader) |
              ([|EncryptionMethod in {TSUDSCSec1EncryptionMethod.EncryptionMethod40Bit,
                                      TSUDSCSec1EncryptionMethod.EncryptionMethod128Bit,
                                      TSUDSCSec1EncryptionMethod.EncryptionMethod56Bit}|] NonFipsSecurityHeader) |
              ([|(EncryptionMethod == TSUDSCSec1EncryptionMethod.EncryptionMethodFips)|] FipsSecurityHeader)
             ) SecurityHeader
        with Documentation
           {Description = "Optional security header. The presence and format of the security header depends on the Encryption Level and Encryption Method selected by the server (sections  and ). If the Encryption Level selected by the server is greater than ENCRYPTION_LEVEL_NONE (0) and the Encryption Method selected by the server is greater than ENCRYPTION_METHOD_NONE (0), then this field MUST contain one of the following headers:"};
  
    TSShareDataHeader ShareDataHeader
        with Documentation
           {Description = "A Share Data Header containing information about the packet. The type subfield of the pduType field of the Share Control Header MUST be set to PDUTYPE_DATAPDU (7). The pduType2 field of the Share Data Header MUST be set to PDUTYPE2_STATUS_INFO_PDU (54), and the pduSource field MUST be set to 0."};
  
    ServerStatusInfoPduStatusCode StatusCode
        with Documentation {Description = "A 32-bit, unsigned integer. Status code."};
        
    override string ToString()
    {
        return "Server Status Info PDU, StatusCode: " + EnumToString(StatusCode, "RDPBCGR.ServerStatusInfoPduStatusCode");
    }
}
with Documentation
       {Applicability = "2.2.5.2",
        Description = "The Status Info PDU is sent by the server to update the client with status information. This PDU is only sent to clients that have indicated that they are capable of status updates using the RNS_UD_CS_SUPPORT_STATUSINFO_PDU flag in the Client Core Data."};

// 2.2.6
// 2.2.6.1   Virtual Channel PDU
message VirtualChannelPdu[TSUDSCSec1EncryptionLevel EncryptionLevel, TSUDSCSec1EncryptionMethod EncryptionMethod]
{    
    optional (
              ([|EncryptionLevel == TSUDSCSec1EncryptionLevel.EncryptionLevelLow|] BasicSecurityHeader) |
              ([|EncryptionMethod in {TSUDSCSec1EncryptionMethod.EncryptionMethod40Bit,
                                      TSUDSCSec1EncryptionMethod.EncryptionMethod128Bit,
                                      TSUDSCSec1EncryptionMethod.EncryptionMethod56Bit}|] NonFipsSecurityHeader) |
              ([|(EncryptionMethod == TSUDSCSec1EncryptionMethod.EncryptionMethodFips)|] FipsSecurityHeader)
             ) SecurityHeader
       with Documentation
           {Description = "Optional security header. The presence and format of the security header depends on the Encryption Level and Encryption Method selected by the server (sections  and ). If the Encryption Level selected by the server is greater than ENCRYPTION_LEVEL_NONE (0) and the Encryption Method selected by the server is greater than ENCRYPTION_METHOD_NONE (0), then this field MUST contain one of the security headers described in section ."};
    
    ChannelPduHeader ChannelPduHeader
        with Documentation
           {Description = "A Channel PDU Header structure, which contains control flags and describes the size of the opaque channel data."};
  
    binary virtualChannelData
        with Documentation
           {Description = "Variable-length data to be processed by the static virtual channel protocol handler. This field MUST NOT be larger than CHANNEL_CHUNK_LENGTH (1600) bytes in size unless the maximum virtual channel chunk size is specified in the optional VCChunkSize field of the Virtual Channel Capability Set."};
    
    override string ToString()
    {
        string summary = "Virtual Channel PDU";
        if ((ChannelPduHeader.Flags & ChannelPduHeaderFlags.ChannelPacketCompressed) == ChannelPduHeaderFlags.ChannelPacketCompressed)
        {
            summary += ", Compressed";
        }
        return summary;
    }
}
with Documentation
       {Applicability = "2.2.6.1",
        Description = "The Virtual Channel PDU is sent from client to server or from server to client and is used to transport data between static virtual channel endpoints."};

// 2.2.6.1.1   Channel PDU Header (CHANNEL_PDU_HEADER)
type ChannelPduHeader
{
    uint Length
        with Documentation
           {Description = "A 32-bit, unsigned integer. The total length in bytes of the uncompressed channel data, excluding this header. The data can span multiple Virtual Channel PDUs and the individual chunks will need to be reassembled in that case."};
  
    ChannelPduHeaderFlags Flags
    with Documentation
           {Description = "A 32-bit, unsigned integer. The channel control flags."};
}
with Documentation
       {Applicability = "2.2.6.1.1",
        Description = "The CHANNEL_PDU_HEADER MUST precede all opaque static virtual channel traffic chunks transmitted via RDP between a client and server."};

// 2.2.6.1.1   Channel PDU Header (CHANNEL_PDU_HEADER)
pattern ChannelPduHeaderFlags = flags uint
{
    ChannelFlagFirst = 0x00000001
      with Documentation
             {Description = "Indicates that the chunk is the first in a sequence."},
    ChannelFlagLast = 0x00000002
      with Documentation
             {Description = "Indicates that the chunk is the last in a sequence."},
    ChannelFlagShowProtocol = 0x00000010
      with Documentation
             {Description = "The Channel PDU Header MUST be visible to the application endpoint (see section )."},
    ChannelFlagSuspend = 0x00000020
      with Documentation
             {Description = "All virtual channel traffic MUST be suspended. This flag is only valid in server-to-client virtual channel traffic. It MUST be ignored in client-to-server data."},
    ChannelFlagResume = 0x00000040
      with Documentation
             {Description = "All virtual channel traffic MUST be resumed. This flag is only valid in server-to-client virtual channel traffic. It MUST be ignored in client-to-server data."},
    ChannelPacketCompressed = 0x00200000
      with Documentation
             {Description = "The virtual channel data is compressed. This value is equivalent to MPPC bit C (for more information see [RFC2118] section 3.1)."},
    ChannelPacketAtFront = 0x00400000
      with Documentation
             {Description = "The decompressed packet MUST be placed at the beginning of the history buffer. This value is equivalent to MPPC bit B (for more information see [RFC2118] section 3.1)."},
    ChannelPacketFlushed = 0x00800000
      with Documentation
             {Description = "The history buffer MUST be reinitialized (by filling it with zeros). This value is equivalent to MPPC bit A (for more information see [RFC2118] section 3.1)."},
    CompressionTypeMask = 0x000F0000
      with Documentation
             {Description = "Indicates the compression package which was used to compress the data. See the discussion which follows this table for a list of compression packages."},
    Unused = 0xFF10FF8C
} with Documentation {EmbeddedType = true};

// patterns of section 2.2.7.1.1
pattern TSGeneralCapabilitySetOSMajorType = enum ushort
{
    OSMajorTypeUnspecified = 0x0000
      with Documentation {Description = "Unspecified platform"},
    OSMajorTypeWindows = 0x0001
      with Documentation {Description = "Windows platform"},
    OSMajorTypeOS2 = 0x0002 
        with Documentation {Description = "OS/2 platform"},
    OSMajorTypeMacintosh = 0x0003
      with Documentation {Description = "Macintosh platform"},
    OSMajorTypeUnix = 0x0004 with Documentation {Description = "UNIX platform"}
} with Documentation {EmbeddedType = true};

pattern TSGeneralCapabilitySetOSMinorType = enum ushort
{
    OSMinorTypeUnspecified = 0x0000
      with Documentation {Description = "Unspecified version"},
    OSMinorTypeWindows31x = 0x0001
      with Documentation {Description = "Windows 3.1x"},
    TSOSMinorTypeWindows95 = 0x0002
      with Documentation {Description = "Windows 95"},
    TSOSMinorTypeWindowsNT = 0x0003
      with Documentation {Description = "Windows NT"},
    TSOSMinorTypeOS2V21 = 0x0004
      with Documentation {Description = "OS/2 2.1"},
    TSOSMinorTypePowerPC = 0x0005
      with Documentation {Description = "PowerPC"},
    TSOSMinorTypeMacintosh = 0x0006
      with Documentation {Description = "Macintosh"},
    TSOSMinorTypeNativeXserver = 0x0007
      with Documentation {Description = "Native X Server"},
    TSOSMinorTypePseudoXserver = 0x0008
      with Documentation {Description = "Pseudo X Server"}
} with Documentation {EmbeddedType = true};

pattern TSGeneralCapabilitySetExtraFlags = flags ushort
{
    FastpathOutputSupported = 0x0001
        with Documentation {Description = "Advertiser supports fast-path output."},
    NoBitmapCompressionHDR = 0x0400
        with Documentation
             {Description = "Advertiser supports excluding the 8-byte Compressed Data Header from the Bitmap Data structure or the Cache Bitmap (Revision 2) Secondary Drawing Order ([MS-RDPEGDI] section )."},
    LongCredentialsSupported = 0x0004
        with Documentation
             {Description = "Advertiser supports long-length credentials for the user name, password, or domain name in the Save Session Info PDU (section 2.2.10.1)."},
    AutoreconnectSupported = 0x0008
        with Documentation
             {Description = "Advertiser supports auto-reconnection (section 5.5)."},
    EncSaltedChecksum = 0x0010
        with Documentation
             {Description = "Advertiser supports salted MAC generation (see section 5.3.6.1.1)."}
} with Documentation {EmbeddedType = true};

pattern TSGeneralCapabilitySetRefreshRectSupport = enum byte
{
    FALSE = 0x00
      with Documentation {Description = "Server does not support Refresh Rect PDU."},
    TRUE = 0x01
      with Documentation {Description = "Server supports Refresh Rect PDU."}
} with Documentation {EmbeddedType = true};

pattern TSGeneralCapabilitySetSuppressOutputSupport = enum byte
{
    FALSE = 0x00
      with Documentation {Description = "Server does not support Suppress Output PDU."},
    TRUE = 0x01
      with Documentation {Description = "Server supports Suppress Output PDU."}
} with Documentation {EmbeddedType = true};

// 2.2.7.1.1   General Capability Set (TS_GENERAL_CAPABILITYSET)

type TSGeneralCapabilitySet
{
    ushort CapabilitySetType where value == 0x0001
        with Documentation
           {Description = "A 16-bit, unsigned integer. The type of the capability set. This field MUST be set to CAPSTYPE_GENERAL (1)."};

    ushort LengthCapability
        with Documentation
           {Description = "A 16-bit, unsigned integer. The length in bytes of the capability data, including the size of the capabilitySetType and lengthCapability fields."};

    TSGeneralCapabilitySetOSMajorType OsMajorType
        with Documentation
           {Description = "A 16-bit, unsigned integer. The type of platform."};

    TSGeneralCapabilitySetOSMinorType OsMinorType
        with Documentation
           {Description = "A 16-bit, unsigned integer. The version of the platform specified in the osMajorType field."};

    ushort ProtocolVersion where value == 0x0200
        with Documentation
           {Description = "A 16-bit, unsigned integer. The protocol version. This field MUST be set to TS_CAPS_PROTOCOLVERSION (0x0200)."};

    ushort Pad2OctetsA
        with Documentation
           {Description = "A 16-bit, unsigned integer. Padding. Values in this field MUST be ignored."};

    ushort GeneralCompressionTypes where value == 0x0000
        with Documentation
           {Description = "A 16-bit, unsigned integer. General compression types. This field MUST be set to 0."};

    TSGeneralCapabilitySetExtraFlags ExtraFlags
        with Documentation
           {Description = "A 16-bit, unsigned integer. General capability information."};

    ushort UpdateCapabilityFlag where value == 0x0000
        with Documentation
           {Description = "A 16-bit, unsigned integer. Support for update capability. This field MUST be set to 0."};

    ushort RemoteUnshareFlag where value == 0x0000
        with Documentation
           {Description = "A 16-bit, unsigned integer. Support for remote unsharing. This field MUST be set to 0."};

    ushort GeneralCompressionLevel where value == 0x0000
        with Documentation
           {Description = "A 16-bit, unsigned integer. General compression level. This field MUST be set to 0."};

    TSGeneralCapabilitySetRefreshRectSupport RefreshRectSupport
        with Documentation
           {Description = "An 8-bit, unsigned integer. Server-only flag that indicates whether the Refresh Rect PDU is supported."};

    TSGeneralCapabilitySetSuppressOutputSupport SuppressOutputSupport
        with Documentation
           {Description = "An 8-bit, unsigned integer. Server-only flag that indicates whether the Suppress Output PDU is supported."};
}
with Documentation
       {Applicability = "2.2.7.1.1",
        Description = "The TS_GENERAL_CAPABILITYSET structure is used to advertise general characteristics and is based on the capability set specified in [T128] section 8.2.3. This capability is sent by both client and server."};


// patterns of section 2.2.7.1.2
pattern TSBitmapCapabilitySetDesktopResizeFlag = enum ushort
{
    FALSE = 0x0000
      with Documentation {Description = "Desktop resizing is not supported."},
    TRUE = 0x0001
      with Documentation {Description = "Desktop resizing is supported."}
} with Documentation {EmbeddedType = true};

pattern TSBitmapCapabilitySetDrawingFlags = flags byte
{
    DrawAllowDynamicColorFidelity = 0x02
      with Documentation
             {Description = "Indicates support for lossy compression of 32 bpp bitmaps by reducing color-fidelity on a per-pixel basis ([MS-RDPEGDI] section )."},
    DrawAllowColorSubsampling = 0x04
      with Documentation
             {Description = "Indicates support for chroma subsampling when compressing 32 bpp bitmaps ([MS-RDPEGDI] section )."},
    DrawAllowSkipAlpha = 0x08
      with Documentation
             {Description = "Indicates that the client supports the removal of the alpha-channel when compressing 32 bpp bitmaps. In this case the alpha is assumed to be 0xFF, meaning the bitmap is opaque."},
    DrawUnusedFlag = 0x10
      with Documentation
             {Description = "An unused flag that MUST be ignored by the client if it is present in the server-to-client Bitmap Capability Set."},
    ...         
} with Documentation {EmbeddedType = true};

// 2.2.7.1.2   Bitmap Capability Set (TS_BITMAP_CAPABILITYSET)

type TSBitmapCapabilitySet
{
    ushort CapabilitySetType where value == 2
        with Documentation
           {Description = "A 16-bit, unsigned integer. The type of the capability set. This field MUST be set to CAPSTYPE_BITMAP (2)."};

    ushort LengthCapability
        with Documentation
           {Description = "A 16-bit, unsigned integer. The length in bytes of the capability data, including the size of the capabilitySetType and lengthCapability fields."};

    ushort PreferredBitsPerPixel
        with Documentation
           {Description = "A 16-bit, unsigned integer. The server MUST set this field to the color depth of the session, while the client SHOULD set this field to the color depth requested in the Client Core Data."};

    ushort Receive1BitPerPixel
        with Documentation
           {Description = "A 16-bit, unsigned integer. Indicates whether the client can receive 1 bpp. This field is ignored and SHOULD be set to TRUE (0x0001)."};

    ushort Receive4BitsPerPixel
        with Documentation
           {Description = "A 16-bit, unsigned integer. Indicates whether the client can receive 4 bpp. This field is ignored and SHOULD be set to TRUE (0x0001)."};

    ushort Receive8BitsPerPixel
        with Documentation
           {Description = "A 16-bit, unsigned integer. Indicates whether the client can receive 8 bpp. This field is ignored and SHOULD be set to TRUE (0x0001)."};

    ushort DesktopWidth
        with Documentation
           {Description = "A 16-bit, unsigned integer. The width of the desktop in the session."};

    ushort DesktopHeight
        with Documentation
           {Description = "A 16-bit, unsigned integer. The height of the desktop in the session."};

    ushort Pad2Octets
        with Documentation
           {Description = "A 16-bit, unsigned integer. Padding. Values in this field MUST be ignored."};

    TSBitmapCapabilitySetDesktopResizeFlag DesktopResizeFlag
        with Documentation
           {Description = "A 16-bit, unsigned integer. Indicates whether resizing the desktop by using a Deactivation-Reactivation Sequence is supported (see section  for an overview of the Deactivation-Reactivation Sequence)."};

    ushort BitmapCompressionFlag
        with Documentation
           {Description = "A 16-bit, unsigned integer. Indicates whether bitmap compression is supported. This field MUST be set to TRUE (0x0001) because support for compressed bitmaps is required for a connection to proceed."};

    byte HighColorFlags
        with Documentation
           {Description = "An 8-bit, unsigned integer. Client support for 16 bpp color modes. This field is ignored and SHOULD be set to 0."};

    TSBitmapCapabilitySetDrawingFlags DrawingFlags where ValidationCheckCombinationValueIncludeZero(InRange<TSBitmapCapabilitySetDrawingFlags>(value), null, false, ReferenceType.Type, "RDPBCGR", "DrawingFlags", "TSBitmapCapabilitySet", "0x02, 0x04, 0x08, 0x10", value)
        with Documentation
           {Description = "An 8-bit, unsigned integer. Flags describing support for 32 bpp bitmaps."};

    ushort MultipleRectangleSupport where ValidationCheckValue(value == 0x0001, null, true, ReferenceType.Type, "RDPBCGR", "MultipleRectangleSupport", "TSBitmapCapabilitySet", "0x0001", value)
        with Documentation
           {Description = "A 16-bit, unsigned integer. Indicates whether the use of multiple bitmap rectangles is supported in the Bitmap Update. This field MUST be set to TRUE (0x0001) because multiple rectangle support is required for a connection to proceed."};

    ushort Pad2OctetsB
        with Documentation
           {Description = "A 16-bit, unsigned integer. Padding. Values in this field MUST be ignored."};
}
with Documentation
       {Applicability = "2.2.7.1.2",
        Description = "The TS_BITMAP_CAPABILITYSET structure is used to advertise bitmap-orientated characteristics and is based on the capability set specified in [T128] section 8.2.4. This capability is sent by both client and server."};


// patterns of section 2.2.7.1.3
pattern TSOrderCapabilitySetOrderFlags = flags ushort
  {
    NegotiateOrderSupport = 0x0002
      with Documentation
             {Description = "Indicates support for specifying supported drawing orders in the orderSupport field. This flag MUST be set."},
    ZeroBoundsDeltasSupport = 0x0008
      with Documentation
             {Description = "Indicates support for the TS_ZERO_BOUNDS_DELTAS (0x20) flag (see [MS-RDPEGDI] section ). The client MUST set this flag."},
    ColorRindexSupport = 0x0020
      with Documentation
             {Description = "Indicates support for sending color indices (not RGB values) in orders."},
    SolidPatternBrushonly = 0x0040
      with Documentation
             {Description = "Indicates that this party can receive only solid and pattern brushes."},
    OrderflagsExtraFlags = 0x0080
      with Documentation
             {Description = "Indicates that the orderSupportExFlags field contains valid data."}
  } with Documentation {EmbeddedType = true};

type TSOrderCapabilitySetOrderSupport
{
    byte SupportDstBlt
      with Documentation
             {Description = "DstBlt Primary Drawing Order (see [MS-RDPEGDI] section )."};
    byte SupportPatBlt
      with Documentation
             {Description = "PatBlt Primary Drawing Order (see [MS-RDPEGDI] section ) and OpaqueRect Primary Drawing Order (see [MS-RDPEGDI] section )."};
    byte SupportScrBlt
      with Documentation
             {Description = "ScrBlt Primary Drawing Order (see [MS-RDPEGDI] section )."};
    byte SupportMemBlt
      with Documentation
             {Description = "MemBlt Primary Drawing Order (see [MS-RDPEGDI] section )."};
    byte SupportMem3Blt 
      with Documentation
             {Description = "Mem3Blt Primary Drawing Order (see [MS-RDPEGDI] section )."};
    byte Unused1
      with Documentation
             {Description = "The contents of the byte at this index MUST be ignored."};
    byte Unused2
      with Documentation
             {Description = "The contents of the byte at this index MUST be ignored."};
    byte SupportDrawNineGrid
      with Documentation
             {Description = "DrawNineGrid Primary Drawing Order (see [MS-RDPEGDI] section )."};
    byte SupportLineTo
      with Documentation
             {Description = "LineTo Primary Drawing Order (see [MS-RDPEGDI] section )."};
    byte SupportMultiDrawNineGrid
      with Documentation
             {Description = "MultiDrawNineGrid Primary Drawing Order (see [MS-RDPEGDI] section )."};
    byte Unused3
      with Documentation
             {Description = "The contents of the byte at this index MUST be ignored."};
    byte SupportSaveBitmap
      with Documentation
             {Description = "SaveBitmap Primary Drawing Order (see [MS-RDPEGDI] section )."};
    byte Unused4
      with Documentation
             {Description = "The contents of the byte at this index MUST be ignored."};
    byte Unused5
      with Documentation
             {Description = "The contents of the byte at this index MUST be ignored."};
    byte Unused6
      with Documentation
             {Description = "The contents of the byte at this index MUST be ignored."};
    byte SupportMultiDstBlt
      with Documentation
             {Description = "MultiDstBlt Primary Drawing Order (see [MS-RDPEGDI] section )."};
    byte SupportMultiPatBlt
      with Documentation
             {Description = "MultiPatBlt Primary Drawing Order (see [MS-RDPEGDI] section )."};
    byte SupportMultiScrBlt
      with Documentation
             {Description = "MultiScrBlt Primary Drawing Order (see [MS-RDPEGDI] section )."};
    byte SupportMultiOpaqueRect
      with Documentation
             {Description = "MultiOpaqueRect Primary Drawing Order (see [MS-RDPEGDI] section )."};
    byte SupportFastIndex
      with Documentation
             {Description = "FastIndex Primary Drawing Order (see [MS-RDPEGDI] section )."};
    byte SupportPolygonSC
      with Documentation
             {Description = "PolygonSC Primary Drawing Order (see [MS-RDPEGDI] section ) and PolygonCB Primary Drawing Order (see [MS-RDPEGDI] section )."};
    byte SupportPolygonCB
      with Documentation
             {Description = "PolygonCB Primary Drawing Order (see [MS-RDPEGDI] section ) and PolygonSC Primary Drawing Order (see [MS-RDPEGDI] section )."};
    byte SupportPolyline
      with Documentation
             {Description = "Polyline Primary Drawing Order (see [MS-RDPEGDI] section )."};
    byte Unused7
      with Documentation
             {Description = "The contents of the byte at this index MUST be ignored."};
    byte SupportFastGlyph
      with Documentation
             {Description = "FastGlyph Primary Drawing Order (see [MS-RDPEGDI] section )."};
    byte SupportEllipseSC
      with Documentation
             {Description = "EllipseSC Primary Drawing Order (see [MS-RDPEGDI] section ) and EllipseCB Primary Drawing Order (see [MS-RDPEGDI] section )."};
    byte SupportEllipseCB
      with Documentation
             {Description = "EllipseCB Primary Drawing Order (see [MS-RDPEGDI] section ) and EllipseSC Primary Drawing Order (see [MS-RDPEGDI] section )."};
    byte SupportGlyphIndex
      with Documentation
             {Description = "GlyphIndex Primary Drawing Order (see [MS-RDPEGDI] section )."};
    byte Unused8
      with Documentation
             {Description = "The contents of the byte at this index MUST be ignored."};
    byte Unused9
      with Documentation
             {Description = "The contents of the byte at this index MUST be ignored."};
    byte Unused10
      with Documentation
             {Description = "The contents of the byte at this index MUST be ignored."};
    byte Unused11
      with Documentation
             {Description = "The contents of the byte at this index MUST be ignored."};
} with Documentation {EmbeddedType = true};

pattern TSOrderCapabilitySetOrderSupportExFlags = flags ushort
{
    OrderflagsExCacheBitmapRe3Support = 0x0002
        with Documentation
             {Description = "The Cache Bitmap (Revision 3) Secondary Drawing Order ([MS-RDPEGDI] section ) is supported."},
    OrderflagsExAltsecFrameMarkerSupport = 0x0004
        with Documentation
             {Description = "The Frame Marker Alternate Secondary Drawing Order ([MS-RDPEGDI] section ) is supported."}
} with Documentation {EmbeddedType = true};

// 2.2.7.1.3   Order Capability Set (TS_ORDER_CAPABILITYSET)

type TSOrderCapabilitySet
{
    ushort CapabilitySetType where value == 3
        with Documentation
           {Description = "A 16-bit, unsigned integer. The type of the capability set. This field MUST be set to CAPSTYPE_ORDER (3)."};

    ushort LengthCapability
        with Documentation
           {Description = "A 16-bit, unsigned integer. The length in bytes of the capability data, including the size of the capabilitySetType and lengthCapability fields."};

    array<byte> terminalDescriptor with BinaryEncoding{Length = 16}
        with Documentation
           {Description = "A 16-element array of 8-bit, unsigned integers. Terminal descriptor. This field is ignored and SHOULD be set to all zeros."};

    uint Pad4OctetsA
        with Documentation
           {Description = "A 32-bit, unsigned integer. Padding. Values in this field MUST be ignored."};

    ushort DesktopSaveXGranularity
        with Documentation
           {Description = "A 16-bit, unsigned integer. X granularity used in conjunction with the SaveBitmap Primary Drawing Order (see [MS-RDPEGDI] section ). This value is ignored and assumed to be 1."};

    ushort DesktopSaveYGranularity
        with Documentation
           {Description = "A 16-bit, unsigned integer. Y granularity used in conjunction with the SaveBitmap Primary Drawing Order (see [MS-RDPEGDI] section ). This value is ignored and assumed to be 20."};

    ushort Pad2OctetsA
        with Documentation
           {Description = "A 16-bit, unsigned integer. Padding. Values in this field MUST be ignored."};

    ushort MaximumOrderLevel
        with Documentation
           {Description = "A 16-bit, unsigned integer. Maximum order level. This value is ignored and SHOULD be set to ORD_LEVEL_1_ORDERS (1)."};

    ushort NumberFonts
        with Documentation
           {Description = "A 16-bit, unsigned integer. Number of fonts. This value is ignored and SHOULD be set to 0."};

    TSOrderCapabilitySetOrderFlags OrderFlags
        with Documentation
           {Description = "A 16-bit, unsigned integer. A 16-bit unsigned integer. Support for drawing order options."};

    TSOrderCapabilitySetOrderSupport OrderSupport
        with Documentation
           {Description = "An array of 32 bytes indicating support for various primary drawing orders. The indices of this array are the negotiation indices for the primary orders specified in [MS-RDPEGDI] section ."};

    ushort TextFlags
        with Documentation
           {Description = "A 16-bit, unsigned integer. Values in this field MUST be ignored."};

    TSOrderCapabilitySetOrderSupportExFlags OrderSupportExFlags
        with Documentation
           {Description = "A 16-bit, unsigned integer. Extended order support flags."};

    uint Pad4octetsB
        with Documentation
           {Description = "A 32-bit, unsigned integer. Padding. Values in this field MUST be ignored."};

    uint DesktopSaveSize
        with Documentation
           {Description = "A 32-bit, unsigned integer. The maximum usable size of bitmap space for bitmap packing in the SaveBitmap Primary Drawing Order (see [MS-RDPEGDI] section ). This field is ignored by the client and assumed to be 230400 bytes (480 * 480)."};
  
    ushort Pad2octetsC
        with Documentation
           {Description = "A 16-bit, unsigned integer. Padding. Values in this field MUST be ignored."};
  
    ushort Pad2octetsD
        with Documentation
           {Description = "A 16-bit, unsigned integer. Padding. Values in this field MUST be ignored."};
  
    ushort TextANSICodePage
        with Documentation
           {Description = "A 16-bit, unsigned integer. ANSI code page descriptor being used by the client (for a list of code pages, see [MSDN-CP]). This field is ignored by the client and SHOULD be set to 0 by the server."};
  
    ushort Pad2octetsE
        with Documentation
           {Description = "A 16-bit, unsigned integer. Padding. Values in this field MUST be ignored."};
}
with Documentation
       {Applicability = "2.2.7.1.3",
        Description = "The TS_ORDER_CAPABILITYSET structure advertises support for primary drawing order-related capabilities and is based on the capability set specified in [T128] section 8.2.5 (for more information about primary drawing orders, see [MS-RDPEGDI] section ). This capability is sent by both client and server."};

// 2.2.7.1.4   Bitmap Cache Capability Set
// 2.2.7.1.4.1   Revision 1 (TS_BITMAPCACHE_CAPABILITYSET)

type TSBitmapCacheCapaibilitySet
{
    ushort CapabilitySetType where value == 4
        with Documentation
           {Description = "A 16-bit, unsigned integer. The type of the capability set. This field MUST be set to CAPSTYPE_BITMAPCACHE (4)."};

    ushort LengthCapability
        with Documentation
           {Description = "A 16-bit, unsigned integer. The length in bytes of the capability data, including the size of the capabilitySetType and lengthCapability fields."};
  
    uint Pad1
        with Documentation
           {Description = "A 32-bit, unsigned integer. Padding. Values in this field MUST be ignored."};
  
    uint Pad2
        with Documentation
           {Description = "A 32-bit, unsigned integer. Padding. Values in this field MUST be ignored."};
  
    uint  Pad3
        with Documentation
           {Description = "A 32-bit, unsigned integer. Padding. Values in this field MUST be ignored."};
  
    uint Pad4
        with Documentation
           {Description = "A 32-bit, unsigned integer. Padding. Values in this field MUST be ignored."};
  
    uint Pad5
        with Documentation
           {Description = "A 32-bit, unsigned integer. Padding. Values in this field MUST be ignored."};
  
    uint Pad6
        with Documentation
           {Description = "A 32-bit, unsigned integer. Padding. Values in this field MUST be ignored."};
  
    ushort Cache0Entries where ValidationCheckLessThanOrEqualTo(value <= 200, null, false, ReferenceType.Type, "RDPBCGR", "Cache0Entries", "TSBitmapCacheCapaibilitySet", 200, value)
        with Documentation
           {Description = "A 16-bit, unsigned integer. The number of entries in Bitmap Cache 0 (maximum allowed value is 200 entries)."};
  
    ushort Cache0MaximumCellSize
        with Documentation
           {Description = "A 16-bit, unsigned integer. The maximum cell size in Bitmap Cache 0."};
  
    ushort Cache1Entries where ValidationCheckLessThanOrEqualTo(value <= 600, null, false, ReferenceType.Type, "RDPBCGR", "Cache1Entries", "TSBitmapCacheCapaibilitySet", 600, value)
        with Documentation
           {Description = "A 16-bit, unsigned integer. The number of entries in Bitmap Cache 1 (maximum allowed value is 600 entries)."};
  
    ushort Cache1MaximumCellSize
        with Documentation
           {Description = "A 16-bit, unsigned integer. The maximum cell size in Bitmap Cache 1."};
  
    ushort Cache2Entries where ValidationCheckLessThanOrEqualTo(value <= 65535, null, false, ReferenceType.Type, "RDPBCGR", "Cache1Entries", "TSBitmapCacheCapaibilitySet", 65535, value)
        with Documentation
           {Description = "A 16-bit, unsigned integer. The number of entries in Bitmap Cache 2 (maximum allowed value is 65535 entries)."};
  
    ushort Cache2MaximumCellSize
        with Documentation
           {Description = "A 16-bit, unsigned integer. The maximum cell size in Bitmap Cache 2."};
}
with Documentation
       {Applicability = "2.2.7.1.4.1",
        Description = "The TS_BITMAPCACHE_CAPABILITYSET structure is used to advertise support for Revision 1 bitmap caches (see [MS-RDPEGDI] section ). This capability is only sent from client to server."};

// pattern of section 2.2.7.1.4.2
pattern TSBitmapCacheCapabilitySetRev2CacheFlags = flags ushort
{
    PersistentKeysExpectedFlag = 0x0001
      with Documentation
             {Description = "Indicates that the client will send a Persistent Key List PDU during the Connection Finalization phase of the RDP Connection Sequence (see section  for an overview of the RDP Connection Sequence phases)."},
    AllowCacheWaitingListFlag = 0x0002
      with Documentation
             {Description = "Indicates that the client supports a cache waiting list. If a waiting list is supported, new bitmaps are cached on the second hit rather than the first (that is, a bitmap is sent twice before it is cached)."},
    ...
} with Documentation {EmbeddedType = true}; 

// 2.2.7.1.4.2   Revision 2 (TS_BITMAPCACHE_CAPABILITYSET_REV2)

type TSBitmapCacheCapabilitySetRev2
{
    ushort CapabilitySetType where value == 19
        with Documentation
           {Description = "A 16-bit, unsigned integer. The type of the capability set. This field MUST be set to CAPSTYPE_BITMAPCACHE_REV2 (19)."};

    ushort LengthCapability
        with Documentation
           {Description = "A 16-bit, unsigned integer. The length in bytes of the capability data, including the size of the capabilitySetType and lengthCapability fields."};

    TSBitmapCacheCapabilitySetRev2CacheFlags CacheFlags where ValidationCheckCombinationValueIncludeZero(InRange<TSBitmapCacheCapabilitySetRev2CacheFlags>(CacheFlags), null, false, ReferenceType.Type, "RDPBCGR", "CacheFlags", "TSBitmapCacheCapabilitySetRev2", "0x0001, 0x0002", value)
        with Documentation
           {Description = "A 16-bit, unsigned integer. Properties which apply to all the bitmap caches."};

    byte Pad2
        with Documentation
           {Description = "An 8-bit, unsigned integer. Padding. Values in this field MUST be ignored."};

    byte NumCellCaches where ValidationCheckLessThanOrEqualTo(value <= 5, null, true, ReferenceType.Type, "RDPBCGR", "NumCellCaches", "TSBitmapCacheCapabilitySetRev2", 5, value)
        with Documentation
           {Description = "An 8-bit, unsigned integer. Number of bitmap caches (with a maximum allowed value of 5)."};

    TSBitmapCacheCellCacheInfo BitmapCache0CellInfo where ValidationCheckLessThanOrEqualTo(value.NumEntries <= 600, null, false, ReferenceType.Type, "RDPBCGR", "BitmapCache0CellInfo", "TSBitmapCacheCapabilitySetRev2", 600, value.NumEntries)
        with Documentation
           {Description = "A TS_BITMAPCACHE_CELL_CACHE_INFO structure. Contains information about the structure of Bitmap Cache 0. The maximum number of entries allowed in this cache is 600. This field is only valid if NumCellCaches is greater than or equal to 1."};

    TSBitmapCacheCellCacheInfo BitmapCache1CellInfo where ValidationCheckLessThanOrEqualTo(value.NumEntries <= 600, null, false, ReferenceType.Type, "RDPBCGR", "BitmapCache1CellInfo", "TSBitmapCacheCapabilitySetRev2", 600, value.NumEntries)
        with Documentation
           {Description = "A TS_BITMAPCACHE_CELL_CACHE_INFO structure. Contains information about the structure of Bitmap Cache 1. The maximum number of entries allowed in this cache is 600. This field is only valid if NumCellCaches is greater than or equal to 2."};

    TSBitmapCacheCellCacheInfo BitmapCache2CellInfo where ValidationCheckLessThanOrEqualTo(value.NumEntries <= 65536, null, false, ReferenceType.Type, "RDPBCGR", "BitmapCache2CellInfo", "TSBitmapCacheCapabilitySetRev2", 65536, value.NumEntries)
        with Documentation
           {Description = "A TS_BITMAPCACHE_CELL_CACHE_INFO structure. Contains information about the structure of Bitmap Cache 2. The maximum number of entries allowed in this cache is 65536. This field is only valid if NumCellCaches is greater than or equal to 3."};

    TSBitmapCacheCellCacheInfo BitmapCache3CellInfo where ValidationCheckLessThanOrEqualTo(value.NumEntries <= 4096, null, false, ReferenceType.Type, "RDPBCGR", "BitmapCache3CellInfo", "TSBitmapCacheCapabilitySetRev2", 4096, value.NumEntries)
        with Documentation
           {Description = "A TS_BITMAPCACHE_CELL_CACHE_INFO structure. Contains information about the structure of Bitmap Cache 3. The maximum number of entries allowed in this cache is 4096. This field is only valid if NumCellCaches is greater than or equal to 4."};
  
    TSBitmapCacheCellCacheInfo BitmapCache4CellInfo where ValidationCheckLessThanOrEqualTo(value.NumEntries <= 2048, null, false, ReferenceType.Type, "RDPBCGR", "BitmapCache4CellInfo", "TSBitmapCacheCapabilitySetRev2", 2048, value.NumEntries)
        with Documentation
           {Description = "A TS_BITMAPCACHE_CELL_CACHE_INFO structure. Contains information about the structure of Bitmap Cache 4. The maximum number of entries allowed in this cache is 2048. This field is only valid if NumCellCaches is equal to 5."};
  
    array<byte> Pad3 with BinaryEncoding{Length = 12}
        with Documentation
           {Description = "A 12-element array of 8-bit, unsigned integers. Padding. Values in this field MUST be ignored."};
}with Documentation
       {Applicability = "2.2.7.1.4.2",
        Description = "The TS_BITMAPCACHE_CAPABILITYSET_REV2 structure is used to advertise support for Revision 2 bitmap caches (see [MS-RDPEGDI] section ). This capability is only sent from client to server."};

type TSBitmapCacheCellCacheInfo
{
    byte K with BinaryEncoding {Width = 1};
    uint NumEntries with BinaryEncoding {Width = 31, Endian = Endian.Big};
} with BinaryEncoding {WidthForComposedType = 32, DecodeAsUnit = true};
                
// pattern of section 2.2.7.1.5
pattern TSPointerCapabilitySetColorPointerFlag = enum ushort
{
    FALSE = 0x0000
      with Documentation {Description = "Monochrome mouse cursors are supported."},
    TRUE = 0x0001
      with Documentation {Description = "Color mouse cursors are supported."}
} with Documentation {EmbeddedType = true};

// 2.2.7.1.5   Pointer Capability Set (TS_POINTER_CAPABILITYSET)
type TSPointerCapabilitySet
{
    ushort CapabilitySetType where value == 8
        with Documentation
           {Description = "A 16-bit, unsigned integer. The type of the capability set. This field MUST be set to CAPSTYPE_POINTER (8)."};
  
    ushort LengthCapability
        with Documentation
           {Description = "A 16-bit, unsigned integer. The length in bytes of the capability data, including the size of the capabilitySetType and lengthCapability fields."};
  
    TSPointerCapabilitySetColorPointerFlag colorPointerFlag
        with Documentation
           {Description = "A 16-bit, unsigned integer. Indicates support for color pointers. Since RDP supports monochrome cursors by using Color Pointer Updates and New Pointer Updates (sections  and  respectively), the value of this field is ignored and is always assumed to be TRUE (at a minimum the Color Pointer Update MUST be supported by an RDP client)."};
  
    ushort ColorPointerCacheSize
        with Documentation
           {Description = "A 16-bit, unsigned integer. The number of available slots in the 24 bpp color pointer cache used to store data received in the Color Pointer Update."};
  
    ushort PointerCacheSize
        with Documentation
           {Description = "A 16-bit, unsigned integer. The number of available slots in the pointer cache used to store pointer data of arbitrary bit depth received in the New Pointer Update."};
}with Documentation
       {Applicability = "2.2.7.1.5",
        Description = "The TS_POINTER_CAPABILITYSET structure advertises pointer cache sizes and flags and is based on the capability set specified in [T128] section 8.2.11. This capability is sent by both client and server."};

// pattern of section 2.2.7.1.6
pattern TSInputCapabilitySetInputFlags = flags ushort
{
    INPUT_FLAG_SCANCODES = 0x0001
      with Documentation
             {Description = "Indicates support for using scancodes in the Keyboard Event notifications (see sections  and )."},
    INPUT_FLAG_MOUSEX = 0x0004
      with Documentation
             {Description = "Indicates support for Extended Mouse Event notifications (see sections  and )."},
    INPUT_FLAG_FASTPATH_INPUT = 0x0008
      with Documentation
             {Description = "Advertised by RDP 5.0 and 5.1 servers. RDP 5.2, 6.0, 6.1, and 7.07.0, 7.1, and 8.0 servers advertise the INPUT_FLAG_FASTPATH_INPUT2 flag to indicate support for fast-path input."},
    INPUT_FLAG_UNICODE = 0x0010
      with Documentation
             {Description = "Indicates support for Unicode Keyboard Event notifications (see sections  and )."},
    INPUT_FLAG_FASTPATH_INPUT2 = 0x0020
      with Documentation
             {Description = "Advertised by RDP 5.2, 6.0, 6.1, and 7.07.0, 7.1, and 8.0 servers. Clients that do not support this flag will not be able to use fast-path input when connecting to RDP 5.2, 6.0, 6.1, and 7.07.0, 7.1, and 8.0 servers."},         
    INPUT_FLAG_UNUSED1 = 0x0040
      with Documentation
             {Description = "An unused flag that MUST be ignored by the client if it is present in the server-to-client Input Capability Set."},
    INPUT_FLAG_UNUSED2 = 0x0080
      with Documentation
             {Description = "An unused flag that MUST be ignored by the server if it is present in the client-to-server Input Capability Set."},
    TS_INPUT_FLAG_MOUSE_HWHEEL = 0x0100,
    ...
} with Documentation {EmbeddedType = true};

pattern KeyboardType = enum uint
{
    //Sent by Client
    IBMPCXTorCompatible83keyKeyboard = 0x00000001
      with Documentation {Description = "IBM PC/XT or compatible (83-key) keyboard"},
    OlivettiICO102keyKeyboard = 0x00000002
      with Documentation {Description = "Olivetti \"ICO\" (102-key) keyboard"},
    IBMPCAT84keyorSimilarKeyboard = 0x00000003
      with Documentation {Description = "IBM PC/AT (84-key) or similar keyboard"},
    IBMEnhanced101or102keyKeyboard = 0x00000004
      with Documentation {Description = "IBM enhanced (101- or 102-key) keyboard"},
    Nokia1050andSimilarKeyboards = 0x00000005
      with Documentation {Description = "Nokia 1050 and similar keyboards"},
    Nokia9140andSimilarKeyboards = 0x00000006
      with Documentation {Description = "Nokia 9140 and similar keyboards"},
    JapaneseKeyboard = 0x00000007
      with Documentation {Description = "Japanese keyboard"},
      
    //Sent by Server
    None = 0x00000000,
    ...
} with Documentation {EmbeddedType = true};

// 2.2.7.1.6   Input Capability Set (TS_INPUT_CAPABILITYSET)
type TSInputCapabilitySet
{
    ushort CapabilitySetType where value == 13
        with Documentation
           {Description = "A 16-bit, unsigned integer. The type of the capability set. This field MUST be set to CAPSTYPE_INPUT (13)."};
  
    ushort LengthCapability
        with Documentation
           {Description = "A 16-bit, unsigned integer. The length in bytes of the capability data, including the size of the capabilitySetType and lengthCapability fields."};
  
    TSInputCapabilitySetInputFlags InputFlags where ValidationCheck(InRange<TSInputCapabilitySetInputFlags>(value), null, "RDPBCGR: The InputFlags field in type TSInputCapabilitySet has one or more undefined bits. Please refer to Input Capability Set (TS_INPUT_CAPABILITYSET) in Technical Document MS-RDPBCGR.")
        with Documentation
           {Description = "A 16-bit, unsigned integer. Input support flags."};
  
    ushort Pad2octetsA
        with Documentation
           {Description = "A 16-bit, unsigned integer. Padding. Values in this field MUST be ignored."};
  
    uint KeyboardLayout
        with Documentation
           {Description = "A 32-bit, unsigned integer. Keyboard layout (active input locale identifier). For a list of input locale identifiers, see [MSFT-DIL]. This value is only specified in the client Input Capability Set and SHOULD correspond with that sent in the Client Core Data."};
  
    KeyboardType KeyboardType where ValidationCheckValueInRange(InRange<KeyboardType>(value), null, false, ReferenceType.Type, "RDPBCGR", "KeyboardType", "TSInputCapabilitySet", 0x00000000, 0x00000007, value)
        with Documentation {Description = "A 32-bit, unsigned integer. Keyboard type."};
  
    uint KeyboardSubType
        with Documentation
           {Description = "A 32-bit, unsigned integer. Keyboard subtype (an original equipment manufacturer-dependent value). This value is only specified in the client Input Capability Set and SHOULD correspond with that sent in the Client Core Data."};
  
    uint KeyboardFunctionKey
        with Documentation
           {Description = "A 32-bit, unsigned integer. Number of function keys on the keyboard. This value is only specified in the client Input Capability Set and SHOULD correspond with that sent in the Client Core Data."};
  
    binary ImeFileName with BinaryEncoding{Length = 64}
        with Documentation
           {Description = "A 64-byte field. Input Method Editor (IME) file name associated with the input locale. This field contains up to 31 Unicode characters plus a null terminator and is only specified in the client Input Capability Set and its contents SHOULD correspond with that sent in the Client Core Data."};
}
with Documentation
       {Applicability = "2.2.7.1.6",
        Description = "The TS_INPUT_CAPABILITYSET structure is used to advertise support for input formats and devices. This capability is sent by both client and server."};

// pattern of section 2.2.7.1.7
pattern TSBrushCapabilitySetBrushSupportLevel = enum uint
{
    BrushDefault = 0x00000000
      with Documentation
             {Description = "Support for solid-color and monochrome pattern brushes with no caching. This is an RDP 4.0 implementation."},
    BrushColor8x8 = 0x00000001
      with Documentation
             {Description = "Ability to handle color brushes (4-bit or 8-bit in RDP 5.0; RDP 5.1, 5.2, 6.0, 6.1, and 7.07.0, 7.1, and 8.0 also support 16-bit and 24-bit) and caching. Brushes are limited to 8-by-8 pixels."},
    BrushColorFull = 0x00000002
      with Documentation
             {Description = "Ability to handle color brushes (4-bit or 8-bit in RDP 5.0; RDP 5.1, 5.2, 6.0, 6.1, and 7.07.0, 7.1, and 8.0 also support 16-bit and 24-bit) and caching. Brushes can have arbitrary dimensions."}
} with Documentation {EmbeddedType = true};

// 2.2.7.1.7   Brush Capability Set (TS_BRUSH_CAPABILITYSET)
type TSBrushCapabilitySet
{
    ushort CapabilitySetType where value == 15
        with Documentation
           {Description = "A 16-bit, unsigned integer. The type of the capability set. This field MUST be set to CAPSTYPE_BRUSH (15)."};
  
    ushort LengthCapability
        with Documentation
           {Description = "A 16-bit, unsigned integer. The length in bytes of the capability data, including the size of the capabilitySetType and lengthCapability fields."};
  
    TSBrushCapabilitySetBrushSupportLevel BrushSupportLevel
        with Documentation
           {Description = "A 32-bit, unsigned integer. The maximum brush level supported by the client."};
}with Documentation
       {Applicability = "2.2.7.1.7",
        Description = "The TS_BRUSH_CAPABILITYSET advertises client brush support. This capability is only sent from client to server."};

// pattern of section 2.2.7.1.8
pattern TSGlyphCacheCapabilitySetGlyphSupportLevel = enum ushort
{
    GlyphSupportNone = 0x0000
      with Documentation
             {Description = "The client does not support glyph caching. All text output will be sent to the client as expensive Bitmap Updates (see sections  and )."},
    GlyphSupportPartial = 0x0001
      with Documentation
             {Description = "Indicates support for Revision 1 Cache Glyph Secondary Drawing Orders (see [MS-RDPEGDI] section )."},
    GlyphSupportFull = 0x0002
      with Documentation
             {Description = "Indicates support for Revision 1 Cache Glyph Secondary Drawing Orders (see [MS-RDPEGDI] section )."},
    GlyphSupportEncode = 0x0003
      with Documentation
             {Description = "Indicates support for Revision 2 Cache Glyph Secondary Drawing Orders (see [MS-RDPEGDI] section )."}
} with Documentation {EmbeddedType = true};

// 2.2.7.1.8   Glyph Cache Capability Set (TS_GLYPHCACHE_CAPABILITYSET)
type TSGlyphCacheCapabilitySet
{
    ushort CapabilitySetType where value == 16
        with Documentation
           {Description = "A 16-bit, unsigned integer. The type of the capability set. This field MUST be set to CAPSTYPE_GLYPHCACHE (16)."};
  
    ushort LengthCapability
        with Documentation
           {Description = "A 16-bit, unsigned integer. The length in bytes of the capability data, including the size of the capabilitySetType and lengthCapability fields."};
  
    array<TSCacheDefinition> GlyphCache with BinaryEncoding{Length = 10}
        with Documentation
           {Description = "An array of 10 TS_CACHE_DEFINITION structures. An ordered specification of the layout of each of the glyph caches with IDs 0 through to 9 ([MS-RDPEGDI] section )."};
  
    uint FragCache
        with Documentation
           {Description = "Fragment cache data. The maximum number of entries allowed in the cache is 256, and the largest allowed maximum size of an element is 256 bytes."};
  
    TSGlyphCacheCapabilitySetGlyphSupportLevel GlyphSupportLevel
        with Documentation
           {Description = "A 16-bit, unsigned integer. The level of glyph support."};
  
    ushort Pad2octets
        with Documentation
           {Description = "A 16-bit, unsigned integer. Padding. Values in this field MUST be ignored."};
}with Documentation
       {Applicability = "2.2.7.1.8",
        Description = "The TS_GLYPHCACHE_CAPABILITYSET structure advertises the glyph support level and associated cache sizes. This capability is only sent from client to server."};

type TSCacheDefinition
{
    ushort CacheEntries where ValidationCheckLessThanOrEqualTo(value <= 254, null, false, ReferenceType.Type, "RDPBCGR", "CacheEntries", "TSCacheDefinition", 254, value)
        with Documentation
           {Description = "A 16-bit, unsigned integer. The number of entries in the cache. The maximum number of entries allowed in a cache is 254, and the largest allowed maximum size of an element is 2048 bytes."};
  
    ushort CacheMaximumCellSize
        with Documentation
           {Description = "A 16-bit, unsigned integer. The maximum size in bytes of an entry in the cache."};
}with Documentation
       {Applicability = "2.2.7.1.8.1",
        Description = "The TS_CACHE_DEFINITION structure specifies details about a particular cache in the Glyph Capability Set structure."};

// pattern of section 2.2.7.1.9
pattern TSOffscreenCapabilitySetOffscreenSupportLevel = enum uint
{
    FALSE = 0x00000000
      with Documentation {Description = "Offscreen bitmap cache is not supported."},
    TRUE = 0x00000001
      with Documentation {Description = "Offscreen bitmap cache is supported."}
} with Documentation {EmbeddedType = true};

// 2.2.7.1.9   Offscreen Bitmap Cache Capability Set (TS_OFFSCREEN_CAPABILITYSET)
type TSOffscreenCapabilitySet
{
    ushort CapabilitySetType where value == 17
        with Documentation
           {Description = "A 16-bit, unsigned integer. The type of the capability set. This field MUST be set to CAPSTYPE_OFFSCREENCACHE (17)."};
  
    ushort LengthCapability
        with Documentation
           {Description = "A 16-bit, unsigned integer. The length in bytes of the capability data, including the size of the capabilitySetType and lengthCapability fields."};
  
    TSOffscreenCapabilitySetOffscreenSupportLevel offscreenSupportLevel
        with Documentation {Description = "A 32-bit, unsigned integer."};
  
    ushort OffscreenCacheSize
        with Documentation
           {Description = "A 16-bit, unsigned integer. The maximum size in kilobytes of the offscreen bitmap cache (largest allowed value is 10,240 KB)."};
  
    ushort OffscreenCacheEntries
        with Documentation
           {Description = "A 16-bit, unsigned integer. The maximum number of cache entries (largest allowed value is 500 entries)."};
}
with Documentation {Applicability = "2.2.7.1.9",
                    Description = "The TS_OFFSCREEN_CAPABILITYSET"};

// pattern of section 2.2.7.1.10
pattern TSVirtualChannelCapabilitySetFlags = flags uint
{
    VccapsNoCompr = 0x00000000
      with Documentation
             {Description = "Virtual channel compression is not supported."},
    VccapsComprSc = 0x00000001
      with Documentation
             {Description = "Indicates to the server that virtual channel compression is supported by the client for server-to-client traffic. The highest compression level supported by the client is advertised in the Client Info PDU."},
    VccapsComprCs8k = 0x00000002
      with Documentation
             {Description = "Indicates to the client that virtual channel compression is supported by the server for client-to-server traffic (the compression level is limited to RDP 4.0 bulk compression)."}
} with Documentation {EmbeddedType = true};

// 2.2.7.1.10   Virtual Channel Capability Set (TS_VIRTUALCHANNEL_CAPABILITYSET)
type TSVirtualChannelCapabilitySet
{
    ushort CapabilitySetType where value == 20
        with Documentation
           {Description = "A 16-bit, unsigned integer. The type of the capability set. This field MUST be set to CAPSTYPE_VIRTUALCHANNEL (20)."};
  
    ushort LengthCapability
        with Documentation
           {Description = "A 16-bit, unsigned integer. The length in bytes of the capability data, including the size of the capabilitySetType and lengthCapability fields."};
  
    TSVirtualChannelCapabilitySetFlags Flags
        with Documentation
           {Description = "A 32-bit, unsigned integer. Virtual channel compression flags."};
  
    optional [|LengthCapability > 8|] uint VCChunkSize
        with Documentation
           {Description = "A 32-bit unsigned integer. When sent from server to client, this field contains the maximum allowed size of a virtual channel chunk. When sent from client to server, the value in this field is ignored by the server; the server determines the maximum virtual channel chunk size. This value MUST be greater than or equal to CHANNEL_CHUNK_LENGTH and less than or equal to 16256."};
}with Documentation
       {Applicability = "2.2.7.1.10",
        Description = "The TS_VIRTUALCHANNEL_CAPABILITYSET structure is used to advertise virtual channel support characteristics. This capability is sent by both client and server."};

// pattern of section 2.2.7.1.11
pattern TSSoundCapabilitySetSoundFlags = flags ushort
{
    SoundBeepsFlag = 0x0001
      with Documentation {Description = "Playing a beep sound is supported."}
} with Documentation {EmbeddedType = true};

// 2.2.7.1.11   Sound Capability Set (TS_SOUND_CAPABILITYSET)

type TSSoundCapabilitySet
{
    ushort CapabilitySetType where value == 12
        with Documentation
           {Description = "A 16-bit, unsigned integer. The type of the capability set. This field MUST be set to CAPSTYPE_SOUND (12)."};
  
    ushort LengthCapability
        with Documentation
           {Description = "A 16-bit, unsigned integer. The length in bytes of the capability data, including the size of the capabilitySetType and lengthCapability fields."};
  
    TSSoundCapabilitySetSoundFlags SoundFlags
        with Documentation
           {Description = "A 16-bit, unsigned integer. Support for sound options."};
  
    ushort Pad2octetsA
        with Documentation
           {Description = "A 16-bit, unsigned integer. Padding. Values in this field MUST be ignored."};
}with Documentation
       {Applicability = "2.2.7.1.11",
        Description = "The TS_SOUND_CAPABILITYSET structure advertises the ability to play a \"beep\" sound. This capability is sent only from client to server."};

// 2.2.7.2   Optional Capability Sets
// 2.2.7.2.1   Bitmap Cache Host Support Capability Set (TS_BITMAPCACHE_HOSTSUPPORT_CAPABILITYSET)

type TSBitmapCacheHostSupportCapabilitySet
{
    ushort CapabilitySetType where value == 18
        with Documentation
           {Description = "A 16-bit, unsigned integer. The type of the capability set. This field MUST be set to CAPSTYPE_BITMAPCACHE_HOSTSUPPORT (18)."};
  
    ushort LengthCapability
        with Documentation
           {Description = "A 16-bit, unsigned integer. The length in bytes of the capability data, including the size of the capabilitySetType and lengthCapability fields."};
  
    byte CacheVersion where ValidationCheckValue(value == 0x01, null, true, ReferenceType.Type, "RDPBCGR", "CacheVersion", "TSBitmapCacheHostSupportCapabilitySet", "0x01", value)
        with Documentation
           {Description = "An 8-bit, unsigned integer. Cache version. This field MUST be set to TS_BITMAPCACHE_REV2 (0x01), which indicates support for the Revision 2 bitmap caches (see [MS-RDPEGDI] section 3.1.1.1.1)."};
  
    byte Pad1
        with Documentation
           {Description = "An 8-bit, unsigned integer. Padding. Values in this field MUST be ignored."};
  
    ushort Pad2
        with Documentation
           {Description = "A 16-bit, unsigned integer. Padding. Values in this field MUST be ignored."};
}with Documentation
       {Applicability = "2.2.7.2.1",
        Description = "The TS_BITMAPCACHE_HOSTSUPPORT_CAPABILITYSET structure is used to advertise support for persistent bitmap caching (see [MS-RDPEGDI] section 3.1.1.1.1). This capability set is only sent from server to client."};

// 2.2.7.2.2   Control Capability Set (TS_CONTROL_CAPABILITYSET)
        
type TSControlCapabilitySet
{
    ushort CapabilitySetType where value == 5
        with Documentation
           {Description = "A 16-bit, unsigned integer. The type of the capability set. This field MUST be set to CAPSTYPE_CONTROL (5)."};
  
    ushort LengthCapability
        with Documentation
           {Description = "A 16-bit, unsigned integer. The length in bytes of the capability data, including the size of the capabilitySetType and lengthCapability fields."};
  
    ushort ControlFlags
        with Documentation
           {Description = "A 16-bit, unsigned integer. This field SHOULD be set to 0."};
  
    ushort RemoteDetachFlag
        with Documentation
           {Description = "A 16-bit, unsigned integer. This field SHOULD be set to FALSE (0x0000)."};
  
    ushort ControlInterest
        with Documentation
           {Description = "A 16-bit, unsigned integer. This field SHOULD be set to CONTROLPRIORITY_NEVER (0x0002)."};
  
    ushort DetachInterest
        with Documentation
           {Description = "A 16-bit, unsigned integer. This field SHOULD be set to CONTROLPRIORITY_NEVER (0x0002)."};
}with Documentation
       {Applicability = "2.2.7.2.2",
        Description = "The TS_CONTROL_CAPABILITYSET structure is used by the client to advertise control capabilities and is fully described in [T128] section 8.2.10. This capability is only sent from client to server and the server ignores its contents."};

// 2.2.7.2.3   Window Activation Capability Set (TS_WINDOWACTIVATION_CAPABILITYSET)

type TSWindowActivationCapabilitySet
{
    ushort CapabilitySetType where value == 7
        with Documentation
           {Description = "A 16-bit, unsigned integer. The type of the capability set. This field MUST be set to CAPSTYPE_ACTIVATION (7)."};
  
    ushort LengthCapability
        with Documentation
           {Description = "A 16-bit, unsigned integer. The length in bytes of the capability data, including the size of the capabilitySetType and lengthCapability fields."};
  
    ushort HelpKeyFlag
        with Documentation
           {Description = "A 16-bit, unsigned integer. This field SHOULD be set to FALSE (0x0000)."};
  
    ushort HelpKeyIndexFlag
        with Documentation
           {Description = "A 16-bit, unsigned integer. This field SHOULD be set to FALSE (0x0000)."};
  
    ushort HelpExtendedKeyFlag
        with Documentation
           {Description = "A 16-bit, unsigned integer. This field SHOULD be set to FALSE (0x0000)."};
  
    ushort WindowManagerKeyFlag
        with Documentation
           {Description = "A 16-bit, unsigned integer. This field SHOULD be set to FALSE (0x0000)."};
}with Documentation
       {Applicability = "2.2.7.2.3",
        Description = "The TS_WINDOWACTIVATION_CAPABILITYSET structure is used by the client to advertise window activation characteristics capabilities and is fully specified in [T128] section 8.2.9. This capability is only sent from client to server and the server ignores its contents."};

// 2.2.7.2.4   Share Capability Set (TS_SHARE_CAPABILITYSET)

type TSShareCapabilitySet
{
    ushort CapabilitySetType where value == 9
        with Documentation
           {Description = "A 16-bit, unsigned integer. The type of the capability set. This field MUST be set to CAPSTYPE_SHARE (9)."};
  
    ushort LengthCapability
        with Documentation
           {Description = "A 16-bit, unsigned integer. The length in bytes of the capability data, including the size of the capabilitySetType and lengthCapability fields."};
  
    ushort NodeId
        with Documentation
           {Description = "A 16-bit, unsigned integer. This field SHOULD be set to 0 by the client and to the server channel ID by the server (0x03EA)."};
  
    ushort Pad2octets
        with Documentation
           {Description = "A 16-bit, unsigned integer. Padding. Values in this field MUST be ignored."};
}
with Documentation
       {Applicability = "2.2.7.2.4",
        Description = "The TS_SHARE_CAPABILITYSET structure is used to advertise the channel ID of the sender and is fully specified in [T128] section 8.2.12. This capability is sent by both client and server."};

// 2.2.7.2.5   Font Capability Set (TS_FONT_CAPABILITYSET)

type TSFontCapabilitySet
{
    ushort CapabilitySetType where value == 14
        with Documentation
           {Description = "A 16-bit, unsigned integer. The type of the capability set. This field MUST be set to CAPSTYPE_FONT (14)."};
  
    ushort LengthCapability where value == 8
        with Documentation
           {Description = "A 16-bit, unsigned integer. The length in bytes of the capability data, including the size of the capabilitySetType and lengthCapability fields."};
  
    ushort FontSupportFlags
        with Documentation
           {Description = "A 16-bit, unsigned integer. The font support options. This field SHOULD be set to FONTSUPPORT_FONTLIST (0x0001)."};
  
    ushort Pad2octets
        with Documentation
           {Description = "A 16-bit, unsigned integer. Padding. Values in this field MUST be ignored."};
}with Documentation
       {Applicability = "2.2.7.2.5",
        Description = "The TS_FONT_CAPABILITYSET structure is used to advertise font support options. This capability is sent by both client and server."};

// 2.2.7.2.6   Multifragment Update Capability Set (TS_MULTIFRAGMENTUPDATE_CAPABILITYSET)

type TSMultifragmentUpdateCapabilitySet
{
    ushort CapabilitySetType where value == 26
        with Documentation
           {Description = "A 16-bit, unsigned integer. Type of the capability set. This field MUST be set to CAPSETTYPE_MULTIFRAGMENTUPDATE (26)."};
  
    ushort LengthCapability
        with Documentation
           {Description = "A 16-bit, unsigned integer. The length in bytes of the capability data, including the size of the capabilitySetType and lengthCapability fields."};
  
    uint MaxRequestSize
        with Documentation
           {Description = "A 32-bit, unsigned integer. The size of the buffer used to reassemble the fragments of a Fast-Path Update (see section ). The size of this buffer places a cap on the size of the largest Fast-Path Update that can be fragmented (there MUST always be enough buffer space to hold all of the related Fast-Path Update fragments for reassembly)."};
}with Documentation
       {Applicability = "2.2.7.2.6",
        Description = "The TS_MULTIFRAGMENTUPDATE_CAPABILITYSET structure is used to specify capabilities related to the fragmentation and reassembly of Fast-Path Updates (see section ). This capability is sent by both client and server."};

// pattern of section 2.2.7.2.7
pattern TSLargePointerCapabilitySetLargePointerSupportFlags = flags ushort
{
    LargePointFlag96x96 = 0x0001
      with Documentation
             {Description = "96-pixel by 96-pixel mouse pointer shapes are supported."}
} with Documentation {EmbeddedType = true};

// 2.2.7.2.7   Large Pointer Capability Set (TS_LARGE_POINTER_CAPABILITYSET)

type TSLargePointerCapabilitySet
{
    ushort CapabilitySetType where value == 27
        with Documentation
           {Description = "A 16-bit, unsigned integer. Type of the capability set. This field MUST be set to CAPSETTYPE_LARGE_POINTER (27)."};
  
    ushort LengthCapability
        with Documentation
           {Description = "A 16-bit, unsigned integer. The length in bytes of the capability data, including the size of the capabilitySetType and lengthCapability fields."};
  
    TSLargePointerCapabilitySetLargePointerSupportFlags LargePointerSupportFlags
        with Documentation {Description = "Support for large pointer shapes."};
}with Documentation
       {Applicability = "2.2.7.2.7",
        Description = "The TS_LARGE_POINTER_CAPABILITYSET structure is used to specify capabilities related to large mouse pointer shape support. This capability is sent by both client and server."};

// pattern of section 2.2.7.2.8
pattern TSCompdeskCapabilitySetCompDeskSupportLevel = enum ushort
{
    CompdeskNotSupported = 0x0000
      with Documentation
             {Description = "Desktop composition services are not supported."},
    CompdeskSupported = 0x0001
      with Documentation
             {Description = "Desktop composition services are supported."}
} with Documentation {EmbeddedType = true};

// 2.2.7.2.8   Desktop Composition Capability Set (TS_COMPDESK_CAPABILITYSET)

type TSCompdeskCapabilitySet
{
    ushort CapabilitySetType where value == 0x0019
        with Documentation
           {Description = "A 16-bit, unsigned integer. The type of capability set. This field MUST be set to 0x0019 (CAPSETTYPE_COMPDESK)."};
  
    ushort LengthCapability
        with Documentation
           {Description = "A 16-bit, unsigned integer. The length in bytes of the capability data."};
  
    TSCompdeskCapabilitySetCompDeskSupportLevel CompDeskSupportLevel
        with Documentation
           {Description = "A 16-bit, unsigned integer. The desktop composition support level."};
}with Documentation
       {Applicability = "2.2.7.2.8",
        Description = "The TS_COMPDESK_CAPABILITYSET structure is used to support desktop composition. This capability is sent by both client and server."};

// pattern of section 2.2.7.2.9
pattern TSSurfCmdsCapabilitySetCmdFlags = flags uint
{
    SurfCmdsSetsurfacebits = 0x00000002
      with Documentation
             {Description = "The Set Surface Bits Command is supported."},
    SurfCmdsFramemarker = 0x00000010
      with Documentation
             {Description = "The Frame Marker Command is supported."},
    SurfCmdsStreamsurfacebits = 0x00000040
      with Documentation
             {Description = "The Stream Surface Bits Command is supported."}
} with Documentation {EmbeddedType = true};

// 2.2.7.2.9   Surface Commands Capability Set (TS_SURFCMDS_CAPABILITYSET)

type TSSurfCmdsCapabilitySet
{
    ushort CapabilitySetType where value == 0x001C
        with Documentation
           {Description = "A 16-bit, unsigned integer. The type of capability set. This field MUST be set to 0x001C (CAPSETTYPE_SURFACE_COMMANDS)."};
  
    ushort LengthCapability
        with Documentation
           {Description = "A 16-bit, unsigned integer. The length in bytes of the capability data."};
  
    TSSurfCmdsCapabilitySetCmdFlags CmdFlags
        with Documentation
           {Description = "A 32-bit, unsigned integer. Flags indicating which Surface Commands are supported."};
  
    uint Reserved
        with Documentation
           {Description = "This field is reserved for future use and has no effect on the RDP wire traffic."};
}with Documentation
       {Applicability = "2.2.7.2.9",
        Description = "The TS_SURFCMDS_CAPABILITYSET structure advertises support for Surface Commands. This capability is sent by both the client and the server."};

// 2.2.7.2.10   Bitmap Codecs Capability Set (TS_BITMAPCODECS_CAPABILITYSET)

type TSBitmapCodecsCapabilitySet
{
    ushort CapabilitySetType where value == 0x001D
        with Documentation
           {Description = "A 16-bit, unsigned integer. The type of capability set. This field MUST be set to 0x001D (CAPSETTYPE_BITMAP_CODECS)."};
  
    ushort LengthCapability
        with Documentation
           {Description = "A 16-bit, unsigned integer. The length in bytes of the capability data."};
  
    TSBitmapCodecs SupportedBitmapCodecs
        with Documentation
           {Description = "A variable-length field containing a TS_BITMAPCODECS structure."};
}with Documentation
       {Applicability = "2.2.7.2.10",
        Description = "The TS_BITMAPCODECS_CAPABILITYSET structure advertises support for bitmap encoding and decoding codecs used in conjunction with the Set Surface Bits Surface Command and Cache Bitmap (Revision 3) Secondary Drawing Order ([MS-RDPEGDI] section ). This capability is sent by both the client and server."};

// 2.2.7.2.10.1   Bitmap Codecs (TS_BITMAPCODECS)
type TSBitmapCodecs
{
    byte BitmapCodecCount
        with Documentation
           {Description = "An 8-bit, unsigned integer. The number of bitmap codec capability entries contained in the bitmapCodecArray field (the maximum allowed is 255)."};
  
    array<TSBitmapCodec> BitmapCodecArray with BinaryEncoding{Length = BitmapCodecCount},
             Documentation
           {Description = "A variable-length array containing a series of TS_BITMAPCODEC structures that describes the supported bitmap codecs. The number of TS_BITMAPCODEC structures contained in the array is given by the bitmapCodecCount field."};
}with Documentation
       {Applicability = "2.2.7.2.10.1",
        Description = "The TS_BITMAPCODECS structure contains an array of bitmap codec capabilities."};

// pattern of section 2.2.7.2.10.1.1
pattern TSBitmapCodecCodecGUID = enum binary
{
    CodecGUIDNscodec = $[B91B8DCA0F004F15589FAE2D1A87E2D6]
      with Documentation
             {Description = "The Bitmap Codec structure defines encoding parameters for the NSCodec Bitmap Codec ([MS-RDPNSC] sections  and ). The codecProperties field MUST contain an NSCodec Capability Set ([MS-RDPNSC] section ) structure."},
    CodecGUIDRemotefx = $[122F777672BD6344AFB3B73C9C6F7886]
      with Documentation
             {Description = "The Bitmap Codec structure defines encoding parameters for the RemoteFX Bitmap Codec ([MS-RDPRFX] sections  and ). The codecProperties field MUST contain a TS_RFX_CLNT_CAPS_CONTAINER ([MS-RDPRFX] section ) structure or a TS_RFX_SRVR_CAPS_CONTAINER ([MS-RDPRFX] section ) structure."},
    
   CodecGUIDImageRemotefx = $[D4CC44278A9D744E803C0ECBEEA19C54]
      with Documentation
             {Description ="The Bitmap Codec structure defines encoding parameters for the RemoteFX Bitmap Codec ([MS-RDPRFX] sections 2 and 3) operating in image mode ([MS-RDPRFX] section 2.2.1.1.1.1)."},
             
    CodecGUIDIgnore = $[A651439C3535AE42910CCDFCE5760B58]
      with Documentation
             {Description ="The Bitmap Codec structure MUST be ignored."} 
} with Documentation {EmbeddedType = true};

// 2.2.7.2.10.1.1   Bitmap Codec (TS_BITMAPCODEC)
type IgnoredCodecProperties[ushort CodecPropertiesLength]
{ 
    binary Data with BinaryEncoding{Length = CodecPropertiesLength};
}

type TSBitmapCodec
{
    binary CodecGUID with BinaryEncoding{Length = 16},
        Documentation
           {Description = "A Globally Unique Identifier that functions as a unique ID for each bitmap codec."},
           DisplayInfo{ToText = BinaryToTSBitmapCodecCodecGUID};
  
    byte CodecID
        with Documentation
           {Description = "An 8-bit unsigned integer. When sent from the client to the server, this field contains a unique 8-bit ID that can be used to identify bitmap data encoded using the codec in wire traffic associated with the current connection - this ID is used in subsequent Set Surface Bits commands and Cache Bitmap (Revision 3) orders ([MS-RDPEGDI] section ). When sent from the server to the client, the value in this field is ignored by the client - the client determines the 8-bit ID to use for the codec. If the codecGUID field contains the CODEC_GUID_NSCODEC GUID, then this field MUST be set to 0x01 (the codec ID 0x01 MUST NOT be associated with any other bitmap codec)."};

    ushort CodecPropertiesLength
        with Documentation
           {Description = "A 16-bit, unsigned integer. The size in bytes of the codecProperties field."};
  
    ([|CodecGUID == TSBitmapCodecCodecGUID.CodecGUIDNscodec|] RDPNSC.TS_NSCODEC_CAPABILITYSET | 
     [|CodecGUID == TSBitmapCodecCodecGUID.CodecGUIDIgnore|] IgnoredCodecProperties[CodecPropertiesLength] | 
      [|(CodecGUID == TSBitmapCodecCodecGUID.CodecGUIDRemotefx || CodecGUID == TSBitmapCodecCodecGUID.CodecGUIDImageRemotefx)|](binary | any)
     ) CodecProperties with BinaryEncoding{Length = CodecPropertiesLength},
        Documentation
           {Description = "A variable-length array of bytes containing data that describes the encoding parameter of the bitmap codec. If the codecGUID field is set to CODEC_GUID_NSCODEC, this field MUST contain an NSCodec Capability Set ([MS-RDPNSC] section ) structure. Otherwise, if the codecGUID field is set to CODEC_GUID_REMOTEFX, this field MUST contain a TS_RFX_CLNT_CAPS_CONTAINER ([MS-RDPRFX] section ) structure when sent from client to server, and a TS_RFX_SRVR_CAPS_CONTAINER ([MS-RDPRFX] section ) structure when sent from server to client."};     

    override string ToString()
    {
        return "TS_BITMAPCODEC, CodecGUID: " + BinaryToTSBitmapCodecCodecGUID(CodecGUID);
    }
    
}with Documentation
       {Applicability = "2.2.7.2.10.1.1",
        Description = "The TS_BITMAPCODEC structure is used to describe the encoding parameters of a bitmap codec."};

// 2.2.8.1.1.1.1   Share Control Header (TS_SHARECONTROLHEADER)
type TSShareControlHeader
{
    ushort TotalLength
        with Documentation
            {Description = "A 16-bit unsigned integer. The total length of the packet in bytes (the length includes the size of the Share Control Header)."};

    TSShareControlHeaderPduType PDUType
        with Documentation
            {Description = "A 16-bit unsigned integer. It contains the PDU type and protocol version information. The format of the pduType word is described by the following bitmask diagram."};

    ushort PDUSource
        with Documentation
            {Description = "A 16-bit unsigned integer. The channel ID which is the transmission source of the PDU."};
}

type TSShareControlHeaderPduType
{
    byte VersionLow where ValidationCheckValue(value == 0x1, null, true, ReferenceType.Type, "RDPBCGR", "VersionLow", "TSShareControlHeaderPduType", "0x1", value) with BinaryEncoding{Width = 4},
        Documentation
            {Description = "Most significant 4 bits of the least significant byte. This field MUST be set to TS_PROTOCOL_VERSION (0x1)."};
           
    TSShareControlHeaderPduTypeType Type with BinaryEncoding{Width = 4},
        Documentation
            {Description = "Least significant 4 bits of the least significant byte."};
           
    byte VersionHigh where ValidationCheckZero(value == 0x00, null, true, ReferenceType.Type, "RDPBCGR", "VersionHigh", "TSShareControlHeaderPduType", value)
        with Documentation
            {Description = "Most significant byte. This field MUST be set to 0x00."};
}

pattern TSShareControlHeaderPduTypeType = enum byte
{
    DemandActivePDU = 0x1
        with Documentation {Description = "Demand Active PDU."},

    ConfirmActivePDU = 0x3
        with Documentation {Description = "Confirm Active PDU."},

    DeactivateAllPDU = 0x6
        with Documentation {Description = "Deactivate All PDU."},

    DataPDU = 0x7
        with Documentation
            {Description = "Data PDU (actual type is revealed by the pduType2 field in the Share Data Header structure)."},

    ServerRedirectionPDU = 0xA
        with Documentation
            {Description = "Enhanced Security Server Redirection PDU."}
} with Documentation {EmbeddedType = true};

// 2.2.8.1.1.1.2   Share Data Header (TS_SHAREDATAHEADER)
type TSShareDataHeader
{
    TSShareControlHeader ShareControlHeader
        with Documentation
            {Description = "Share Control Header containing information about the packet."};

    uint ShareId
        with Documentation
            {Description = "A 32-bit, unsigned integer. Share identifier for the packet (see [T128] section 8.4.2 for more information about share IDs)."};

    byte Pad1
        with Documentation
            {Description = "An 8-bit, unsigned integer. Padding. Values in this field MUST be ignored."};

    TSShareDataHeaderStreamId StreamId
        with Documentation
            {Description = "An 8-bit, unsigned integer. The stream identifier for the packet."};

    ushort UncompressedLength
        with Documentation
            {Description = "A 16-bit, unsigned integer. The uncompressed length of the packet in bytes."};

    TSShareControlHeaderPduType2Type PDUType2
        with Documentation
            {Description = "An 8-bit, unsigned integer. The type of Data PDU."};

    TSShareDataHeaderCompressedType CompressedType
        with Documentation
            {Description = "An 8-bit, unsigned integer. The compression type and flags specifying the data following the Share Data Header."};

    ushort CompressedLength
        with Documentation
            {Description = "A 16-bit, unsigned integer. The compressed length of the packet in bytes."};
}

pattern TSShareDataHeaderStreamId = enum byte
{
    UndefinedStreamPriority = 0x00
         with Documentation
             {Description = "Undefined stream priority. This value might be used in the Server Synchronize PDU (see section ) due to a server-side RDP bug. It MUST NOT be used in conjunction with any other PDUs."},
    LowPriorityStream = 0x01 with Documentation {Description = "Low-priority stream."},
    MediumPriorityStream = 0x02 with Documentation {Description = "Medium-priority stream."},
    HighPriorityStream = 0x04 with Documentation {Description = "High-priority stream."}
} with Documentation {EmbeddedType = true};

pattern TSShareControlHeaderPduType2Type = enum byte
{
    GraphicsUpdatePDU = 0x02 with Documentation {Description = "Graphics Update PDU"},
    ControlPDU = 0x14 with Documentation {Description = "Control PDU"},
    PointerUpdatePDU = 0x1B with Documentation {Description = "Pointer Update PDU"},
    InputEventPDU = 0x1C with Documentation {Description = "Input Event PDU"},
    SynchronizePDU = 0x1F with Documentation {Description = "Synchronize PDU"},
    RefreshRectPDU = 0x21 with Documentation {Description = "Refresh Rect PDU"},
    PlaySoundPDU = 0x22 with Documentation {Description = "Play Sound PDU"},
    SuppressOutputPDU = 0x23 with Documentation {Description = "Suppress Output PDU"},
    ShutdownRequestPDU = 0x24 with Documentation {Description = "Shutdown Request PDU"},
    ShutdownRequestDeniedPDU = 0x25 with Documentation {Description = "Shutdown Request Denied PDU"},
    SaveSessionInfoPDU = 0x26 with Documentation {Description = "Save Session Info PDU"},
    FontListPDU = 0x27 with Documentation {Description = "Font List PDU"},
    FontMapPDU = 0x28 with Documentation {Description = "Font Map PDU"},
    SetKeyboardIndicatorsPDU = 0x29 with Documentation {Description = "Set Keyboard Indicators PDU"},
    PersistentKeyListPDU = 0x2B with Documentation {Description = "Persistent Key List PDU"},
    BitmapCacheErrorPDU = 0x2C with Documentation {Description = "Bitmap Cache Error PDU (see [MS-RDPEGDI] section )"},
    SetKeyboardIMEStatusPDU = 0x2D with Documentation {Description = "Set Keyboard IME Status PDU"},
    OffscreenBitmapCacheErrorPDU = 0x2E with Documentation{Description = "Offscreen Bitmap Cache Error PDU (see [MS-RDPEGDI] section )"},
    SetErrorInfoPDU = 0x2F with Documentation {Description = "Set Error Info PDU"},
    DrawNineGridCacheErrorPDU = 0x30 with Documentation{Description = "DrawNineGrid Cache Error PDU (see [MS-RDPEGDI] section )"},
    GDIPlusErrorPDU = 0x31 with Documentation {Description = "GDI+ Error PDU (see [MS-RDPEGDI] section )"},
    AutoReconnectStatus = 0x32 with Documentation {Description = "Auto-Reconnect Status PDU"},
    StatusInfoPDU = 0x36 with Documentation {Description = "Status Info PDU"},
    MonitorLayoutPDU = 0x37 with Documentation {Description = "Monitor Layout PDU"},    
    FrameAcknowledge = 0x38 with Documentation {Description = "Frame Acknowledge PDU"}
} with Documentation {EmbeddedType = true};

// flags pattern
pattern TSShareDataHeaderCompressedFlags = flags byte
{
    PacketCompressed = 0x2
        with Documentation
        {Description = "The payload data is compressed. This value is equivalent to MPPC bit C (for more information see [RFC2118] section 3.1)."},
    PacketAtFront = 0x4
        with Documentation
        {Description = "The decompressed packet MUST be placed at the beginning of the history buffer. This value is equivalent to MPPC bit B (for more information see [RFC2118] section 3.1)."},
    PacketFlushed = 0x8
        with Documentation
        {Description = "The history buffer MUST be reinitialized (by filling it with zeros). This value is equivalent to MPPC bit A (for more information see [RFC2118] section 3.1)."},
    ...
};

type TSShareDataHeaderCompressedType
{
    TSShareDataHeaderCompressedFlags compressedFlags where ValidationCheckCombinationValueIncludeZero(InRange<TSShareDataHeaderCompressedFlags>(value), null, false, ReferenceType.Type, "RDPBCGR", "compressedFlags", "TSShareDataHeaderCompressedType", "0x2, 0x4,0x8", value)
        with BinaryEncoding{Width = 4};
        
    TSShareDataHeaderCompressionTypeMask CompressionTypeMask with BinaryEncoding{Width = 4},
        Documentation
            {Description = "Indicates the package which was used for compression. See the table which follows for a list of compression packages."};
}

pattern TSShareDataHeaderCompressionTypeMask = enum byte
{
    PacketComprType8K = 0x0
        with Documentation
            {Description = "RDP 4.0 bulk compression."},
            
    PacketComprType64K = 0x1
        with Documentation
            {Description = "RDP 5.0 bulk compression."},
            
    PacketComprTypeRDP6 = 0x2
        with Documentation
            {Description = "RDP 6.0 bulk compression."},
    
    PacketComprTypeRDP61 = 0x3
        with Documentation
            {Description = "RDP 6.1 bulk compression."}
}with Documentation {EmbeddedType = true};

// 2.2.8.1.1.2.1   Basic (TS_SECURITY_HEADER)
type BasicSecurityHeader
{
    TSSecurityHeaderFlags Flags
        with Documentation {Description = "A 16-bit, unsigned integer. Security flags."};

    ushort FlagsHi
        with Documentation
            {Description = "A 16-bit, unsigned integer. This field is reserved for future RDP needs. It is currently unused and all values are ignored. This field MUST contain valid data only if the SEC_FLAGSHI_VALID bit (0x8000) is set in the flags field. If this bit is not set, the flagsHi field is uninitialized and MAY contain random data."};
}

pattern TSSecurityHeaderFlags = flags ushort
 {
     SecExchangePkt = 0x0001
        with Documentation
             {Description = "Indicates that the packet is a Security Exchange PDU. This packet type is sent from client to server only. The client only sends this packet if it will be encrypting further communication and Standard RDP Security mechanisms are in effect."},

     SecTransportReq = 0x0002
        with Documentation 
             {Description = "Indicates that the packet is an Inititiate Multitransport Request PDU."},
        
     SecTransportRsp = 0x0004
        with Documentation 
             {Description = "Indicates that the packet is an Inititiate Multitransport Error PDU."},
        
     SecEncrypt = 0x0008
        with Documentation 
             {Description = "Indicates that the packet is encrypted."},
        
     SecResetSeqno = 0x0010
        with Documentation
             {Description = "This flag is not processed by any RDP clients or servers and MUST be ignored."},
             
     SecIgnoreSeqno = 0x0020
        with Documentation
             {Description = "This flag is not processed by any RDP clients or servers and MUST be ignored."},
             
     SecInfoPkt = 0x0040
        with Documentation
             {Description = "Indicates that the packet is a Client Info PDU. This packet type is sent from client to server only. If Standard RDP Security mechanisms are in effect, then this packet MUST also be encrypted."},
     
    SecLicensePkt = 0x0080
        with Documentation
             {Description = "Indicates that the packet is a Licensing PDU."},    
   
    SecLicenseEncryptCS = 0x0100
        with Documentation
             {Description = "Indicates to the client that the server is capable of processing encrypted licensing packets. It is sent by the server together with any licensing PDUs."},
    
    SecLicenseEncryptSC = 0x0200
        with Documentation
             {Description = "Indicates to the server that the client is capable of processing encrypted licensing packets. It is sent by the client together with the SEC_EXCHANGE_PKT flag when sending a Security Exchange PDU."},

    SecRedirectionPkt = 0x0400
        with Documentation
             {Description = "Indicates that the packet is a Standard Security Server Redirection PDU and that the PDU is encrypted."},
 
    SecSecureChecksum = 0x0800
        with Documentation
             {Description = "Indicates that the MAC for the PDU was generated using the \"salted MAC generation\" technique (see section ). If this flag is not present, then the standard technique was used (sections  and )."},

    SecAutodetectReq = 0x1000
        with Documentation
             {Description = "Indicates that the packet is an Auto-Detect Request PDU ()."}, 
        
    SecAutodetectRsp = 0x2000
        with Documentation
             {Description = "Indicates that the packet is an Auto-Detect Response PDU ()."},
             
    Reserved = 0x4000,
             
    SecFlagshiValid = 0x8000
        with Documentation
             {Description = "Indicates that the flagsHi field contains valid data. If this flag is not set, then the contents of the flagsHi field MUST be ignored."}
 } with Documentation {EmbeddedType = true};


// 2.2.8.1.1.2.2   Non-FIPS (TS_SECURITY_HEADER1)
type NonFipsSecurityHeader
{
    BasicSecurityHeader BasicSecurityHeader
        with Documentation
            {Description = "Basic Security Header, as specified in section ."};

    ulong DataSignature
        with Documentation
            {Description = "A 64-bit Message Authentication Code generated by using one of the techniques described in section ."};
}

// 2.2.8.1.1.2.3   FIPS (TS_SECURITY_HEADER2)
type FipsSecurityHeader
{
    BasicSecurityHeader BasicSecurityHeader
        with Documentation
            {Description = "Basic Security Header, as specified in section ."};

    ushort Length where ValidationCheckValue(value == 0x0010, null, true, ReferenceType.Type, "RDPBCGR", "Length", "FipsSecurityHeader", "0x0010", value)
        with Documentation
            {Description = "A 16-bit, unsigned integer. The length of the FIPS security header. This field MUST be set to 0x0010 (16 bytes)."};

    byte Version
        with Documentation
            {Description = "An 8-bit, unsigned integer. The version of the FIPS header. This field SHOULD be set to TSFIPS_VERSION1 (0x01)."};

    byte Padlen
        with Documentation
            {Description = "An 8-bit, unsigned integer. The number of padding bytes of padding appended to the end of the packet prior to encryption to make sure that the data to be encrypted is a multiple of the 3DES block size (that is, a multiple of 8 because the block size is 64 bits)."};

    ulong DataSignature
        with Documentation
            {Description = "A 64-bit Message Authentication Code generated by using the techniques specified in section ."};
}
// 2.2.8.1.1.3   Client Input Event PDU (TS_INPUT_PDU)
message TSInputPDU[TSUDSCSec1EncryptionLevel EncryptionLevel, TSUDSCSec1EncryptionMethod EncryptionMethod]
{
    optional (
              ([|EncryptionMethod in {TSUDSCSec1EncryptionMethod.EncryptionMethod40Bit,
                                      TSUDSCSec1EncryptionMethod.EncryptionMethod128Bit,
                                      TSUDSCSec1EncryptionMethod.EncryptionMethod56Bit}|] NonFipsSecurityHeader) |
              ([|(EncryptionMethod == TSUDSCSec1EncryptionMethod.EncryptionMethodFips)|] FipsSecurityHeader)
             ) SecurityHeader
        with Documentation
            {Description = "Optional security header. The presence and format of the security header depends on the Encryption Level and Encryption Method selected by the server (sections  and ). If the Encryption Level selected by the server is greater than ENCRYPTION_LEVEL_NONE (0) and the Encryption Method selected by the server is greater than ENCRYPTION_METHOD_NONE (0), then this field MUST contain one of the following headers:"};

    TSInputPDUData ClientInputEventData
        with Documentation
            {Description = "The actual contents of the Client Input Event PDU, as specified in section ."};
            
    override string ToString()
    {
        string summary = "Client Input Event PDU, NumberEvents: " + (ClientInputEventData.NumberEvents as string);
        int cnt = 0;
        foreach (var inpdu in ClientInputEventData.SlowPathInputEvents)
        {
            if (cnt == 0)
            {
                summary += ", TSInputEvent: ";
                if (ClientInputEventData.SlowPathInputEvents.Count > 1)
                {
                    summary += "[";
                }
            }
            else if (cnt > 4)
            {
                summary += " ...";
                break;
            }
            else
            {
                summary += ", ";
            }
            summary += EnumToString(inpdu.MessageType, "RDPBCGR.TSInputEventMessageType");
            cnt++;           
        }
        if (cnt > 1)
        {
            summary += "]";
        }
        return summary;
    }
}

// 2.2.8.1.1.3.1   Client Input Event PDU Data (TS_INPUT_PDU_DATA)
type TSInputPDUData
{
    TSShareDataHeader ShareDataHeader
        with Documentation
            {Description = "Share Data Header containing information about the packet. The type subfield of the pduType field of the Share Control Header MUST be set to PDUTYPE_DATAPDU (7). The pduType2 field of the Share Data Header MUST be set to PDUTYPE2_INPUT (28)."};

    ushort NumberEvents
        with Documentation
            {Description = "A 16-bit, unsigned integer. The number of slow-path input events packed together in the slowPathInputEvents field."};

    ushort Pad2Octets
        with Documentation
            {Description = "A 16-bit, unsigned integer. Padding. Values in this field MUST be ignored."};

    array<TSInputEvent> SlowPathInputEvents with BinaryEncoding{Length = NumberEvents},
        Documentation
            {Description = "A collection of Slow-Path Input Events to be processed by the server. The number of events present in this array is given by the numberEvents field."};
}

// 2.2.8.1.1.3.1.1   Slow-Path Input Event (TS_INPUT_EVENT)
type TSInputEvent
{
    uint EventTime
        with Documentation
            {Description = "A 32-bit, unsigned integer. The 32-bit time stamp for the input event. This value is ignored by the server."};

    TSInputEventMessageType MessageType
        with Documentation
            {Description = "A 16-bit, unsigned integer. The input event type."};

    ([|MessageType == 0x0004|] TSKeyboadrEvent | [|MessageType == 0x0005|] TSUnicodeKeyboardEvent | [|MessageType == 0x8001|] TSPointerEvent | [|MessageType == 0x8002|] TSPointerXEvent | [|MessageType == 0x0000|] TSSyncEvent | [|MessageType == 0x0002|] TSUnusedEvent) SlowPathInputData
        with Documentation
            {Description = "TS_KEYBOARD_EVENT, TS_UNICODE_KEYBOARD_EVENT, TS_POINTER_EVENT, TS_POINTERX_EVENT, or TS_SYNC_EVENT. The actual contents of the slow-path input event (see sections  through )."};
}

pattern TSInputEventMessageType = enum ushort
{
    SynchronizeEvent = 0x0000
        with Documentation {Description = "Indicates a Synchronize Event."},

    UnusedEvent = 0x0002
        with Documentation {Description = "Indicates an Unused Event."},

    KeyboardEvent = 0x0004
        with Documentation {Description = "Indicates a Keyboard Event."},

    UnicodeKeyboardEvent = 0x0005
        with Documentation {Description = "Indicates a Unicode Keyboard Event."},

    MouseEvent = 0x8001
        with Documentation {Description = "Indicates a Mouse Event."},

    ExtendedMouseEvent = 0x8002
        with Documentation {Description = "Indicates an Extended Mouse Event."}
};

// 2.2.8.1.1.3.1.1.1   Keyboard Event (TS_KEYBOARD_EVENT)
type TSKeyboadrEvent
{
    TSKeyboadrEventkeyboardFlags KeyboardFlags
        with Documentation
            {Description = "A 16-bit, unsigned integer. The flags describing the keyboard event."};

    ushort KeyCode
        with Documentation
            {Description = "A 16-bit, unsigned integer. The scancode of the key which triggered the event."};

    ushort Pad2Octets
        with Documentation
            {Description = "A 16-bit, unsigned integer. Padding. Values in this field MUST be ignored."};
}

pattern TSKeyboadrEventkeyboardFlags = flags ushort
{
    KBDFlagsExtended = 0x0100 
        with Documentation
            {Description = "The keystroke message contains an extended scancode. For enhanced 101-key and 102-key keyboards, extended keys include the right ALT and right CTRL keys on the main section of the keyboard; the INS, DEL, HOME, END, PAGE UP, PAGE DOWN and ARROW keys in the clusters to the left of the numeric keypad; and the Divide (\"/\") and ENTER keys in the numeric keypad."},

    KBDFlagsDown = 0x4000 
        with Documentation
            {Description = "Indicates that the key was down prior to this event."},

    KBDFlagsRelease = 0x8000
        with Documentation
            {Description = "The absence of this flag indicates a key-down event, while its presence indicates a key-release event."}

}with Documentation {EmbeddedType = true};

// 2.2.8.1.1.3.1.1.2   Unicode Keyboard Event (TS_UNICODE_KEYBOARD_EVENT)
type TSUnicodeKeyboardEvent
{
    TSUnicodeKeyboadrEventkeyboardFlags KeyboardFlags
        with Documentation
            {Description = "A 16-bit unsigned integer. The flags describing the Unicode keyboard event."};

    ushort UnicodeCode
        with Documentation
            {Description = "A 16-bit unsigned integer. The Unicode character input code."};

    ushort Pad2Octets
        with Documentation
            {Description = "A 16-bit unsigned integer. Padding. Values in this field MUST be ignored."};
}

pattern TSUnicodeKeyboadrEventkeyboardFlags = flags ushort
{
    KBDFlagsRelease = 0x8000
        with Documentation
            {Description = "The absence of this flag indicates a key-down event, whereas its presence indicates a key-release event."}
};

// 2.2.8.1.1.3.1.1.3   Mouse Event (TS_POINTER_EVENT)
type TSPointerEvent
{
    TSPointerEventPointerFlags PointerFlags
        with Documentation
            {Description = "A 16-bit, unsigned integer. The flags describing the pointer event."};

    ushort XPos
        with Documentation
            {Description = "A 16-bit, unsigned integer. The x-coordinate of the pointer relative to the top-left corner of the server\'s desktop."};

    ushort YPos
        with Documentation
            {Description = "A 16-bit, unsigned integer. The y-coordinate of the pointer relative to the top-left corner of the server\'s desktop."};
}

type TSPointerEventPointerFlags
{
    byte WheelRotationMask;
    TSPointerEventPointerFlagsPart PointerFlags;    
}

pattern TSPointerEventPointerFlagsPart = flags byte
{    
    PTRFlagsWheel = 0x02
        with Documentation
            {Description = "The event is a mouse wheel rotation. The only valid flags in a wheel rotation event are PTRFLAGS_WHEEL_NEGATIVE and the WheelRotationMask; all other pointer flags are ignored."},
            
    PTRFlagsWheelNegative = 0x01
        with Documentation
            {Description = "The wheel rotation value (contained in the WheelRotationMask bit field) is negative and MUST be sign-extended before injection at the server."},
           
    PTRFlagsMove = 0x08
        with Documentation
            {Description = "Indicates that the mouse position MUST be updated to the location specified by the xPos and yPos fields. "},
            
    PTRFlagsDown = 0x80
        with Documentation
            {Description = "Indicates that a click event has occurred at the position specified by the xPos and yPos fields. The button flags indicate which button has been clicked and at least one of these flags MUST be set."},
            
    PTRFlagsButton1 = 0x10
        with Documentation
            {Description = "Mouse button 1 (left button) was clicked or released. If the PTRFLAGS_DOWN flag is set, then the button was clicked, otherwise it was released."},
            
    PTRFlagsButton2 = 0x20
        with Documentation
            {Description = "Mouse button 2 (right button) was clicked or released. If the PTRFLAGS_DOWN flag is set, then the button was clicked, otherwise it was released."},
            
    PTRFlagsButton3 = 0x40
        with Documentation
            {Description = "Mouse button 3 (middle button or wheel) was clicked or released. If the PTRFLAGS_DOWN flag is set, then the button was clicked, otherwise it was released."}   
};

// 2.2.8.1.1.3.1.1.4   Extended Mouse Event (TS_POINTERX_EVENT)
type TSPointerXEvent
{
    TSPointerXEventPointerFlags PointerFlags
        with Documentation
            {Description = "A 16-bit unsigned integer. The flags describing the extended mouse event."};
  
    ushort XPos
        with Documentation
            {Description = "A 16-bit unsigned integer. The x-coordinate of the pointer."};
  
    ushort YPos
        with Documentation
            {Description = "A 16-bit unsigned integer. The y-coordinate of the pointer."};
}

pattern TSPointerXEventPointerFlags = flags ushort 
{
    PTRXFlagsDown = 0x8000
        with Documentation
            {Description = "Indicates that a click event has occurred at the position specified by the xPos and yPos fields. The button flags indicate which button has been clicked and at least one of these flags MUST be set."},

    PTRXFlagsButton1 = 0x0001
        with Documentation
            {Description = "Extended mouse button 1 (also referred to as button 4) was clicked or released. If the PTRXFLAGS_DOWN flag is set, the button was clicked; otherwise, it was released."},

    PTRXFlagsButton2 = 0x0002
        with Documentation
            {Description = "Extended mouse button 2 (also referred to as button 5) was clicked or released. If the PTRXFLAGS_DOWN flag is set, the button was clicked; otherwise, it was released."}
                                       
}with Documentation {EmbeddedType = true};

// 2.2.8.1.1.3.1.1.5   Synchronize Event (TS_SYNC_EVENT)
type TSSyncEvent
{
    ushort Pad2Octets
        with Documentation
            {Description = "A 16-bit, unsigned integer. Padding. Values in this field MUST be ignored."};

    TSSyncEventToggleFlags ToggleFlags
        with Documentation
            {Description = "A 32-bit, unsigned integer. Flags indicating the \"on\" status of the keyboard toggle keys."};
}

pattern TSSyncEventToggleFlags = flags uint
{
    TSSyncScrollLock = 0x00000001
        with Documentation
            {Description = "Indicates that the Scroll Lock indicator light SHOULD be on."},

    TSSyncNumLock = 0x00000002
        with Documentation
            {Description = "Indicates that the Num Lock indicator light SHOULD be on."},

    TSSyncCapsLock = 0x00000004
        with Documentation
            {Description = "Indicates that the Caps Lock indicator light SHOULD be on."},

    TSSyncKanaLock = 0x00000008
        with Documentation
            {Description = "Indicates that the Kana Lock indicator light SHOULD be on."}
            
}with Documentation {EmbeddedType = true};

// 2.2.8.1.1.3.1.1.6   Unused Event (TS_UNUSED_EVENT)
type TSUnusedEvent
{
    uint Pad4Octets
        with Documentation
            {Description = "A 32-bit, unsigned integer. This field is padding, and the values in this field MUST be ignored"};

    ushort Pad2Octets
        with Documentation
            {Description = "A 32-bit, unsigned integer. This field is padding, and the values in this field MUST be ignored"};
}

// 2.2.8.1.2   Client Fast-Path Input Event PDU (TS_FP_INPUT_PDU)
message TSFPInputEventPdu
{
    TSFPInputPduInputHeader FpInputHeader
        with Documentation
            {Description = "An 8-bit, unsigned integer. One-byte, bit-packed header. This byte coincides with the first byte of the TPKT Header (see [T123] section 8). Three pieces of information are collapsed into this byte:"};

    byte Length1
        with Documentation
           {Description = "An 8-bit, unsigned integer. If the most significant bit of the length1 field is not set, then the size of the PDU is in the range 1 to 127 bytes and the length1 field contains the overall PDU length (the length2 field is not present in this case). However, if the most significant bit of the length1 field is set, then the overall PDU length is given by the low 7 bits of the length1 field concatenated with the 8 bits of the length2 field, in big-endian order (the length2 field contains the low-order bits)."};
  
    optional ([|(Length1 & 0x80) == 0x80|] byte) Length2
        with Documentation
           {Description = "An 8-bit, unsigned integer. If the most significant bit of the length1 field is not set, then the length2 field is not present. If the most significant bit of the length1 field is set, then the overall PDU length is given by the low 7 bits of the length1 field concatenated with the 8 bits of the length2 field, in big-endian order (the length2 field contains the low-order bits)."};
  
    optional TSFPFipSInfo FipsInformation
        with Documentation
           {Description = "Optional FIPS header information, present when the Encryption Method selected by the server (sections  and ) is ENCRYPTION_METHOD_FIPS (0x00000010). The Fast-Path FIPS Information structure is specified in section ."};
  
    optional ([|(FpInputHeader.secFlags & TSFPInputPduInputHeaderSecurityFlags.FAST_PATH_INPUT_ENCRYPTED) == TSFPInputPduInputHeaderSecurityFlags.FAST_PATH_INPUT_ENCRYPTED|] ulong) DataSignature
        with Documentation
           {Description = "MAC generated over the packet using one of the techniques specified in section  (the FASTPATH_OUTPUT_SECURE_CHECKSUM flag, which is set in the fpOutputHeader field, describes the method used to generate the signature). This field MUST be present if the FASTPATH_OUTPUT_ENCRYPTED flag is set in the fpOutputHeader field."};
  
    optional ([|((FpInputHeader.secFlags & TSFPInputPduInputHeaderSecurityFlags.FAST_PATH_INPUT_ENCRYPTED) == 0) && (FpInputHeader.NumberEvents == 0)|] byte) NumberEvents
        with Documentation
           {Description = "An 8-bit, unsigned integer. The number of fast-path input events packed together in the fpInputEvents field (up to 255). This field is present if the numberEvents bit field in the fast-path header byte is zero."};
  
    optional ([|(FpInputHeader.secFlags & TSFPInputPduInputHeaderSecurityFlags.FAST_PATH_INPUT_ENCRYPTED) == TSFPInputPduInputHeaderSecurityFlags.FAST_PATH_INPUT_ENCRYPTED|] binary) EncryptedData;
    
    optional ([|(FpInputHeader.secFlags & TSFPInputPduInputHeaderSecurityFlags.FAST_PATH_INPUT_ENCRYPTED) == 0|] array<TSFPInputEvent>) FpInputEvents
        with Documentation
           {Description = "An array of Fast-Path Input Event structures to be processed by the server. The number of events present in this array is given by the numberEvents bit field in the fast-path header byte, or by the numberEvents field in the Fast-Path Input Event PDU (if it is present)."};
           
    override string ToString()
    {
        string summary = "Client Fast-Path Input Event PDU";
        if ((FpInputHeader.secFlags & TSFPInputPduInputHeaderSecurityFlags.FAST_PATH_INPUT_ENCRYPTED) == TSFPInputPduInputHeaderSecurityFlags.FAST_PATH_INPUT_ENCRYPTED)
        {
            summary += ", Encrypted";
        }
        else
        {
            if (NumberEvents != nothing)
            {
                summary += ", NumberEvents: " + (NumberEvents as string);
                if ((NumberEvents as uint) > 0 && FpInputEvents != nothing)
                {
                    summary += ", FpInputEvents: ";
                    if ((FpInputEvents as array<TSFPInputEvent>).Count > 1)
                    {
                        summary += "[";
                    }
                    int cnt = 0;
                    foreach (var e in (FpInputEvents as array<TSFPInputEvent>))
                    {
                        if (cnt > 4)
                        {
                            summary += " ...";
                            break;
                        }
                        else if (cnt > 0)
                        {
                            summary += ", ";
                        }
                        if (e is TSFPKeyboardEvent)
                        {
                            summary += "TSFPKeyboardEvent";
                        }
                        else if (e is TSFPUnicodeKeyboardEvent)
                        {
                            summary += "TSFPUnicodeKeyboardEvent";
                        }
                        else if (e is TSFPPointerEvent)
                        {
                            summary += "TSFPPointerEvent";
                        }
                        else if (e is TSFPPointerXEvent)
                        {
                            summary += "TSFPPointerXEvent";
                        }
                        else if (e is TSFPSyncEvent)
                        {
                            summary += "TSFPSyncEvent";
                        }
                        cnt++;
                    }
                    if (cnt > 1)
                    {
                        summary += "]";
                    }
                }
            }
        }
        int length = (Length2 is l:byte) ? ((((Length1 & 0x7F) as ushort) << 8) | (l as ushort)) : Length1;
        return summary + ", Length: " + length.ToString();
    }
}

type TSFPInputPduInputHeader
{          
    TSFPInputPduInputHeaderSecurityFlags secFlags with BinaryEncoding{Width = 2}; 
            
    byte NumberEvents with BinaryEncoding{Width = 4},
        Documentation
            {Description = "Collapses the number of fast-path input events packed together in the fpInputEvents field into 4 bits if the number of events is in the range 1 to 15. If the number of input events is greater than 15, then the numberEvents bit field in the fast-path header byte MUST be set to zero, and the numberEvents optional field inserted after the dataSignature field. This allows up to 255 input events in one PDU."};

    TSFPInputPduInputHeaderAction Action where ValidationCheckEnumValue(InRange<TSFPInputPduInputHeaderAction>(value), null, false, ReferenceType.Type, "RDPBCGR", "Action", "TSFPInputPduInputHeader", "0x0, 0x3", value)
        with BinaryEncoding{Width = 2},
        Documentation
            {Description = "An array of Fast-Path Input Event structures to be processed by the server. The number of events present in this array is given by the numberEvents bit field in the fast-path header byte, or by the numberEvents field in the Fast-Path Input Event PDU (if it is present)."};
}

pattern TSFPInputPduInputHeaderAction = enum byte
{
    FASTPATH_INPUT_ACTION_FASTPATH = 0x0,
    
    FASTPATH_INPUT_ACTION_X224 = 0x3,
    
    ...
};

pattern TSFPInputPduInputHeaderSecurityFlags = flags byte
{
    FASTPATH_INPUT_SECURE_CHECKSUM = 0x1,
    
    FAST_PATH_INPUT_ENCRYPTED = 0x2,
};

// 2.2.8.1.2.1   Fast-Path FIPS Information (TS_FP_FIPS_INFO)
type TSFPFipSInfo
{
    ushort Length where value == 0x0010
        with Documentation
           {Description = "A 16-bit, unsigned integer. The length of the FIPS Security Header. This field MUST be set to 0x0010 (16 bytes)."};
    
    byte Version
        with Documentation
           {Description = "An 8-bit, unsigned integer. The version of the FIPS Header. This field SHOULD be set to TSFIPS_VERSION1 (0x01)."};

    byte PadLen
        with Documentation
           {Description = "An 8-bit, unsigned integer. The number of padding bytes of padding appended to the end of the packet prior to encryption to make sure that the data to be encrypted is a multiple of the 3DES block size (that is, a multiple of 8 because the block size is 64 bits)."};
}

// 2.2.8.1.2.2   Fast-Path Input Event (TS_FP_INPUT_EVENT)
pattern TSFPInputEvent = TSFPKeyboardEvent | TSFPUnicodeKeyboardEvent | TSFPPointerEvent | TSFPPointerXEvent | TSFPSyncEvent;

pattern TSFPInputEventEventHeaderEventCode = enum byte
{
    ScanCode    = 0x00
        with Documentation {Description = "Indicates a Fast-Path Keyboard Event."},
    Mouse       = 0x01
        with Documentation {Description = "Indicates a Fast-Path Mouse Event."},
    MouseX      = 0x02
        with Documentation
             {Description = "Indicates a Fast-Path Extended Mouse Event."},
    Sync        = 0x03
        with Documentation {Description = "Indicates a Fast-Path Synchronize Event."},
    Unicode     = 0x04
        with Documentation
             {Description = "Indicates a Fast-Path Unicode Keyboard Event."}
} with Documentation {EmbeddedType = true};

type TSFPInputEventEventHeader
{
    TSFPInputEventEventHeaderEventCode EventCode with BinaryEncoding{Width = 3};
    
     ([|EventCode == TSFPInputEventEventHeaderEventCode.ScanCode|] TSFPKeyboardEventEventHeaderEventFlags | 
      [|EventCode == TSFPInputEventEventHeaderEventCode.Mouse|] byte | 
      [|EventCode == TSFPInputEventEventHeaderEventCode.MouseX|] byte | 
      [|EventCode == TSFPInputEventEventHeaderEventCode.Sync|] TSFPSyncEventEventHeaderEventFlags | 
      [|EventCode == TSFPInputEventEventHeaderEventCode.Unicode|] TSFPUnicodeKeyboardEventEventHeaderEventFlags) EventFlags with BinaryEncoding{Width = 5};
}

// 2.2.8.1.2.2.1   Fast-Path Keyboard Event (TS_FP_KEYBOARD_EVENT)
type TSFPKeyboardEvent
{
    TSFPInputEventEventHeader EventHeader where value.EventCode == TSFPInputEventEventHeaderEventCode.ScanCode
        with Documentation
           {Description = "An 8-bit, unsigned integer. The format of this field is the same as the eventHeader byte field described in section . The eventCode bitfield (3 bits in size) MUST be set to FASTPATH_INPUT_EVENT_SCANCODE (0). The eventFlags bitfield (5 bits in size) contains flags describing the keyboard event."};
  
    byte keyCode
        with Documentation
           {Description = "An 8-bit, unsigned integer. The scancode of the key which triggered the event."};
}

pattern TSFPKeyboardEventEventHeaderEventFlags = flags byte
{
    FastpathInputKBDFflagsRelease = 0x01
            with Documentation
             {Description = "The absence of this flag indicates a key-down event, while its presence indicates a key-release event."},

    FastpathInputKBDFflagsExtended = 0x02
            with Documentation
             {Description = "The keystroke message contains an extended scancode. For enhanced 101-key and 102-key keyboards, extended keys include the right ALT and right CTRL keys on the main section of the keyboard; the INS, DEL, HOME, END, PAGE UP, PAGE DOWN and ARROW keys in the clusters to the left of the numeric keypad; and the Divide (\"/\") and ENTER keys in the numeric keypad."}
}with Documentation {EmbeddedType = true}, BinaryEncoding{Width = 5};

// 2.2.8.1.2.2.2   Fast-Path Unicode Keyboard Event (TS_FP_UNICODE_KEYBOARD_EVENT)
type TSFPUnicodeKeyboardEvent
{
    TSFPInputEventEventHeader EventHeader where value.EventCode == TSFPInputEventEventHeaderEventCode.Unicode
        with Documentation
            {Description = "An 8-bit unsigned integer. The format of this field is the same as the eventHeader byte field, specified in section . The eventCode bitfield (3 bits in size) MUST be set to FASTPATH_INPUT_EVENT_UNICODE (4). The eventFlags bitfield (5 bits in size) contains flags describing the keyboard event."};
  
    ushort UnicodeCode
        with Documentation
           {Description = "A 16-bit unsigned integer. The Unicode character input code."};
}

pattern TSFPUnicodeKeyboardEventEventHeaderEventFlags = flags byte
{
    FastpathInputKBDFflags = 0x01
          with Documentation
             {Description = "The absence of this flag indicates a key-down event, whereas its presence indicates a key-release event."}
}with Documentation {EmbeddedType = true}, BinaryEncoding{Width = 5};

// 2.2.8.1.2.2.3   Fast-Path Mouse Event (TS_FP_POINTER_EVENT)
type TSFPPointerEvent
{
    TSFPInputEventEventHeader EventHeader where value.EventCode == TSFPInputEventEventHeaderEventCode.Mouse
        with Documentation
            {Description = "An 8-bit, unsigned integer. The format of this field is the same as the eventHeader byte field, specified in section . The eventCode bitfield (3 bits in size) MUST be set to FASTPATH_INPUT_EVENT_MOUSE (1). The eventFlags bitfield (5 bits in size) MUST be zeroed out."};
  
    TSPointerEventPointerFlags PointerFlags
        with Documentation
            {Description = "A 16-bit, unsigned integer. The flags describing the pointer event. The possible flags are identical to those found in the pointerFlags field of the TS_POINTER_EVENT structure."};
  
    ushort XPos
        with Documentation
            {Description = "A 16-bit, unsigned integer. The x-coordinate of the pointer."};
  
    ushort YPos
        with Documentation
            {Description = "A 16-bit, unsigned integer. The y-coordinate of the pointer."};
}

// 2.2.8.1.2.2.4   Fast-Path Extended Mouse Event (TS_FP_POINTERX_EVENT)
type TSFPPointerXEvent
{
    TSFPInputEventEventHeader EventHeader where value.EventCode == TSFPInputEventEventHeaderEventCode.MouseX
        with Documentation
            {Description = "An 8-bit, unsigned integer. The format of this field is the same as the eventHeader byte field, specified in section . The eventCode bitfield (3 bits in size) MUST be set to FASTPATH_INPUT_EVENT_MOUSEX (2). The eventFlags bitfield (5 bits in size) MUST be zeroed out."};
  
    TSPointerEventPointerFlags PointerFlags
        with Documentation
            {Description = "A 16-bit, unsigned integer. The flags describing the pointer event. The possible flags are identical to those found in the pointerFlags field of the TS_POINTERX_EVENT structure."};
  
    ushort xPos
        with Documentation
            {Description = "A 16-bit, unsigned integer. The x-coordinate of the pointer."};
  
    ushort yPos
        with Documentation
            {Description = "A 16-bit, unsigned integer. The y-coordinate of the pointer."};
}

// 2.2.8.1.2.2.5   Fast-Path Synchronize Event (TS_FP_SYNC_EVENT)
type TSFPSyncEvent
{
    TSFPInputEventEventHeader EventHeader where value.EventCode == TSFPInputEventEventHeaderEventCode.Sync
        with Documentation
            {Description = "An 8-bit, unsigned integer. The format of this field is the same as the eventHeader byte field, specified in section . The eventCode bitfield (3 bits in size) MUST be set to FASTPATH_INPUT_EVENT_SYNC (3). The eventFlags bitfield (5 bits in size) contains flags indicating the \"on\" status of the keyboard toggle keys."};
}

pattern TSFPSyncEventEventHeaderEventFlags = flags byte
{
    FastpathInputSyncScrollLock = 0x01
        with Documentation
             {Description = "Indicates that the Scroll Lock indicator light SHOULD be on."},

    FastpathInputSyncNumLock = 0x02
        with Documentation
             {Description = "Indicates that the Num Lock indicator light SHOULD be on."},

    FastpathInputSyncCapsLock = 0x04
        with Documentation
             {Description = "Indicates that the Caps Lock indicator light SHOULD be on."},

    FastpathInputSyncKanaLock = 0x08
        with Documentation
             {Description = "Indicates that the Kana Lock indicator light SHOULD be on."}
}with Documentation {EmbeddedType = true}, BinaryEncoding{Width = 5};

// 2.2.8.2.1   Server Set Keyboard Indicators PDU
message ServerSetKeyboardIndicatorsPdu[TSUDSCSec1EncryptionLevel EncryptionLevel, TSUDSCSec1EncryptionMethod EncryptionMethod]
{
    optional (
              ([|EncryptionLevel == TSUDSCSec1EncryptionLevel.EncryptionLevelLow|] BasicSecurityHeader) |
              ([|EncryptionMethod in {TSUDSCSec1EncryptionMethod.EncryptionMethod40Bit,
                                      TSUDSCSec1EncryptionMethod.EncryptionMethod128Bit,
                                      TSUDSCSec1EncryptionMethod.EncryptionMethod56Bit}|] NonFipsSecurityHeader) |
              ([|(EncryptionMethod == TSUDSCSec1EncryptionMethod.EncryptionMethodFips)|] FipsSecurityHeader)
             ) SecurityHeader
        with Documentation
           {Description = "Optional security header. The presence and format of the security header depends on the Encryption Level and Encryption Method selected by the server (sections  and ). If the Encryption Level selected by the server is greater than ENCRYPTION_LEVEL_NONE (0) and the Encryption Method selected by the server is greater than ENCRYPTION_METHOD_NONE (0) then this field MUST contain one of the following headers:"};
  
    TSSetKeyboardIndicatorsPDU SetKeyBdIndicatorsPduData
        with Documentation
           {Description = "The actual contents of the Set Keyboard Indicators PDU, as specified in section ."};
           
    override string ToString()
    {
        return "Server Set Keyboard Indicators PDU, LedFlags: " + EnumToString(SetKeyBdIndicatorsPduData.LedFlags, "RDPBCGR.TSSetKeyboardIndicatorsPDULedFlags");
    }
}

// 2.2.8.2.1.1   Set Keyboard Indicators PDU Data (TS_SET_KEYBOARD_INDICATORS_PDU)
type TSSetKeyboardIndicatorsPDU
{
    TSShareDataHeader ShareDataHeader
        with Documentation
            {Description = "Share Data Header containing information about the packet. The type subfield of the pduType field of the Share Control Header MUST be set to PDUTYPE_DATAPDU (7). The pduType2 field of the Share Data Header MUST be set to PDUTYPE2_SET_KEYBOARD_INDICATORS (41)."};

    ushort UnitId
        with Documentation
            {Description = "A 16-bit, unsigned integer. Hardware related value. This field SHOULD be ignored by the client and as a consequence SHOULD be set to 0 by the server."};

    TSSetKeyboardIndicatorsPDULedFlags LedFlags
        with Documentation
            {Description = "A 16-bit, unsigned integer. The flags indicating the \"on\" status of the keyboard toggle keys."};
}

pattern TSSetKeyboardIndicatorsPDULedFlags = flags ushort
{
    TSSyncScrollLock = 0x01
        with Documentation
             {Description = "Indicates that the Scroll Lock indicator light SHOULD be on."},

    TSSyncNumLock = 0x02
        with Documentation
             {Description = "Indicates that the Num Lock indicator light SHOULD be on."},

    TSSyncCapsLock = 0x04
        with Documentation
             {Description = "Indicates that the Caps Lock indicator light SHOULD be on."},

    TSSyncKanaLock = 0x08
        with Documentation
             {Description = "Indicates that the Kana Lock indicator light SHOULD be on."}
}with Documentation {EmbeddedType = true};

// 2.2.8.2.2   Server Set Keyboard IME Status PDU
message ServerSetKeyboardIMEStatusPdu[TSUDSCSec1EncryptionLevel EncryptionLevel, TSUDSCSec1EncryptionMethod EncryptionMethod]
{
    optional (
              ([|EncryptionLevel == TSUDSCSec1EncryptionLevel.EncryptionLevelLow|] BasicSecurityHeader) |
              ([|EncryptionMethod in {TSUDSCSec1EncryptionMethod.EncryptionMethod40Bit,
                                      TSUDSCSec1EncryptionMethod.EncryptionMethod128Bit,
                                      TSUDSCSec1EncryptionMethod.EncryptionMethod56Bit}|] NonFipsSecurityHeader) |
              ([|(EncryptionMethod == TSUDSCSec1EncryptionMethod.EncryptionMethodFips)|] FipsSecurityHeader)
             ) SecurityHeader
        with Documentation
            {Description = "Optional security header. The presence and format of the security header depends on the Encryption Level and Encryption Method selected by the server (sections  and ). If the Encryption Level selected by the server is greater than ENCRYPTION_LEVEL_NONE (0) and the Encryption Method selected by the server is greater than ENCRYPTION_METHOD_NONE (0) then this field MUST contain one of the following headers:"};

    TSSetKeyboardIMEStatusPDU SetKeyBdImeStatusPduData
        with Documentation
            {Description = "The actual contents of the Set Keyboard IME Status PDU, as specified in section ."};
            
    override string ToString()
    {
        return "Server Set Keyboard IME Status PDU, ImeState: " + EnumToString(SetKeyBdImeStatusPduData.ImeState, "RDPBCGR.TSSetKeyboardIMEStatusPDUImeState") + ", ImeConvMode: " + EnumToString(SetKeyBdImeStatusPduData.ImeConvMode, "RDPBCGR.TSSetKeyboardIMEStatusPDUImeConvMode");
    }
}

// 2.2.8.2.2.1   Set Keyboard IME Status PDU Data (TS_SET_KEYBOARD_IME_STATUS_PDU)
type TSSetKeyboardIMEStatusPDU
{
    TSShareDataHeader ShareDataHeader
        with Documentation
           {Description = "Share Data Header containing information about the packet. The type subfield of the pduType field of the Share Control Header MUST be set to PDUTYPE_DATAPDU (7). The pduType2 field of the Share Data Header MUST be set to PDUTYPE2_SET_KEYBOARD_IME_STATUS (45)."};

    ushort UnitId
        with Documentation
            {Description = "A 16-bit, unsigned integer. The unit identifier for which the IME message is intended. This field SHOULD be ignored by the client and as a consequence SHOULD be set to 0 by the server."};

    TSSetKeyboardIMEStatusPDUImeState ImeState
        with Documentation
            {Description = "A 32-bit, unsigned integer. Indicates the open or closed state of the IME."};

    TSSetKeyboardIMEStatusPDUImeConvMode ImeConvMode
        with Documentation
            {Description = "A 32-bit, unsigned integer. Indicates the IME conversion mode."};
}

pattern TSSetKeyboardIMEStatusPDUImeState = enum uint
{
    Closed = 0x00000000
      with Documentation {Description = "The IME state is closed."},
    Open = 0x00000001
      with Documentation {Description = "The IME state is open."}
} with Documentation {EmbeddedType = true};

pattern TSSetKeyboardIMEStatusPDUImeConvMode = flags uint
{
    ImeCmodeNative = 0x00000001
        with Documentation
            {Description = "The input mode is native. If not set, the input mode is alphanumeric."},
            
    ImeCmodeKatakana = 0x00000002
        with Documentation
            {Description = "The input mode is Katakana. If not set, the input mode is Hiragana."},
                
    ImeCmodeFullshape = 0x00000008
        with Documentation
            {Description = "The input mode is full-width. If not set, the input mode is half-width."},    
    
    ImeCmodeRoman = 0x00000010
        with Documentation
            {Description = "The input mode is Roman."},    
    
    ImeCmodeCharCode = 0x00000020
        with Documentation
            {Description = "Character-code input is in effect."},    
    
    ImeCmodeHanjaConvert = 0x00000040
        with Documentation
            {Description = "Hanja conversion mode is in effect."},    
    
    ImeCmodeSoftKBD = 0x00000080
        with Documentation
            {Description = "A soft (on-screen) keyboard is being used."},    
    
    ImeCmodeNoConversion = 0x00000100
        with Documentation
            {Description = "IME conversion is inactive (that is, the IME is closed)."},    
    
    ImeCmodeEudc = 0x00000200
        with Documentation
            {Description = "End-User Defined Character (EUDC) conversion mode is in effect."},    
    
    ImeCmodeSymbol = 0x00000400
        with Documentation
            {Description = "Symbol conversion mode is in effect."},    
    
    ImeCmodeFixed = 0x00000800
        with Documentation
            {Description = "Fixed conversion mode is in effect."}       
}with Documentation {EmbeddedType = true}; 

//  2.2.9
// 2.2.9.1.1.3   Server Graphics Update PDU (TS_GRAPHICS_PDU)
message TSGraphicsPdu[TSUDSCSec1EncryptionLevel EncryptionLevel, TSUDSCSec1EncryptionMethod EncryptionMethod]
{
    optional (
              ([|EncryptionLevel == TSUDSCSec1EncryptionLevel.EncryptionLevelLow|] BasicSecurityHeader) |
              ([|EncryptionMethod in {TSUDSCSec1EncryptionMethod.EncryptionMethod40Bit,
                                      TSUDSCSec1EncryptionMethod.EncryptionMethod128Bit,
                                      TSUDSCSec1EncryptionMethod.EncryptionMethod56Bit}|] NonFipsSecurityHeader) |
              ([|(EncryptionMethod == TSUDSCSec1EncryptionMethod.EncryptionMethodFips)|] FipsSecurityHeader)
             ) SecurityHeader
        with Documentation
           {Description = "Optional security header. The presence and format of the security header depends on the Encryption Level and Encryption Method selected by the server (sections  and ). If the Encryption Level selected by the server is greater than ENCRYPTION_LEVEL_NONE (0) and the Encryption Method selected by the server is greater than ENCRYPTION_METHOD_NONE (0), then this field MUST contain one of the following headers:"};
  
    array<TSGraphicsUpdate> SlowPathGraphicsUpdates
        with Documentation
           {Description = "A variable-length array of Slow-Path Graphics Updates to be processed by the client ."};
           
    override string ToString()
    {
        string summary = "Server Graphics Update PDU";
        if (SlowPathGraphicsUpdates.Count > 0)
        {
            summary += ", SlowPathGraphicsUpdates: ";
            if (SlowPathGraphicsUpdates.Count > 1)
            {
                summary += "[";
            }
            int cnt = 0;
            foreach (var up in SlowPathGraphicsUpdates)
            {
                if (cnt > 0)
                {
                    summary += ", ";
                }
                if (up is TSUpdateBitmap)
                {
                    summary += "TSUpdateBitmap";
                }
                else if (up is TSUpdatePalette)
                {
                    summary += "TSUpdatePalette";
                }
                else if (up is TSUpdateSync)
                {
                    summary += "TSUpdateSync";
                }
                else if (up is UpdateOrdersPDUData)
                {
                    summary += "UpdateOrdersPDUData";
                }
                cnt++;
            }
            if (cnt > 1)
            {
                summary += "]";
            }
        }
        return summary;
    }
}
with Documentation
       {Applicability = "2.2.9.1.1.3",
        Description = "The Slow-Path Graphics Update PDU is used to transmit graphics updates from server to client."};

// 2.2.9.1.1.3.1   Slow-Path Graphics Update (TS_GRAPHICS_UPDATE)
pattern TSGraphicsUpdate = TSUpdateBitmap | TSUpdatePalette | TSUpdateSync | UpdateOrdersPDUData;

pattern TSGraphicsUpdateUpdateType = enum ushort
{
    UpdateTypeOrders = 0x0000
      with Documentation
             {Description = "Indicates an Orders Update (see [MS-RDPEGDI] section )."},
    UpdateTypeBitmap = 0x0001
      with Documentation
             {Description = "Indicates a Bitmap Graphics Update (see section )."},
    UpdateTypePalette = 0x0002
      with Documentation {Description = "Indicates a Palette Update (see section )."},
    UpdateTypeSynchronize = 0x0003
      with Documentation
             {Description = "Indicates a Synchronize Update (see section )."}
} with Documentation {EmbeddedType = true};

// 2.2.9.1.1.3.1.1   Palette Update (TS_UPDATE_PALETTE)
type TSUpdatePalette
{
    TSShareDataHeader ShareDataHeader
        with Documentation
           {Description = "Share Data Header containing information about the packet. The type subfield of the pduType field of the Share Control Header MUST be set to PDUTYPE_DATAPDU (7). The pduType2 field of the Share Data Header MUST be set to PDUTYPE2_UPDATE (2)."};
  
    TSUpdatePaletteData PaletteData
        with Documentation
           {Description = "The actual palette update data, as specified in section ."};
}
with Documentation
       {Applicability = "2.2.9.1.1.3.1.1",
        Description = "The TS_UPDATE_PALETTE structure contains global palette information that covers the entire session\'s palette (see [T128] section 8.18.6). Only 256-color palettes are sent in this update."};

// 2.2.9.1.1.3.1.1.1   Palette Update Data (TS_UPDATE_PALETTE_DATA)
type TSUpdatePaletteData
{
    (TSGraphicsUpdateUpdateType where value == TSGraphicsUpdateUpdateType.UpdateTypePalette) UpdateType
        with Documentation
           {Description = "A 16-bit, unsigned integer. The update type. This field MUST be set to UPDATETYPE_PALETTE (0x0002)."};
  
    ushort Pad2Octets
        with Documentation
           {Description = "A 16-bit, unsigned integer. Padding. Values in this field MUST be ignored."};
  
    uint NumberColors where ValidationCheckValue(value == 256, null, true, ReferenceType.Type, "RDPBCGR", "NumberColors", "TSUpdatePaletteData", 256, value)
        with Documentation
           {Description = "A 32-bit, unsigned integer. The number of RGB triplets in the paletteData field. This field MUST be set to 256 (the number of entries in an 8 bpp palette)."};
  
    array<TSPaletteEntry> PaletteEntries
        with Documentation
           {Description = "An array of palette entries in RGB triplet format packed on byte boundaries. The number of triplet entries is given by the numberColors field."},
           BinaryEncoding{Length = NumberColors};
}
with Documentation
       {Applicability = "2.2.9.1.1.3.1.1.1",
        Description = "The TS_UPDATE_PALETTE_DATA encapsulates the palette data that defines a Palette Update."};
        
// 2.2.9.1.1.3.1.1.2   RGB Palette Entry (TS_PALETTE_ENTRY)
type TSPaletteEntry
{
    byte Red
        with Documentation
           {Description = "An 8-bit, unsigned integer. The red RGB color component."};
  
    byte Green
        with Documentation
           {Description = "An 8-bit, unsigned integer. The green RGB color component."};
  
    byte Blue
        with Documentation
           {Description = "An 8-bit, unsigned integer. The blue RGB color component."};
}
with Documentation
       {Applicability = "2.2.9.1.1.3.1.1.2",
        Description = "The TS_PALETTE_ENTRY structure is used to express the red, green, and blue components necessary to reproduce a color in the additive RGB space."};

// 2.2.9.1.1.3.1.2   Bitmap Update (TS_UPDATE_BITMAP)
type TSUpdateBitmap
{
  TSShareDataHeader ShareDataHeader
    with Documentation
           {Description = "Share Data Header containing information about the packet. The type subfield of the pduType field of the Share Control Header MUST be set to PDUTYPE_DATAPDU (7). The pduType2 field of the Share Data Header MUST be set to PDUTYPE2_UPDATE (2)."};
  
  TSUpdateBitmapData BitmapData
    with Documentation
           {Description = "The actual bitmap update data, as specified in section ."};
}
with Documentation
       {Applicability = "2.2.9.1.1.3.1.2",
        Description = "The TS_UPDATE_BITMAP structure contains one or more rectangular clippings taken from the server-side screen frame buffer (see [T128] section 8.17)."};

// 2.2.9.1.1.3.1.2.1   Bitmap Update Data (TS_UPDATE_BITMAP_DATA)
type TSUpdateBitmapData
{
    (TSGraphicsUpdateUpdateType where value == TSGraphicsUpdateUpdateType.UpdateTypeBitmap) UpdateType
        with Documentation
           {Description = "A 16-bit, unsigned integer. The update type. This field MUST be set to UPDATETYPE_BITMAP (0x0001)."};
  
    ushort NumberRectangles
        with Documentation
           {Description = "A 16-bit, unsigned integer. The number of screen rectangles present in the rectangles field."};
  
    array<TSBitmapData> Rectangles
        with Documentation
           {Description = "Variable-length array of TS_BITMAP_DATA structures, each of which contains a rectangular clipping taken from the server-side screen frame buffer. The number of screen clippings in the array is specified by the numberRectangles field."},
           BinaryEncoding{Length = (NumberRectangles)};
}
with Documentation
       {Applicability = "2.2.9.1.1.3.1.2.1",
        Description = "The TS_UPDATE_BITMAP_DATA structure encapsulates the bitmap data that defines a Bitmap Update."};

// 2.2.9.1.1.3.1.2.2   Bitmap Data (TS_BITMAP_DATA)
pattern TSBitmapDataFlags = flags ushort
{
    BitmapCompression = 0x0001
      with Documentation
             {Description = "Indicates that the bitmap data is compressed. The bitmapComprHdr field MUST be present if the NO_BITMAP_COMPRESSION_HDR (0x0400) flag is not set."},
    NOBitmapCompressionHdr = 0x0400
      with Documentation
             {Description = "Indicates that the bitmapComprHdr field is not present (removed for bandwidth efficiency to save 8 bytes)."}
} with Documentation {EmbeddedType = true};
  
// 2.2.9.1.1.3.1.2.2   Bitmap Data (TS_BITMAP_DATA)
type TSBitmapData
{
    ushort DestLeft
        with Documentation
           {Description = "A 16-bit, unsigned integer. Left bound of the rectangle."};
  
    ushort DestTop
        with Documentation
           {Description = "A 16-bit, unsigned integer. Top bound of the rectangle."};
  
    ushort DestRight
        with Documentation
           {Description = "A 16-bit, unsigned integer. Inclusive right bound of the rectangle."};
  
    ushort DestBottom
        with Documentation
           {Description = "A 16-bit, unsigned integer. Inclusive bottom bound of the rectangle."};
  
    ushort Width
        with Documentation
           {Description = "A 16-bit, unsigned integer. The width of the rectangle."};
  
    ushort Height
        with Documentation
           {Description = "A 16-bit, unsigned integer. The height of the rectangle."};
  
    ushort BitsPerPixel
        with Documentation
           {Description = "A 16-bit, unsigned integer. The color depth of the rectangle data in bits-per-pixel."};
  
    TSBitmapDataFlags Flags
        with Documentation
           {Description = "A 16-bit, unsigned integer. The flags describing the format of the bitmap data in the bitmapDataStream field."};
  
    ushort BitmapLength
        with Documentation
           {Description = "A 16-bit, unsigned integer. The size in bytes of the data in the bitmapComprHdr and bitmapDataStream fields."};
  
    optional [|(Flags & TSBitmapDataFlags.BitmapCompression) == TSBitmapDataFlags.BitmapCompression && (Flags & TSBitmapDataFlags.NOBitmapCompressionHdr) != TSBitmapDataFlags.NOBitmapCompressionHdr|] TSCDHeader BitmapComprHdr
        with Documentation
           {Description = "Optional Compressed Data Header structure specifying the bitmap data in the bitmapDataStream. This field MUST be present if the BITMAP_COMPRESSION (0x0001) flag is present in the Flags field, but the NO_BITMAP_COMPRESSION_HDR (0x0400) flag is not."};
  
    binary BitmapDataStream
        with Documentation
           {Description = "A variable-length array of bytes describing a bitmap image. Bitmap data is either compressed or uncompressed, depending on whether the BITMAP_COMPRESSION flag is present in the Flags field. Uncompressed bitmap data is formatted as a bottom-up, left-to-right series of pixels. Each pixel is a whole number of bytes. Each row contains a multiple of four bytes (including up to three bytes of padding, as necessary). Compressed bitmaps not in 32 bpp format are compressed using Interleaved RLE and encapsulated in an RLE Compressed Bitmap Stream structure, while compressed bitmaps at a color depth of 32 bpp are compressed using RDP 6.0 Bitmap Compression and stored inside an RDP 6.0 Bitmap Compressed Stream structure ([MS-RDPEGDI] section )."},
           BinaryEncoding{Length = BitmapComprHdr == nothing ? (BitmapLength) : ((BitmapLength - 8))};
}
with Documentation
       {Applicability = "2.2.9.1.1.3.1.2.2",
        Description = "The TS_BITMAP_DATA structure wraps the bitmap data for a screen area rectangle containing a clipping taken from the server-side screen frame buffer."};

// 2.2.9.1.1.3.1.2.3   Compressed Data Header (TS_CD_HEADER)
type TSCDHeader
{
    ushort CBCompFirstRowSize where ValidationCheckZero(value == 0x0000, null, true, ReferenceType.Type, "RDPBCGR", "CBCompFirstRowSize", "TSCDHeader", value)
        with Documentation
           {Description = "A 16-bit, unsigned integer. The field MUST be set to 0x0000."};
  
    ushort CBCompMainBodySize
        with Documentation
           {Description = "A 16-bit, unsigned integer. The size in bytes of the compressed bitmap data (which follows this header)."};
  
    ushort CBScanWidth
        with Documentation
           {Description = "A 16-bit, unsigned integer. The width of the bitmap (which follows this header) in pixels (this value MUST be divisible by 4)."};
  
    ushort CBUncompressedSize
        with Documentation
           {Description = "A 16-bit, unsigned integer. The size in bytes of the bitmap data (which follows this header) after it has been decompressed."};
}
with Documentation
       {Applicability = "2.2.9.1.1.3.1.2.3",
        Description = "The TS_CD_HEADER structure is used to describe compressed bitmap data."};

// 2.2.9.1.1.3.1.2.4   RLE Compressed Bitmap Stream (RLE_BITMAP_STREAM)
type RleBitmapStream[uint Length]
{
    RleBitmapStreamRleCompressedBitmapStream RleCompressedBitmapStream
        with Documentation
           {Description = "An array of compression codes describing compressed structures in the bitmap."},
           BinaryEncoding{Length = Length};
}
with Documentation
       {Applicability = "2.2.9.1.1.3.1.2.4",
        Description = "The RLE_BITMAP_STREAM structure contains a stream of bitmap data compressed using Interleaved Run-Length Encoding (RLE). Bitmap data compressed by the server MUST follow a Compressed Data Header structure unless the exclusion of this header has been specified in the General Capability Set."};

// 2.2.9.1.1.3.1.2.4   RLE Compressed Bitmap Stream (RLE_BITMAP_STREAM)
pattern RleBitmapStreamRleCompressedBitmapStream = enum binary
{
    RegularBGRun = $[00]
      with Documentation
             {Description = "The compression order encodes a regular-form background run. The run length is stored in the five low-order bits of the order header byte. If this value is zero, then the run length is encoded in the byte following the order header and MUST be incremented by 32 to give the final value."},
    MegaMegaBGRun = $[F0]
      with Documentation
             {Description = "The compression order encodes a MEGA_MEGA background run. The run length is stored in the two bytes following the order header (in little-endian format)."}
} with Documentation {EmbeddedType = true};
       
// 2.2.9.1.1.3.1.3   Synchronize Update (TS_UPDATE_SYNC)
type TSUpdateSync
{
    TSShareDataHeader ShareDataHeader
        with Documentation
           {Description = "Share Data Header containing information about the packet. The type subfield of the pduType field of the Share Control Header MUST be set to PDUTYPE_DATAPDU (7). The pduType2 field of the Share Data Header MUST be set to PDUTYPE2_UPDATE (2)."};
  
    (TSGraphicsUpdateUpdateType where value == TSGraphicsUpdateUpdateType.UpdateTypeSynchronize) UpdateType
        with Documentation
           {Description = "A 16-bit, unsigned integer. The update type. This field MUST be set to UPDATETYPE_SYNCHRONIZE (0x0003)."};
  
    ushort Pad2Octets
        with Documentation
           {Description = "A 16-bit, unsigned integer. Padding. Values in this field MUST be ignored."};
}
with Documentation
       {Applicability = "2.2.9.1.1.3.1.3",
        Description = "The TS_UPDATE_SYNC structure is an artifact of the T.128 protocol (see [T128] section 8.6.2) and SHOULD be ignored."};

// 2.2.9.1.1.4   Server Pointer Update PDU (TS_POINTER_PDU)
message TSPointerPdu[TSUDSCSec1EncryptionLevel EncryptionLevel, TSUDSCSec1EncryptionMethod EncryptionMethod]
{
    optional (
              ([|EncryptionLevel == TSUDSCSec1EncryptionLevel.EncryptionLevelLow|] BasicSecurityHeader) |
              ([|EncryptionMethod in {TSUDSCSec1EncryptionMethod.EncryptionMethod40Bit,
                                      TSUDSCSec1EncryptionMethod.EncryptionMethod128Bit,
                                      TSUDSCSec1EncryptionMethod.EncryptionMethod56Bit}|] NonFipsSecurityHeader) |
              ([|(EncryptionMethod == TSUDSCSec1EncryptionMethod.EncryptionMethodFips)|] FipsSecurityHeader)
             ) SecurityHeader
        with Documentation
           {Description = "Optional security header. The presence and format of the security header depends on the Encryption Level and Encryption Method selected by the server (sections  and ). If the Encryption Level selected by the server is greater than ENCRYPTION_LEVEL_NONE (0) and the Encryption Method selected by the server is greater than ENCRYPTION_METHOD_NONE (0), then this field MUST contain one of the following headers:"};
  
    TSShareDataHeader ShareDataHeader
        with Documentation
           {Description = "Share Data Header containing information about the packet. The type subfield of the pduType field of the Share Control Header MUST be set to PDUTYPE_DATAPDU (7). The pduType2 field of the Share Data Header MUST be set to PDUTYPE2_POINTER (27)."};
  
    TSPointerPduMessageType MessageType
        with Documentation
           {Description = "A 16-bit, unsigned integer. Type of pointer update."};
  
    ushort Pad2Octets
        with Documentation
           {Description = "A 16-bit, unsigned integer. Padding. Values in this field MUST be ignored."};
  
    ([|MessageType == TSPointerPduMessageType.TSPtrmsgtypeSystem|] TSSystemPointerAttribute |
    [|MessageType == TSPointerPduMessageType.TSPtrmsgtypePosition|] TSPointerPosAttribute |
    [|MessageType == TSPointerPduMessageType.TSPtrmsgtypeColor|] TSColorPointerAttribute |
    [|MessageType == TSPointerPduMessageType.TSPtrmsgtypeCached|] TSCachedPointerAttribute |
    [|MessageType == TSPointerPduMessageType.TSPtrmsgtypePointer|] TSPointerAttribute)
        PointerAttributeData
            with Documentation
                {Description = "A Pointer Position Update, System Pointer Update, Color Pointer Update, New Pointer Update, or Cached Pointer Update. The actual contents of the slow-path pointer update."};
                
    override string ToString()
    {
        return "Server Pointer Update PDU, MessageType: " + EnumToString(MessageType, "RDPBCGR.TSPointerPduMessageType");
    }
}
with Documentation
       {Applicability = "2.2.9.1.1.4",
        Description = "The Pointer Update PDU is sent from server to client and is used to convey pointer information, including pointers\' bitmap images, use of system or hidden pointers, use of cached cursors and position updates."};

// 2.2.9.1.1.4   Server Pointer Update PDU (TS_POINTER_PDU)
pattern TSPointerPduMessageType = enum ushort
{
    TSPtrmsgtypeSystem = 0x0001
      with Documentation {Description = "Indicates a System Pointer Update."},
    TSPtrmsgtypePosition = 0x0003
      with Documentation {Description = "Indicates a Pointer Position Update."},
    TSPtrmsgtypeColor = 0x0006
      with Documentation {Description = "Indicates a Color Pointer Update."},
    TSPtrmsgtypeCached = 0x0007
      with Documentation {Description = "Indicates a Cached Pointer Update."},
    TSPtrmsgtypePointer = 0x0008
      with Documentation {Description = "Indicates a New Pointer Update."}
} with Documentation {EmbeddedType = true};
        
// 2.2.9.1.1.4.1   Point (TS_POINT16)
type TSPoint16
{
    ushort XPos
        with Documentation
           {Description = "A 16-bit, unsigned integer. The x-coordinate relative to the top-left corner of the server\'s desktop."};
  
    ushort YPos
        with Documentation
           {Description = "A 16-bit, unsigned integer. The y-coordinate relative to the top-left corner of the server\'s desktop."};
}
with Documentation
       {Applicability = "2.2.9.1.1.4.1",
        Description = "The TS_POINT16 structure specifies a point relative to the top-left corner of the server\'s desktop."};

// 2.2.9.1.1.4.2   Pointer Position Update (TS_POINTERPOSATTRIBUTE)
type TSPointerPosAttribute
{
    TSPoint16 Position
        with Documentation
           {Description = "Point (section 2.2.9.1.1.4.1) structure containing the new x-coordinates and y-coordinates of the pointer."};
}
with Documentation
       {Applicability = "2.2.9.1.1.4.2",
        Description = "The TS_POINTERPOSATTRIBUTE structure is used to indicate that the client pointer MUST be moved to the specified position relative to the top-left corner of the server's desktop (see [T128] section 8.14.4)."};

// 2.2.9.1.1.4.3   System Pointer Update (TS_SYSTEMPOINTERATTRIBUTE)
pattern TSSystemPointerAttributeSystemPointerType = enum uint
{
    SysptrNull = 0x00000000
      with Documentation {Description = "The hidden pointer."},
    SysptrDefault = 0x00007F00
      with Documentation {Description = "The default system pointer."}
} with Documentation {EmbeddedType = true};
        
// 2.2.9.1.1.4.3   System Pointer Update (TS_SYSTEMPOINTERATTRIBUTE)
type TSSystemPointerAttribute
{
    TSSystemPointerAttributeSystemPointerType SystemPointerType
        with Documentation
           {Description = "A 32-bit, unsigned integer. The type of system pointer."};
}
with Documentation
       {Applicability = "2.2.9.1.1.4.3",
        Description = "The TS_SYSTEMPOINTERATTRIBUTE structure is used to hide the pointer or to set its shape to the operating system default (see [T128] section 8.14.1)."};
        
// 2.2.9.1.1.4.4   Color Pointer Update (TS_COLORPOINTERATTRIBUTE)
type TSColorPointerAttribute
{
    ushort CacheIndex
        with Documentation
           {Description = "A 16-bit, unsigned integer. The zero-based cache entry in the pointer cache in which to store the pointer image. The number of cache entries is specified using the Pointer Capability Set."};
  
    TSPoint16 HotSpot
        with Documentation
           {Description = "Point structure containing the x-coordinates and y-coordinates of the pointer hotspot."};
  
    ushort Width
        with Documentation
           {Description = "A 16-bit, unsigned integer. The width of the pointer in pixels. The maximum allowed pointer width is 96 pixels if the client indicated support for large pointers by setting the LARGE_POINTER_FLAG (0x00000001) in the Large Pointer Capability Set. If the LARGE_POINTER_FLAG was not set, the maximum allowed pointer width is 32 pixels."};
  
    ushort Height
        with Documentation
           {Description = "A 16-bit, unsigned integer. The height of the pointer in pixels. The maximum allowed pointer height is 96 pixels if the client indicated support for large pointers by setting the LARGE_POINTER_FLAG (0x00000001) in the Large Pointer Capability Set. If the LARGE_POINTER_FLAG was not set, the maximum allowed pointer height is 32 pixels."};
  
    ushort LengthAndMask
        with Documentation
           {Description = "A 16-bit, unsigned integer. The size in bytes of the andMaskData field."};
  
    ushort LengthXorMask
        with Documentation
           {Description = "A 16-bit, unsigned integer. The size in bytes of the xorMaskData field."};
  
    binary XorMaskData
        with Documentation
           {Description = "Variable number of bytes: Contains the 24-bpp, bottom-up XOR mask scan-line data. The XOR mask is padded to a 2-byte boundary for each encoded scan-line. For example, if a 3x3 pixel cursor is being sent, then each scan-line will consume 10 bytes (3 pixels per scan-line multiplied by 3 bytes per pixel, rounded up to the next even number of bytes)."},
           BinaryEncoding{Length = (LengthXorMask)};
  
    binary AndMaskData
        with Documentation
           {Description = "Variable number of bytes: Contains the 1-bpp, bottom-up AND mask scan-line data. The AND mask is padded to a 2-byte boundary for each encoded scan-line. For example, if a 7x7 pixel cursor is being sent, then each scan-line will consume 2 bytes (7 pixels per scan-line multiplied by 1 bpp, rounded up to the next even number of bytes)."},
           BinaryEncoding{Length = (LengthAndMask)};
  
    //TDI: In capture, there is extra data for field Pad
    optional byte Pad
        with Documentation
           {Description = "An 8-bit, unsigned integer. Padding. Values in this field MUST be ignored."};
}
with Documentation
       {Applicability = "2.2.9.1.1.4.4",
        Description = "The TS_COLORPOINTERATTRIBUTE structure represents a regular T.128 24 bpp color pointer, as specified in [T128] section 8.14.3. This pointer update is used for both monochrome and color pointers in RDP."};

// 2.2.9.1.1.4.5   New Pointer Update (TS_POINTERATTRIBUTE)
type TSPointerAttribute
{
    ushort XorBpp
        with Documentation
           {Description = "A 16-bit, unsigned integer. The color depth in bits-per-pixel of the XOR mask contained in the colorPtrAttr field."};
  
    TSColorPointerAttribute ColorPtrAttr
        with Documentation
           {Description = "Encapsulated Color Pointer Update structure which contains information about the pointer. The Color Pointer Update fields are all used, as specified in section ; however color XOR data is presented in the color depth described in the xorBpp field (for 8 bpp, each byte contains one palette index; for 4 bpp, there are two palette indices per byte)."};
}
with Documentation
       {Applicability = "2.2.9.1.1.4.5",
        Description = "The TSPointerAttribute structure is used to send pointer data at an arbitrary color depth. Support for the New Pointer Update is advertised in the Pointer Capability Set."};
        
// 2.2.9.1.1.4.6   Cached Pointer Update (TS_CACHEDPOINTERATTRIBUTE)
type TSCachedPointerAttribute
{
    ushort CacheIndex
        with Documentation
           {Description = "A 16-bit, unsigned integer. A zero-based cache entry containing the cache index of the cached pointer to which the client\'s pointer MUST be changed. The pointer data MUST have already been cached using either the Color Pointer Update or New Pointer Update."};
}
with Documentation
       {Applicability = "2.2.9.1.1.4.6",
        Description = "The TSCachedPointerAttribute structure is used to instruct the client to change the current pointer shape to one already present in the pointer cache."};

// 2.2.9.1.1.5   Server Play Sound PDU
message ServerPlaySoundPdu[TSUDSCSec1EncryptionLevel EncryptionLevel, TSUDSCSec1EncryptionMethod EncryptionMethod]
{
    optional (
              ([|EncryptionLevel == TSUDSCSec1EncryptionLevel.EncryptionLevelLow|] BasicSecurityHeader) |
              ([|EncryptionMethod in {TSUDSCSec1EncryptionMethod.EncryptionMethod40Bit,
                                      TSUDSCSec1EncryptionMethod.EncryptionMethod128Bit,
                                      TSUDSCSec1EncryptionMethod.EncryptionMethod56Bit}|] NonFipsSecurityHeader) |
              ([|(EncryptionMethod == TSUDSCSec1EncryptionMethod.EncryptionMethodFips)|] FipsSecurityHeader)
             ) SecurityHeader
        with Documentation
           {Description = "Optional security header. The presence and format of the security header depends on the Encryption Level and Encryption Method selected by the server (sections 5.3.2 and 2.2.1.4.3). If the Encryption Level selected by the server is greater than ENCRYPTION_LEVEL_NONE (0) and the Encryption Method selected by the server is greater than ENCRYPTION_METHOD_NONE (0), then this field MUST contain one of the following headers:"};
  
    TSPlaySoundPduData TSPlaySoundPduData
        with Documentation
           {Description = "The actual contents of the Play Sound PDU, as specified in section 2.2.9.1.1.5.1."};
           
    override string ToString()
    {
        return "Server Play Sound PDU";
    }
}
with Documentation
       {Applicability = "2.2.9.1.1.5",
        Description = "The Save Session Info PDU is used by the server to transmit session and user logon information back to the client after the user has logged on."};

// 2.2.9.1.1.5.1   Play Sound PDU Data (TS_PLAY_SOUND_PDU_DATA)
type TSPlaySoundPduData
{
    TSShareDataHeader ShareDataHeader
        with Documentation
           {Description = "Share Data Header containing information about the packet. The type subfield of the pduType field of the Share Control Header MUST be set to PDUTYPE_DATAPDU (7). The pduType2 field of the Share Data Header MUST be set to PDUTYPE2_PLAY_SOUND (34)."};
  
    uint Duration
        with Documentation
           {Description = "A 32-bit, unsigned integer. Duration of the beep the client MUST play."};
  
    uint Frequency
        with Documentation
           {Description = "A 32-bit, unsigned integer. Frequency of the beep the client MUST play."};
}
with Documentation
       {Applicability = "2.2.9.1.1.5.1",
        Description = "The TSPlaySoundPduData structure contains the contents of the Play Sound PDU, which is a Share Data Header and two fields."};

// 2.2.9.1.2   Server Fast-Path Update PDU (TS_FP_UPDATE_PDU)
message TSFPUpdatePdu
{
    TSFPUpdatePduFPOutputHeader FPOutputHeader
        with Documentation
           {Description = "An 8-bit, unsigned integer. One-byte, bit-packed header. This byte coincides with the first byte of the TPKT Header (see [T123] section 8). Two pieces of information are collapsed into this byte:"};
  
    byte Length1
        with Documentation
           {Description = "An 8-bit, unsigned integer. If the most significant bit of the length1 field is not set, then the size of the PDU is in the range 1 to 127 bytes and the length1 field contains the overall PDU length (the length2 field is not present in this case). However, if the most significant bit of the length1 field is set, then the overall PDU length is given by the low 7 bits of the length1 field concatenated with the 8 bits of the length2 field, in big-endian order (the length2 field contains the low-order bits)."};
  
    optional ([|(Length1 & 0x80) == 0x80|] byte) Length2
        with Documentation
           {Description = "An 8-bit, unsigned integer. If the most significant bit of the length1 field is not set, then the length2 field is not present. If the most significant bit of the length1 field is set, then the overall PDU length is given by the low 7 bits of the length1 field concatenated with the 8 bits of the length2 field, in big-endian order (the length2 field contains the low-order bits)."};
  
    optional TSFPFipSInfo FipsInformation
        with Documentation
           {Description = "Optional FIPS header information, present when the Encryption Method selected by the server (sections  and ) is ENCRYPTION_METHOD_FIPS (0x00000010). The Fast-Path FIPS Information structure is specified in section ."};
  
    optional ([|(FPOutputHeader.secFlags & SecurityFlags.FASTPATH_OUTPUT_ENCRYPTED) == SecurityFlags.FASTPATH_OUTPUT_ENCRYPTED|] binary) DataSignature with BinaryEncoding{Length = 8},
        Documentation
           {Description = "MAC generated over the packet using one of the techniques specified in section  (the FASTPATH_OUTPUT_SECURE_CHECKSUM flag, which is set in the fpOutputHeader field, describes the method used to generate the signature). This field MUST be present if the FASTPATH_OUTPUT_ENCRYPTED flag is set in the fpOutputHeader field."};
  
    optional ([|(FPOutputHeader.secFlags & SecurityFlags.FASTPATH_OUTPUT_ENCRYPTED) == SecurityFlags.FASTPATH_OUTPUT_ENCRYPTED|] binary) EncryptedData;
    
    optional ([|(FPOutputHeader.secFlags & SecurityFlags.FASTPATH_OUTPUT_ENCRYPTED) != SecurityFlags.FASTPATH_OUTPUT_ENCRYPTED|] array<TSFPUpdate>) FPOutputUpdates
        with Documentation
           {Description = "An array of Fast-Path Update structures to be processed by the client."};
         
    override string ToString()
    {
        string summary = "Server Fast-Path Update PDU";
        if ((FPOutputHeader.secFlags & SecurityFlags.FASTPATH_OUTPUT_ENCRYPTED) == SecurityFlags.FASTPATH_OUTPUT_ENCRYPTED)
        {
            summary += ", Encrypted";
        }
        else
        {
            if ((FPOutputUpdates as array<TSFPUpdate>).Count > 0)
            {
                summary += ", FPOutputUpdates: ";
                if ((FPOutputUpdates as array<TSFPUpdate>).Count > 1)
                {
                    summary += "[";
                }
                int cnt = 0;
                foreach (var up in (FPOutputUpdates as array<TSFPUpdate>))
                {
                    if (cnt > 4)
                    {
                        summary += " ...";
                        break;
                    }
                    else if (cnt > 0)
                    {
                        summary += ", ";
                    }
                    if (up is TSFPUpdateOrders)
                    {
                        summary += "TSFPUpdateOrders";
                    }
                    else if (up is TSFPUpdatePalette)
                    {
                        summary += "TSFPUpdatePalette";
                    }
                    else if (up is TSFPUpdateBitmap)
                    {
                        summary += "TSFPUpdateBitmap";
                    }
                    else if (up is TSFPUpdateSynchronize)
                    {
                        summary += "TSFPUpdateSynchronize";
                    }
                    else if (up is TSFPPointerPosAttribute)
                    {
                        summary += "TSFPPointerPosAttribute";
                    }
                    else if (up is TSFPSystemPointerHiddenAttribute)
                    {
                        summary += "TSFPSystemPointerHiddenAttribute";
                    }
                    else if (up is TSFPSystemPointerDefaultAttribute)
                    {
                        summary += "TSFPSystemPointerDefaultAttribute";
                    }
                    else if (up is TSFPColorPointerAttribute)
                    {
                        summary += "TSFPColorPointerAttribute";
                    }
                    else if (up is TSFPPointerAttribute)
                    {
                        summary += "TSFPPointerAttribute";
                    }
                    else if (up is TSFPCachedPointerAttribute)
                    {
                        summary += "TSFPCachedPointerAttribute";
                    }
                    else if (up is TSFPSurfcmds)
                    {
                        summary += "TSFPSurfcmds";
                    }
                    cnt++;
                }
                if (cnt > 1)
                {
                    summary += "]";
                }
                var update = (FPOutputUpdates as array<TSFPUpdate>)[0];
                byte compression;
                switch (update)
                {
                    case d:TSFPUpdateOrders =>
                        compression = d.UpdateHeader.Compression;
                    case d:TSFPUpdatePalette =>
                        compression = d.UpdateHeader.Compression;
                    case d:TSFPUpdateBitmap =>
                        compression = d.UpdateHeader.Compression;
                    case d:TSFPUpdateSynchronize =>
                        compression = d.UpdateHeader.Compression;
                    case d:TSFPPointerPosAttribute =>
                        compression = d.UpdateHeader.Compression;
                    case d:TSFPSystemPointerHiddenAttribute =>
                        compression = d.UpdateHeader.Compression;
                    case d:TSFPSystemPointerDefaultAttribute =>
                        compression = d.UpdateHeader.Compression;
                    case d:TSFPColorPointerAttribute =>
                        compression = d.UpdateHeader.Compression;
                    case d:TSFPPointerAttribute =>
                        compression = d.UpdateHeader.Compression;
                    case d:TSFPCachedPointerAttribute =>
                        compression = d.UpdateHeader.Compression;
                    case d:TSFPSurfcmds =>
                        compression = d.UpdateHeader.Compression;
                    default =>
                        compression = 0;
                }
                if (compression == TSFPUpdateUpdateHeaderCompression.FastPathOutputCompressionUsed)
                {
                    summary += ", Compressed";
                }          
            }
        }
        int length = (Length2 is l:byte) ? ((((Length1 & 0x7F) as ushort) << 8) | (l as ushort)) : Length1;
        return summary + ", Length: " + length.ToString();
    }
}
with Documentation
       {Applicability = "2.2.9.1.2",
        Description = "Fast-path revises server output packets from the first byte with the goal of improving bandwidth. The TPKT Header ([T123] section 8), X.224 Class 0 Data TPDU ([X224] section 13.7), and MCS Send Data Indication ([T125] section 11.33) are replaced; the Security Header is collapsed into the fast-path output header; and the Share Data Header is replaced by a new fast-path format. The contents of the graphics and pointer updates (see sections  and ) are also changed to reduce their size, particularly by removing or reducing headers. Support for fast-path output is advertised in the General Capability Set."};
    
// 2.2.9.1.2   Server Fast-Path Update PDU (TS_FP_UPDATE_PDU)
pattern TSFPUpdatePduFPOutputHeaderAction = enum byte
{
    FASTPATH_OUTPUT_ACTION_FASTPATH = 0x0,
    
    FASTPATH_OUTPUT_ACTION_X224 = 0x3,
    
    ...
} with Documentation {EmbeddedType = true};
                
// 2.2.9.1.2   Server Fast-Path Update PDU (TS_FP_UPDATE_PDU)
pattern TSFPUpdatePduFPOutputHeaderEncryptionFlags = enum byte
{
    FastPathOutputSecureChecksum = 0x00
      with Documentation
             {Description = "Indicates that the MAC signature for the PDU was generated using the \"salted MAC generation\" technique (see section ). If this bit is not set, then the standard technique was used (see sections  and )."},
    FastPathOutputEncrypted = 0x02
      with Documentation
             {Description = "Indicates that the PDU contains an 8-byte MAC signature after the optional length2 field (that is, the dataSignature field is present), and the contents of the PDU are encrypted using the negotiated encryption package (see sections  and )."}
} with Documentation {EmbeddedType = true};

// flags pattern        
pattern SecurityFlags = flags byte
{
    FASTPATH_OUTPUT_SECURE_CHECKSUM = 0x01
        with Documentation {Description = "Indicates that the MAC signature for the PDU was generated using the salted MAC generation technique "},
    FASTPATH_OUTPUT_ENCRYPTED = 0x2
        with Documentation {Description = "Indicates that the PDU contains an 8-byte MAC signature after the optional length2 field (that is, the dataSignature field is present), and the contents of the PDU are encrypted using the negotiated encryption package"}
};
  
// 2.2.9.1.2   Server Fast-Path Update PDU (TS_FP_UPDATE_PDU)
type TSFPUpdatePduFPOutputHeader
{
    SecurityFlags secFlags with BinaryEncoding{Width = 2}; 

    byte Reserved with BinaryEncoding{Width = 4},
        Documentation
           {Description = "Unused bits reserved for future use. This bitfield MUST be set to 0."};
           
    TSFPUpdatePduFPOutputHeaderAction Action where ValidationCheckEnumValue(InRange<TSFPUpdatePduFPOutputHeaderAction>(value), null, false, ReferenceType.Type, "RDPBCGR", "Action", "TSFPUpdatePduFPOutputHeader", "0x0, 0x3", Utility.DecToHexFormat(1, value))
        with BinaryEncoding{Width = 2},
        Documentation
           {Description = "Code indicating whether the PDU is in fast-path or slow-path format."};
}
with Documentation
       {Description = "An 8-bit, unsigned integer. One-byte, bit-packed header. This byte coincides with the first byte of the TPKT Header (see [T123] section 8). Two pieces of information are collapsed into this byte:"},
        Documentation {EmbeddedType = true};
     
// 2.2.9.1.2.1   Fast-Path Update (TS_FP_UPDATE)
pattern TSFPUpdate =  TSFPUpdateOrders | TSFPUpdatePalette | TSFPUpdateBitmap | TSFPUpdateSynchronize | TSFPPointerPosAttribute | 
    TSFPSystemPointerHiddenAttribute | TSFPSystemPointerDefaultAttribute | TSFPColorPointerAttribute | TSFPPointerAttribute | TSFPCachedPointerAttribute | TSFPSurfcmds;         

// 2.2.9.1.2.1   Fast-Path Update (TS_FP_UPDATE)
type TSFPUpdateUpdateHeader
{
    TSFPUpdateUpdateHeaderCompression Compression where ValidationCheckCombinationValueIncludeZero(InRange<TSFPUpdateUpdateHeaderCompression>(value), null, false, ReferenceType.Type, "RDPBCGR", "Compression", "TSFPUpdateUpdateHeader", "0x2", value)
        with Documentation {Description = "Compression usage indication flags."},
        BinaryEncoding{Width = 2};

    TSFPUpdateUpdateHeaderFragmentation Fragmentation where ValidationCheckEnumValue(InRange<TSFPUpdateUpdateHeaderFragmentation>(value), null, false, ReferenceType.Type, "RDPBCGR", "Fragmentation", "TSFPUpdateUpdateHeader", "0x0, 0x1, 0x2, 0x3", value)
        with Documentation
           {Description = "Fast-path fragment sequencing information-support for fast-path fragmentation is specified in the Multifragment Update Capability Set."},
           BinaryEncoding{Width = 2};

    TSFPUpdateUpdateHeaderUpdateCode UpdateCode
        with Documentation {Description = "Type code of the update."},
        BinaryEncoding{Width = 4};
}
with Documentation
       {Description = "An 8-bit, unsigned integer. The TS_FP_UPDATE structure begins with a 1- byte, bit-packed update header field. Two pieces of information are collapsed into this byte:"},
     Documentation {EmbeddedType = true};
        
// 2.2.9.1.2.1   Fast-Path Update (TS_FP_UPDATE)
pattern TSFPUpdateUpdateHeaderUpdateCode = enum byte
{
    FastPathUpdatetypeOrders = 0x00
      with Documentation
             {Description = "Indicates a Fast-Path Orders Update (see [MS-RDPEGDI] section )."},
    FastPathUpdateTypeBitmap = 0x01
      with Documentation
             {Description = "Indicates a Fast-Path Bitmap Update (see section )."},
    FastPathUpdateTypePalette = 0x02
      with Documentation
             {Description = "Indicates a Fast-Path Palette Update (see section )."},
    FastPathUpdatetypeSynchronize = 0x03
      with Documentation
             {Description = "Indicates a Fast-Path Synchronize Update (see section )."},
    FastPathUpdatetypeSurfcmds = 0x04
      with Documentation
             {Description = "Indicates a Fast-Path Surface Commands Update (see section )."},
    FastPathEpdatetypePtrNull = 0x05
      with Documentation
             {Description = "Indicates a Fast-Path System Pointer Hidden Update (see section )."},
    FastPathUpdatetypePtrDefault = 0x06
      with Documentation
             {Description = "Indicates a Fast-Path System Pointer Default Update (see section )."},
    FastPathUpdateTypePtrPosition = 0x08
      with Documentation
             {Description = "Indicates a Fast-Path Pointer Position Update (see section )."},
    FastPathUpdateTypeColor = 0x09
      with Documentation
             {Description = "Indicates a Fast-Path Color Pointer Update (see section )."},
    FastPathUpdateTypeCached = 0x0A
      with Documentation
             {Description = "Indicates a Fast-Path Cached Pointer Update (see section )."},
    FastPathUpdateTypePointer = 0x0B
      with Documentation
             {Description = "Indicates a Fast-Path New Pointer Update (see section )."}
} with Documentation {EmbeddedType = true};
             
// 2.2.9.1.2.1   Fast-Path Update (TS_FP_UPDATE)
pattern TSFPUpdateUpdateHeaderFragmentation = enum byte
{
    FastPathFragmentSingle = 0x00
      with Documentation
             {Description = "The fast-path data in the updateData field is not part of a sequence of fragments."},
    FastPathFragmentLast = 0x01
      with Documentation
             {Description = "The fast-path data in the updateData field contains the last fragment in a sequence of fragments."},
    FastPathFragmentFirst = 0x02
      with Documentation
             {Description = "The fast-path data in the updateData field contains the first fragment in a sequence of fragments."},
    FastPathFragmentNext = 0x03
      with Documentation
             {Description = "The fast-path data in the updateData field contains the second or subsequent fragment in a sequence of fragments."},
    ...         
} with Documentation {EmbeddedType = true};

// 2.2.9.1.2.1   Fast-Path Update (TS_FP_UPDATE)
pattern TSFPUpdateUpdateHeaderCompression = flags byte
{
    FastPathOutputCompressionUsed = 0x2
      with Documentation
             {Description = "Indicates that the compressionFlags field is present."},
    ...
} with Documentation {EmbeddedType = true};

// 2.2.9.1.2.1.1   Fast-Path Palette Update (TS_FP_UPDATE_PALETTE)
type TSFPUpdatePalette
{
    TSFPUpdateUpdateHeader UpdateHeader where value.UpdateCode == TSFPUpdateUpdateHeaderUpdateCode.FastPathUpdateTypePalette
        with Documentation
           {Description = "An 8-bit, unsigned integer. The format of this field is the same as the updateHeader byte field, specified in the Fast-Path Update structure. The updateCode bitfield (4 bits in size) MUST be set to FASTPATH_UPDATETYPE_PALETTE (2)."};
  
    //  2.2.8.1.1.1.2
    (optional [|UpdateHeader.Compression == TSFPUpdateUpdateHeaderCompression.FastPathOutputCompressionUsed|] TSShareDataHeaderCompressedType) CompressionFlags
        with Documentation
           {Description = "An 8-bit, unsigned integer. The format of this optional field (as well as the possible values) is the same as the compressionFlags field specified in the Fast-Path Update structure."};
  
    ushort Size
        with Documentation
           {Description = "A 16-bit, unsigned integer. The format of this field (as well as the possible values) is the same as the size field specified in the Fast-Path Update structure."};
  
    optional [|CompressionFlags != nothing  && ((CompressionFlags as TSShareDataHeaderCompressedType).compressedFlags & TSShareDataHeaderCompressedFlags.PacketCompressed) == TSShareDataHeaderCompressedFlags.PacketCompressed |] binary CompressedData with BinaryEncoding{Length = Size};
       
    optional [|CompressedData is nothing|] TSUpdatePaletteData PaletteUpdateData
        with Documentation
           {Description = "Variable-length palette data. Both slow-path and fast-path utilize the same data format, a Palette Update Data structure, to represent this information."};
}
with Documentation
       {Applicability = "2.2.9.1.2.1.1",
        Description = "The TS_FP_UPDATE_PALETTE structure is the fast-path variant of the TS_UPDATE_PALETTE structure."};

// 2.2.9.1.2.1.2   Fast-Path Bitmap Update (TS_FP_UPDATE_BITMAP)
type TSFPUpdateBitmap
{
    TSFPUpdateUpdateHeader UpdateHeader where value.UpdateCode == TSFPUpdateUpdateHeaderUpdateCode.FastPathUpdateTypeBitmap
        with Documentation
           {Description = "An 8-bit, unsigned integer. The format of this field is the same as the updateHeader byte field specified in the Fast-Path Update structure. The updateCode bitfield (4 bits in size) MUST be set to FASTPATH_UPDATETYPE_BITMAP (1)."};
  
    //  2.2.8.1.1.1.2
    (optional [|UpdateHeader.Compression == TSFPUpdateUpdateHeaderCompression.FastPathOutputCompressionUsed|] TSShareDataHeaderCompressedType) CompressionFlags
        with Documentation
           {Description = "An 8-bit, unsigned integer. The format of this optional field (as well as the possible values) is the same as the compressionFlags field specified in the Fast-Path Update structure."};
  
    ushort Size
        with Documentation
           {Description = "A 16-bit, unsigned integer. The format of this field (as well as the possible values) is the same as the size field specified in the Fast-Path Update structure."};
  
    optional [|CompressionFlags != nothing  && ((CompressionFlags as TSShareDataHeaderCompressedType).compressedFlags & TSShareDataHeaderCompressedFlags.PacketCompressed) == TSShareDataHeaderCompressedFlags.PacketCompressed|] binary CompressedData with BinaryEncoding{Length = Size};
       
    optional [|CompressedData is nothing|] TSUpdateBitmapData BitmapUpdateData
        with Documentation
           {Description = "Variable-length bitmap data. Both slow-path and fast-path utilize the same data format, a Bitmap Update Data structure, to represent this information."};
}
with Documentation
       {Applicability = "2.2.9.1.2.1.2",
        Description = "The TS_FP_UPDATE_BITMAP structure is the fast-path variant of the TS_UPDATE_BITMAP structure."};

// 2.2.9.1.2.1.3   Fast-Path Synchronize Update (TS_FP_UPDATE_SYNCHRONIZE)
type TSFPUpdateSynchronize
{
    TSFPUpdateUpdateHeader UpdateHeader where value.UpdateCode == TSFPUpdateUpdateHeaderUpdateCode.FastPathUpdatetypeSynchronize
        with Documentation
           {Description = "An 8-bit, unsigned integer. The format of this field is the same as the updateHeader byte field described in the Fast-Path Update. The updateCode bitfield (4 bits in size) MUST be set to FASTPATH_UPDATETYPE_SYNCHRONIZE (3)."};
  
    //  2.2.8.1.1.1.2
    (optional [|UpdateHeader.Compression == TSFPUpdateUpdateHeaderCompression.FastPathOutputCompressionUsed|] TSShareDataHeaderCompressedType) CompressionFlags
        with Documentation
           {Description = "An 8-bit, unsigned integer. The format of this optional field (as well as the possible values) is the same as the compressionFlags field described in the Fast-Path Update structure."};
  
    ushort Size where ValidationCheckZero(value == 0, null, true, ReferenceType.Type, "RDPBCGR", "Size", "TSFPUpdateSynchronize", value)
        with Documentation
           {Description = "A 16-bit, unsigned integer. This field MUST be set to 0."};
}
with Documentation
       {Applicability = "2.2.9.1.2.1.3",
        Description = "The TS_FP_UPDATE_SYNCHRONIZE structure is the fast-path variant of the TS_UPDATE_SYNCHRONIZE_PDU_DATA structure."};

// 2.2.9.1.2.1.4   Fast-Path Pointer Position Update (TS_FP_POINTERPOSATTRIBUTE)
type TSFPPointerPosAttribute
{
    TSFPUpdateUpdateHeader UpdateHeader where value.UpdateCode == TSFPUpdateUpdateHeaderUpdateCode.FastPathUpdateTypePtrPosition 
        with Documentation
           {Description = "The format of this field is the same as the updateHeader byte field specified in the Fast-Path Update structure. The updateCode bitfield (4 bits in size) MUST be set to FASTPATH_UPDATETYPE_PTR_POSITION (8)."};
  
    //  2.2.8.1.1.1.2
    (optional [|UpdateHeader.Compression == TSFPUpdateUpdateHeaderCompression.FastPathOutputCompressionUsed|] TSShareDataHeaderCompressedType) CompressionFlags
        with Documentation
           {Description = "An 8-bit, unsigned integer. The format of this optional field (as well as the possible values) is the same as the compressionFlags field specified in the Fast-Path Update structure."};
  
    ushort Size
        with Documentation
           {Description = "A 16-bit, unsigned integer. The format of this field (as well as the possible values) is the same as the size field specified in the Fast-Path Update structure."};
  
    optional [|CompressionFlags != nothing  && ((CompressionFlags as TSShareDataHeaderCompressedType).compressedFlags & TSShareDataHeaderCompressedFlags.PacketCompressed) == TSShareDataHeaderCompressedFlags.PacketCompressed|] binary CompressedData with BinaryEncoding{Length = Size};
       
    optional [|CompressedData is nothing|] TSPointerPosAttribute PointerPositionUpdateData
        with Documentation
           {Description = "Pointer coordinates. Both slow-path and fast-path utilize the same data format, a Pointer Position Update structure, to represent this information."};          
}
with Documentation
       {Applicability = "2.2.9.1.2.1.4",
        Description = "The TS_FP_POINTERPOSATTRIBUTE structure is the fast-path variant of the TS_POINTERPOSATTRIBUTE structure (see section )."};

// 2.2.9.1.2.1.5   Fast-Path System Pointer Hidden Update (TS_FP_SYSTEMPOINTERHIDDENATTRIBUTE)
type TSFPSystemPointerHiddenAttribute
{
    TSFPUpdateUpdateHeader UpdateHeader where value.UpdateCode == TSFPUpdateUpdateHeaderUpdateCode.FastPathEpdatetypePtrNull 
        with Documentation
           {Description = "An 8-bit, unsigned integer. The format of this field is the same as the updateHeader byte field specified in the Fast-Path Update structure. The updateCode bitfield (4 bits in size) MUST be set to FASTPATH_UPDATETYPE_PTR_NULL (5)."};
  
    //  2.2.8.1.1.1.2
    (optional [|UpdateHeader.Compression == TSFPUpdateUpdateHeaderCompression.FastPathOutputCompressionUsed|] TSShareDataHeaderCompressedType) CompressionFlags
        with Documentation
           {Description = "An 8-bit, unsigned integer. The format of this optional field (as well as the possible values) is the same as the compressionFlags field specified in the Fast-Path Update structure."};
  
    ushort Size where ValidationCheckZero(value == 0, null, true, ReferenceType.Type, "RDPBCGR", "Size", "TSFPSystemPointerHiddenAttribute", value)
        with Documentation
           {Description = "A 16-bit, unsigned integer. This field MUST be set to 0."};       
}
with Documentation
       {Applicability = "2.2.9.1.2.1.5",
        Description = "The TS_FP_SYSTEMPOINTERHIDDENATTRIBUTE structure is used to hide the pointer."};

// 2.2.9.1.2.1.6   Fast-Path System Pointer Default Update (TS_FP_SYSTEMPOINTERDEFAULTATTRIBUTE)
type TSFPSystemPointerDefaultAttribute
{
    TSFPUpdateUpdateHeader UpdateHeader where value.UpdateCode == TSFPUpdateUpdateHeaderUpdateCode.FastPathUpdatetypePtrDefault 
        with Documentation
           {Description = "An 8-bit, unsigned integer. The format of this field is the same as the updateHeader byte field specified in the Fast-Path Update structure. The updateCode bitfield (4 bits in size) MUST be set to FASTPATH_UPDATETYPE_PTR_DEFAULT (6)."};
  
    //  2.2.8.1.1.1.2
    (optional [|UpdateHeader.Compression == TSFPUpdateUpdateHeaderCompression.FastPathOutputCompressionUsed|] TSShareDataHeaderCompressedType) CompressionFlags
        with Documentation
           {Description = "An 8-bit, unsigned integer. The format of this optional field (as well as the possible values) is the same as the compressionFlags field specified in the Fast-Path Update structure."};
  
    ushort Size where ValidationCheckZero(value == 0, null, true, ReferenceType.Type, "RDPBCGR", "Size", "TSFPSystemPointerDefaultAttribute", value)
        with Documentation
           {Description = "A 16-bit, unsigned integer. This field MUST be set to 0."};           
}
with Documentation
       {Applicability = "2.2.9.1.2.1.6",
        Description = "The TS_FP_SYSTEMPOINTERDEFAULTATTRIBUTE structure is used to set the shape of the pointer to the operating system default."};

// 2.2.9.1.2.1.7   Fast-Path Color Pointer Update (TS_FP_COLORPOINTERATTRIBUTE)
type TSFPColorPointerAttribute
{
    TSFPUpdateUpdateHeader UpdateHeader where value.UpdateCode == TSFPUpdateUpdateHeaderUpdateCode.FastPathUpdateTypeColor
        with Documentation
           {Description = "An 8-bit, unsigned integer. The format of this field is the same as the updateHeader byte field specified in the Fast-Path Update structure. The updateCode bitfield (4 bits in size) MUST be set to FASTPATH_UPDATETYPE_COLOR (9)."};
  
    //  2.2.8.1.1.1.2
    (optional [|UpdateHeader.Compression == TSFPUpdateUpdateHeaderCompression.FastPathOutputCompressionUsed|] TSShareDataHeaderCompressedType) CompressionFlags
        with Documentation
           {Description = "An 8-bit, unsigned integer. The format of this optional field (as well as the possible values) is the same as the compressionFlags field specified in the Fast-Path Update structure."};
  
    ushort Size
        with Documentation
           {Description = "A 16-bit, unsigned integer. The format of this field (as well as the possible values) is the same as the size field specified in the Fast-Path Update structure."};
  
    optional [|CompressionFlags != nothing  && ((CompressionFlags as TSShareDataHeaderCompressedType).compressedFlags & TSShareDataHeaderCompressedFlags.PacketCompressed) == TSShareDataHeaderCompressedFlags.PacketCompressed|] binary CompressedData with BinaryEncoding{Length = Size};
       
    optional [|CompressedData is nothing|] TSColorPointerAttribute ColorPointerUpdateData
        with Documentation
           {Description = "Color pointer data. Both slow-path and fast-path utilize the same data format, a Color Pointer Update structure, to represent this information."};
}
with Documentation
       {Applicability = "2.2.9.1.2.1.7",
        Description = "The TS_FP_COLORPOINTERATTRIBUTE structure is the fast-path variant of the TS_COLORPOINTERATTRIBUTE structure."};

// 2.2.9.1.2.1.8   Fast-Path New Pointer Update (TS_FP_POINTERATTRIBUTE)
type TSFPPointerAttribute
{
    TSFPUpdateUpdateHeader UpdateHeader where value.UpdateCode == TSFPUpdateUpdateHeaderUpdateCode.FastPathUpdateTypePointer
        with Documentation
           {Description = "An 8-bit, unsigned integer. The format of this field is the same as the updateHeader byte field specified in the Fast-Path Update structure. The updateCode bitfield (4 bits in size) MUST be set to FASTPATH_UPDATETYPE_POINTER (11)."};
  
    //  2.2.8.1.1.1.2
    (optional [|UpdateHeader.Compression == TSFPUpdateUpdateHeaderCompression.FastPathOutputCompressionUsed|] TSShareDataHeaderCompressedType) CompressionFlags
        with Documentation
           {Description = "An 8-bit, unsigned integer. The format of this optional field (as well as the possible values) is the same as the compressionFlags field specified in the Fast-Path Update structure."};
  
    ushort Size
        with Documentation
           {Description = "A 16-bit, unsigned integer. The format of this field (as well as the possible values) is the same as the size field specified in the Fast-Path Update structure."};
  
    optional [|CompressionFlags != nothing  && ((CompressionFlags as TSShareDataHeaderCompressedType).compressedFlags & TSShareDataHeaderCompressedFlags.PacketCompressed) == TSShareDataHeaderCompressedFlags.PacketCompressed|] binary CompressedData with BinaryEncoding{Length = Size};
       
    optional [|CompressedData is nothing|] TSPointerAttribute NewPointerUpdateData
        with Documentation
           {Description = "Color pointer data at arbitrary color depth. Both slow-path and fast-path utilize the same data format, a New Pointer Update structure, to represent this information."};
}
with Documentation
       {Applicability = "2.2.9.1.2.1.8",
        Description = "The TS_FP_POINTERATTRIBUTE structure is the fast-path variant of the TS_POINTERATTRIBUTE structure."};

// 2.2.9.1.2.1.9   Fast-Path Cached Pointer Update (TS_FP_CACHEDPOINTERATTRIBUTE)
type TSFPCachedPointerAttribute
{
    TSFPUpdateUpdateHeader UpdateHeader  where value.UpdateCode == TSFPUpdateUpdateHeaderUpdateCode.FastPathUpdateTypeCached 
        with Documentation
           {Description = "An 8-bit, unsigned integer. The format of this field is the same as the updateHeader byte field specified in the Fast-Path Update structure. The updateCode bitfield (4 bits in size) MUST be set to FASTPATH_UPDATETYPE_CACHED (10)."};
  
    //  2.2.8.1.1.1.2
    (optional [|UpdateHeader.Compression == TSFPUpdateUpdateHeaderCompression.FastPathOutputCompressionUsed|] TSShareDataHeaderCompressedType) CompressionFlags
        with Documentation
           {Description = "An 8-bit, unsigned integer. The format of this optional field (as well as the possible values) is the same as the compressionFlags field specified in the Fast-Path Update structure."};
  
    ushort Size
        with Documentation
           {Description = "A 16-bit, unsigned integer. The format of this field (as well as the possible values) is the same as the size field specified in the Fast-Path Update structure."};
  
    optional [|CompressionFlags != nothing  && ((CompressionFlags as TSShareDataHeaderCompressedType).compressedFlags & TSShareDataHeaderCompressedFlags.PacketCompressed) == TSShareDataHeaderCompressedFlags.PacketCompressed|] binary CompressedData with BinaryEncoding{Length = Size};
       
    optional [|CompressedData is nothing|] TSCachedPointerAttribute CachedPointerUpdateData
        with Documentation
           {Description = "Cached pointer data. Both slow-path and fast-path utilize the same data format, a Cached Pointer Update structure, to represent this information."};
}
with Documentation
       {Applicability = "2.2.9.1.2.1.9",
        Description = "The TS_FP_CACHEDPOINTERATTRIBUTE structure is the fast-path variant of the TS_CACHEDPOINTERATTRIBUTE structure."};

// 2.2.9.1.2.1.10   Fast-Path Surface Commands Update (TS_FP_SURFCMDS)
type TSFPSurfcmds
{
    TSFPUpdateUpdateHeader UpdateHeader where value.UpdateCode == TSFPUpdateUpdateHeaderUpdateCode.FastPathUpdatetypeSurfcmds 
        with Documentation
           {Description = "An 8-bit, unsigned integer. The format of this field is the same as the updateHeader byte field specified in the Fast-Path Update structure. The updateCode bitfield (4 bits in size) MUST be set to FASTPATH_UPDATETYPE_SURFCMDS (4)."};
  
    //  2.2.8.1.1.1.2
    optional ([|UpdateHeader.Compression == TSFPUpdateUpdateHeaderCompression.FastPathOutputCompressionUsed|] TSShareDataHeaderCompressedType) CompressionFlags
        with Documentation
           {Description = "An 8-bit, unsigned integer. The format of this optional field (as well as the possible values) is the same as the compressionFlags field specified in the Fast-Path Update structure."};
  
    ushort Size
        with Documentation
           {Description = "A 16-bit, unsigned integer. The format of this field (as well as the possible values) is the same as the size field specified in the Fast-Path Update structure."};
  
    optional [|CompressionFlags != nothing  && ((CompressionFlags as TSShareDataHeaderCompressedType).compressedFlags & TSShareDataHeaderCompressedFlags.PacketCompressed) == TSShareDataHeaderCompressedFlags.PacketCompressed|] binary CompressedData with BinaryEncoding{Length = Size};
       
    optional [|CompressedData is nothing|] array<TSSurfcmd> SurfaceCommands
        with Documentation
           {Description = "An array of Surface Command structures containing a collection of commands to be processed by the client."};
}
with Documentation
       {Applicability = "2.2.9.1.2.1.10",
        Description = "The TS_FP_SURFCMDS structure encapsulates one or more Surface Command structures."};

// 2.2.9.1.2.1.10.1   Surface Command (TS_SURFCMD)
type TSSurfcmd
{
    TSSurfcmdCmdType CmdType
        with Documentation
           {Description = "A 16-bit, unsigned integer. A. Surface Command type."};
  
    ([|CmdType == TSSurfcmdCmdType.CmdTypeSetSurfaceBits|] TSSurfcmdSetSurfBits |
    [|CmdType == TSSurfcmdCmdType.CmdTypeFrameMarker|] TSFrameMarker |
    [|CmdType == TSSurfcmdCmdType.CmdTypeStreamSurfaceBits|] TSSurfcmdStreamSurfBits) CmdData
        with Documentation
           {Description = "Variable-length data specific to the Surface Command."};
}
with Documentation
       {Applicability = "2.2.9.1.2.1.10.1",
        Description = "The TS_SURFCMD structure is used to specify the Surface Command type and to encapsulate the data for a Surface Command sent from a server to a client. All Surface Commands in section  conform to this structure."};


// 2.2.9.1.2.1.10.1   Surface Command (TS_SURFCMD)
pattern TSSurfcmdCmdType = enum ushort
{
    CmdTypeSetSurfaceBits = 0x0001
      with Documentation
             {Description = "Indicates a Set Surface Bits Command (section 2.2.9.2.1)."},
    CmdTypeFrameMarker = 0x0004
        with Documentation
             {Description = "Indicates a Frame Marker Command (section 2.2.9.2.3)."},
    CmdTypeStreamSurfaceBits = 0x0006
        with Documentation
             {Description = "Indicates a Stream Surface Bits Command (section 2.2.9.2.2)."}
} with Documentation {EmbeddedType = true};
        
// 2.2.9.2.1   Set Surface Bits Command (TS_SURFCMD_SET_SURF_BITS)
type TSSurfcmdSetSurfBits
{
    ushort DestLeft
        with Documentation
           {Description = "A 16-bit, unsigned integer. Left bound of the destination rectangle that will contain the decoded bitmap data."};
  
    ushort DestTop
        with Documentation
           {Description = "A 16-bit, unsigned integer. Top bound of the destination rectangle that will contain the decoded bitmap data."};
  
    ushort DestRight
        with Documentation
           {Description = "A 16-bit, unsigned integer. Exclusive right bound of the destination rectangle that will contain the decoded bitmap data."};
  
    ushort DestBottom
        with Documentation
           {Description = "A 16-bit, unsigned integer. Exclusive bottom bound of the destination rectangle that will contain the decoded bitmap data."};
  
    TSBitmapDataEX BitmapData
        with Documentation
           {Description = "An Extended Bitmap Data structure that contains an encoded bitmap image."};
}
with Documentation
       {Applicability = "2.2.9.2.1",
        Description = "The Set Surface Bits Command is used to transport encoded bitmap data destined for a rectangular region of the current target surface from an RDP server to an RDP client."};

// 2.2.9.2.1.1   Extended Bitmap Data (TS_BITMAP_DATA_EX)
type TSBitmapDataEX
{
    byte Bpp
        with Documentation
           {Description = "An 8-bit, unsigned integer. The color depth of the bitmap data in bits-per-pixel."};
  
    byte Reserved1
        with Documentation
           {Description = "An 8-bit, unsigned integer. This field is reserved for future use."};
  
    byte Reserved2
        with Documentation
           {Description = "An 8-bit, unsigned integer. This field is reserved for future use."};
  
    byte CodecID
        with Documentation
           {Description = "An 8-bit, unsigned integer. The client-assigned ID that identifies the bitmap codec that was used to encode the bitmap data. Bitmap codec parameters are exchanged in the Bitmap Codecs Capability Set. If this field is 0, then the bitmap data is not encoded and can be used without performing any decoding transformation."};
  
    ushort Width
        with Documentation
           {Description = "A 16-bit, unsigned integer. The width of the decoded bitmap image in pixels."};
  
    ushort Height
        with Documentation
           {Description = "A 16-bit, unsigned integer. The height of the decoded bitmap image in pixels."};
  
    uint BitmapDataLength
        with Documentation
           {Description = "A 32-bit, unsigned integer. The size in bytes of the bitmapData field."};
  
    ([|CodecID == 0x01|] RDPNSC.NSCODEC_BITMAP_STREAM[Width, Height] | binary | any) BitmapData 
        with BinaryEncoding{Length = BitmapDataLength},
             Documentation
                {Description = "A variable-length array of bytes containing bitmap data encoded using the codec identified by the ID in the codecID field."};
}
with Documentation
       {Applicability = "2.2.9.2.1.1",
        Description = "The TS_BITMAP_DATA_EX structure is used to encapsulate encoded bitmap data."};
        
// 2.2.9.2.2   Stream Surface Bits Command (TS_SURFCMD_STREAM_SURF_BITS)
type TSSurfcmdStreamSurfBits
{
    ushort DestLeft
        with Documentation
           {Description = "A 16-bit, unsigned integer. Left bound of the destination rectangle that will contain the decoded bitmap data."};
  
    ushort DestTop
        with Documentation
           {Description = "A 16-bit, unsigned integer. Top bound of the destination rectangle that will contain the decoded bitmap data."};
  
    ushort DestRight
        with Documentation
           {Description = "A 16-bit, unsigned integer. Exclusive right bound of the destination rectangle that will contain the decoded bitmap data."};
  
    ushort DestBottom
        with Documentation
           {Description = "A 16-bit, unsigned integer. Exclusive bottom bound of the destination rectangle that will contain the decoded bitmap data."};
  
    TSBitmapDataEX BitmapData
        with Documentation
           {Description = "An Extended Bitmap Data structure that contains an encoded bitmap image."};
}
with Documentation
       {Applicability = "2.2.9.2.2",
        Description = "The Stream Surface Bits Command is used to transport encoded bitmap data destined for a rectangular region of the current target surface from an RDP server to an RDP client."};

// 2.2.9.2.3   Frame Marker Command (TS_FRAME_MARKER)
pattern TSFrameMarkerFrameAction = enum ushort
{
    SurfaceCmdFrameactionBegin = 0x0000
      with Documentation {Description = "Indicates the start of a new frame."},
    SurfaceCmdFrameactionEnd = 0x0001
      with Documentation {Description = "Indicates the end of the current frame."}
} with Documentation {EmbeddedType = true};

// 2.2.9.2.3   Frame Marker Command (TS_FRAME_MARKER)
type TSFrameMarker
{
  TSFrameMarkerFrameAction FrameAction
    with Documentation
           {Description = "A 16-bit, unsigned integer. Identifies the beginning and end of a frame."};
  
  uint FrameId
    with Documentation
           {Description = "A 32-bit, unsigned integer. The ID identifying the frame."};
}
with Documentation
       {Applicability = "2.2.9.2.3",
        Description = "The Frame Marker Command is used to group multiple surface commands so that these commands can be processed and presented to the user as a single entity, a frame."};

// 2.2.10.1   Server Save Session Info PDU
message ServerSaveSessionInfoPdu[TSUDSCSec1EncryptionLevel EncryptionLevel, TSUDSCSec1EncryptionMethod EncryptionMethod]
{
    optional (
              ([|EncryptionLevel == TSUDSCSec1EncryptionLevel.EncryptionLevelLow|] BasicSecurityHeader) |
              ([|EncryptionMethod in {TSUDSCSec1EncryptionMethod.EncryptionMethod40Bit,
                                      TSUDSCSec1EncryptionMethod.EncryptionMethod128Bit,
                                      TSUDSCSec1EncryptionMethod.EncryptionMethod56Bit}|] NonFipsSecurityHeader) |
              ([|(EncryptionMethod == TSUDSCSec1EncryptionMethod.EncryptionMethodFips)|] FipsSecurityHeader)
             ) SecurityHeader
        with Documentation
           {Description = "Optional security header. The presence and format of the security header depends on the Encryption Level and Encryption Method selected by the server (sections  and ). If the Encryption Level selected by the server is greater than ENCRYPTION_LEVEL_NONE (0) and the Encryption Method selected by the server is greater than ENCRYPTION_METHOD_NONE (0), then this field MUST contain one of the following headers:"};
  
    TSSaveSessionInfoPduData SaveSessionInfoPduData
        with Documentation
           {Description = "The actual contents of the Save Session Info PDU, as specified in section ."};
           
    override string ToString()
    {
        return "Server Save Session Info PDU";
    }
}
with Documentation
       {Applicability = "2.2.10.1",
        Description = "The Save Session Info PDU is used by the server to transmit session and user logon information back to the client after the user has logged on."};

// 2.2.10.1.1   Save Session Info PDU Data (TS_SAVE_SESSION_INFO_PDU_DATA)
type TSSaveSessionInfoPduData
{
    TSShareDataHeader ShareDataHeader
        with Documentation
           {Description = "Share Data Header containing information about the packet. The type subfield of the pduType field of the Share Control Header MUST be set to PDUTYPE_DATAPDU (7). The pduType2 field of the Share Data Header MUST be set to PDUTYPE2_SAVE_SESSION_INFO (38)."};
  
    TSSaveSessionInfoPduDataInfoType InfoType
        with Documentation
           {Description = "A 32-bit, unsigned integer. The type of logon information."};
  
    ([|InfoType == TSSaveSessionInfoPduDataInfoType.InfotypeLogon|] TSLogonInfo // Logon Info Version 1
       | [|InfoType == TSSaveSessionInfoPduDataInfoType.InfotypeLogonLong|] TSLogonInfoVersion2 // Logon Info Version 2
       | [|InfoType == TSSaveSessionInfoPduDataInfoType.InfotypeLogonPlainnotify|] TSPlainNotify // Plain Notify
       | [|InfoType == TSSaveSessionInfoPduDataInfoType.InfotypeLogonExtendedInfo|] TS_LogonInfoExtended) InfoData // Logon Info Extended
        with Documentation
           {Description = "A Logon Info Version 1, Logon Info Version 2, Plain Notify, or Logon Info Extended structure. The type of data that follows depends on the value of the infoType field."};
}
with Documentation
       {
           Applicability = "2.2.10.1.1",
           Description = "The TS_SAVE_SESSION_INFO_PDU_DATA structure is a wrapper around different classes of user logon information."
       };

pattern TSSaveSessionInfoPduDataInfoType = enum uint
{
    InfotypeLogon = 0x00000000
        with Documentation
             {Description = "This is a notification that the user has logged on. The infoData field which follows contains a Logon Info Version 1 structure."},
    InfotypeLogonLong = 0x00000001
        with Documentation
             {Description = "This is a notification that the user has logged on. The infoData field which follows contains a Logon Info Version 2 structure. This type is supported by RDP 5.1, 5.2, 6.0, 6.1, and 7.07.0, 7.1, and 8.0 and SHOULD be used if the LONG_CREDENTIALS_SUPPORTED (0x00000004) flag is set in the General Capability Set."},
    InfotypeLogonPlainnotify = 0x00000002
        with Documentation
             {Description = "This is a notification that the user has logged on. The infoData field which follows contains a Plain Notify structure which contains 576 bytes of padding (see section ). This type is supported by RDP 5.1, 5.2, 6.0, 6.1, and 7.07.0, 7.1, and 8.0."},
    InfotypeLogonExtendedInfo = 0x00000003
        with Documentation
             {Description = "The infoData field which follows contains a Logon Info Extended structure. This type is supported by RDP 5.2, 6.0, 6.1, and 7.07.0, 7.1, and 8.0."}
} with Documentation {EmbeddedType = true};

// 2.2.10.1.1.1   Logon Info Version 1 (TS_LOGON_INFO)
// pattern String16 = string with BinaryEncoding{TextEncoding = TextEncoding.UTF16};
type TSLogonInfo
{
    uint CBDomain
        with Documentation
           {Description = "A 32-bit, unsigned integer. The size of the Unicode character data (including the mandatory null terminator) in bytes present in the fixed-length Domain field."};
    
    // WORKAROUND to decode binary first and display as string. Length of string is fixed.
    binary Domain
        with Documentation
           {Description = "An array of 26 Unicode characters: Null-terminated Unicode string containing the name of the domain to which the user is logged on. The length of the character data in bytes is given by the cbDomain field."},
         BinaryEncoding{Length = 52},
         DisplayInfo{ToText = BinaryToUnicode};
  
    uint CBUserName
        with Documentation
           {Description = "A 32-bit, unsigned integer. Size of the Unicode character data (including the mandatory null terminator) in bytes present in the fixed-length UserName field."};
    
    // WORKAROUND to decode binary first and display as string. Length of string is fixed.
    binary UserName
        with Documentation
           {Description = "An array of 256 Unicode characters: Null-terminated Unicode string containing the username which was used to log on. The length of the character data in bytes is given by the cbUserName field."},
         BinaryEncoding{Length = 512},
         DisplayInfo{ToText = BinaryToUnicode};
           
    uint SessionId
        with Documentation
           {Description = "A 32-bit, unsigned integer. Optional ID of the session on the remote server according to the server. Sent by RDP 5.0, 5.1, 5.2, 6.0, 6.1, and 7.07.0, 7.1, and 8.0 servers."};
}
with Documentation
       {Applicability = "2.2.10.1.1.1",
        Description = "TS_LOGON_INFO is a fixed-length structure that contains logon information intended for the client."};

// 2.2.10.1.1.2   Logon Info Version 2 (TS_LOGON_INFO_VERSION_2)
type TSLogonInfoVersion2
{
    TSLogonInfoVersion2Version Version
        with Documentation
           {Description = "A 16-bit, unsigned integer. The logon version."};
  
    uint Size
        with Documentation
           {Description = "A 32-bit, unsigned integer. The total size in bytes of this structure, excluding the Domain and UserName variable-length fields."};
  
    uint SessionId
        with Documentation
           {Description = "A 32-bit, unsigned integer. The ID of the session on the remote server according to the server."};
  
    uint CBDomain
        with Documentation
           {Description = "A 32-bit, unsigned integer. The size in bytes of the Domain field (including the mandatory null terminator)."};
  
    uint CBUserName
        with Documentation
           {Description = "A 32-bit, unsigned integer. The size in bytes of the UserName field (including the mandatory null terminator)."};
  
    binary Pad
        with Documentation
           {Description = "558 bytes. Padding. Values in this field MUST be ignored."},
        BinaryEncoding {Length = 558};
  
    // WORKAROUND to decode binary first and display as string, Length of string is fixed.
    binary Domain
        with Documentation
           {Description = "Variable-length null-terminated Unicode string containing the name of the domain to which the user is logged on. The size of this field in bytes is given by the cbDomain field."},
        BinaryEncoding {Length = CBDomain},
        DisplayInfo{ToText = BinaryToUnicode};
     
    // WORKAROUND to decode binary first and display as string, Length of string is fixed.      
    binary UserName
        with Documentation
           {Description = "Variable-length null-terminated Unicode string containing the user name which was used to log on. The size of this field in bytes is given by the cbUserName field."},
        BinaryEncoding {Length = CBUserName},
        DisplayInfo{ToText = BinaryToUnicode};
}
with Documentation
       {Applicability = "2.2.10.1.1.2",
        Description = "TS_LOGON_INFO_VERSION_2 is a variable-length structure that contains logon information intended for the client."};

pattern TSLogonInfoVersion2Version = enum ushort
{
    SaveSessionPduVersionOne = 0x0001
      with Documentation {Description = "Version 1"}
} with Documentation {EmbeddedType = true};

// 2.2.10.1.1.3   Plain Notify (TS_PLAIN_NOTIFY)
type TSPlainNotify
{
    binary Pad
        with Documentation
           {Description = "576 bytes. Padding. Values in this field MUST be ignored."},
        BinaryEncoding {Length = 576};
}
with Documentation
       {Applicability = "2.2.10.1.1.3",
        Description = "TS_PLAIN_NOTIFY is a fixed-length structure that contains 576 bytes of padding."};
        
// 2.2.10.1.1.4   Logon Info Extended (TS_LOGON_INFO_EXTENDED)
type TS_LogonInfoExtended
{
    ushort Length
        with Documentation
           {Description = "A 16-bit, unsigned integer. The total size in bytes of this structure, including the variable LogonFields field."};
  
    TSLogonInfoExtendedFieldsPresent FieldsPresent
        with Documentation
           {Description = "A 32-bit, unsigned integer. The flags indicating which fields are present in the LogonFields field."};
  
    TS_LogonInfoExtendedLogonFields[FieldsPresent] LogonFields
        with Documentation
           {Description = "Extended logon information fields encapsulated in Logon Info Field structures. The presence of an information field is indicated by the flags within the FieldsPresent field of the Logon Info Extended structure. The ordering of the fields is implicit and is as follows:"};
  
    binary Pad
        with Documentation
           {Description = "570 bytes. Padding. Values in this field MUST be ignored."},
        BinaryEncoding {Length = 570};
}
with Documentation
       {Applicability = "2.2.10.1.1.4",
        Description = "The TS_LOGON_INFO_EXTENDED structure contains RDP 5.2, 6.0, 6.1, and 7.07.0, 7.1, and 8.0 extended logon information."};
        
type TS_LogonInfoExtendedLogonFields[TSLogonInfoExtendedFieldsPresent FieldsPresent]
{
    optional [|(FieldsPresent & TSLogonInfoExtendedFieldsPresent.LogonExAutoReconnectCookie) > 0|] TSLogonInfoField[1] AutoReconnectCookieData;
    optional [|(FieldsPresent & TSLogonInfoExtendedFieldsPresent.LogonExLogonErrors) > 0|] TSLogonInfoField[2] LogonNotificationData;
} with Documentation {EmbeddedType = true};
        
// 2.2.10.1.1.4   Logon Info Extended (TS_LOGON_INFO_EXTENDED)
pattern TSLogonInfoExtendedFieldsPresent = flags uint
{
    LogonExAutoReconnectCookie = 0x00000001
        with Documentation
            {Description = "An auto-reconnect cookie field is present. The LogonFields field of the associated Logon Info structure MUST contain a Server Auto-Reconnect structure."},
    LogonExLogonErrors = 0x00000002
        with Documentation
            {Description = "A logon error field is present. The LogonFields field of the associated Logon Info MUST contain a Logon Errors Info structure."}
} with Documentation {EmbeddedType = true};

// 2.2.10.1.1.4.1   Logon Info Field (TS_LOGON_INFO_FIELD)
// ArcSCPrivatePacket or Error 
type TSLogonInfoField[uint fieldPresent]
{
    uint CBFieldData
        with Documentation
           {Description = "A 32-bit, unsigned integer. The size in bytes of the variable-length data in the FieldData field."};
  
    ([|fieldPresent == 1|] ArcSCPrivatePacket | [|fieldPresent == 2|] TSLogonErrorsInfo) FieldData
        with Documentation
           {Description = "Variable-length data conforming to the structure for the type given in the FieldsPresent field of the Logon Info Extended structure."};
}
with Documentation
       {Applicability = "2.2.10.1.1.4.1",
        Description = "The TS_LOGON_INFO_FIELD structure is used to encapsulate extended logon information field data of variable length."};
        
// 2.2.10.1.1.4.1.1   Logon Errors Info (TS_LOGON_ERRORS_INFO)
type TSLogonErrorsInfo
{    
    uint ErrorNotificationData;
    TSLogonErrorsInfoErrorNotificationType ErrorNotificationType where ValidationCheckEnumValue(InRange<TSLogonErrorsInfoErrorNotificationType>(value), null, false, ReferenceType.Type, "RDPBCGR", "ErrorNotificationType", "TSLogonErrorsInfo", "0x00000000, 0x00000001, 0x00000002, and 0x00000003", value);
}
with Documentation
       {Applicability = "2.2.10.1.1.4.1.1",
        Description = "The TS_LOGON_ERRORS_INFO structure contains information that describes a logon error notification."};

// 2.2.10.1.1.4.1.1   Logon Errors Info (TS_LOGON_ERRORS_INFO)
pattern TSLogonErrorsInfoErrorNotificationType = enum uint
{
    LogonFailedBadPassword = 0x00000000
        with Documentation
            {Description = "The logon process failed. The logon credentials which were supplied are invalid."},
    LogonFailedUpdatePassword = 0x00000001
        with Documentation
             {Description = "The logon process failed. The user cannot continue with the logon process until the password is changed."},
    LogonFailedOther = 0x00000002
        with Documentation
             {Description = "The logon process failed. The reason for the failure can be deduced from the ErrorNotificationData field."},
    LogonWarning = 0x00000003
        with Documentation
             {Description = "The user received a warning during the logon process. The reason for the warning can be deduced from the ErrorNotificationData field."},
    ...
} with Documentation {EmbeddedType = true};

// 2.2.10.2   Early User Authorization Result PDU
pattern AuthorizationResult = enum uint
{
    AuthzSuccess = 0x00000000
        with Documentation
            {Description = "The user has permission to access the server."},
    AuthzAccessDenied = 0x0000052E
        with Documentation
             {Description = "The user does not have permission to access the server."}
}with Documentation {EmbeddedType = true};

message EarlyUserAuthorizationResultPdu
{
    AuthorizationResult AuthorizationResult
        with Documentation
           {Description = "A 32-bit unsigned integer. Specifies the authorization result."};
    override string ToString()
    {
        return "EarlyUserAuthorizationResultPdu, AuthorizationResult: " + EnumToString(AuthorizationResult, "RDPBCGR.AuthorizationResult");
    }
}
with Documentation
       {Applicability = "2.2.10.2",
        Description = "The Early User Authorization Result PDU is sent from server to client and is used to convey authorization information to the client."};
        
// 2.2.11.1   Inclusive Rectangle (TS_RECTANGLE16)
type TSRectangle16
{
    ushort Left
        with Documentation
           {Description = "A 16-bit, unsigned integer. The leftmost bound of the rectangle."};
  
    ushort Top
        with Documentation
           {Description = "A 16-bit, unsigned integer. The upper bound of the rectangle."};
  
    ushort Right
        with Documentation
           {Description = "A 16-bit, unsigned integer. The rightmost bound of the rectangle."};
  
    ushort Bottom
        with Documentation
           {Description = "A 16-bit, unsigned integer. The lower bound of the rectangle."};
}
with Documentation
       {Applicability = "2.2.11.1",
        Description = "The TS_RECTANGLE16 structure describes a rectangle expressed in inclusive coordinates (the right and bottom coordinates are included in the rectangle bounds)."};

// 2.2.11.2   Client Refresh Rect PDU
message ClientRefreshRectPdu[TSUDSCSec1EncryptionLevel EncryptionLevel, TSUDSCSec1EncryptionMethod EncryptionMethod]
{
    optional (
              ([|EncryptionMethod in {TSUDSCSec1EncryptionMethod.EncryptionMethod40Bit,
                                      TSUDSCSec1EncryptionMethod.EncryptionMethod128Bit,
                                      TSUDSCSec1EncryptionMethod.EncryptionMethod56Bit}|] NonFipsSecurityHeader) |
              ([|(EncryptionMethod == TSUDSCSec1EncryptionMethod.EncryptionMethodFips)|] FipsSecurityHeader)
             ) SecurityHeader
        with Documentation
           {Description = "Optional security header. The presence and format of the security header depends on the Encryption Level and Encryption Method selected by the server (sections  and ). If the Encryption Level selected by the server is greater than ENCRYPTION_LEVEL_NONE (0) and the Encryption Method selected by the server is greater than ENCRYPTION_METHOD_NONE (0), then this field MUST contain one of the following headers:"};
  
    TSRefreshRectPdu RefreshRectPduData
        with Documentation
           {Description = "The actual contents of the Refresh Rect PDU, as specified in section ."};
           
    override string ToString()
    {
        return "Client Refresh Rect PDU";
    }
}
with Documentation
       {Applicability = "2.2.11.2",
        Description = "The Refresh Rect PDU allows the client to request that the server redraw one or more rectangles of the session screen area. The client can use it to repaint sections of the client window that were obscured by other windowed applications. Server support for this PDU is indicated in the General Capability Set."};

// 2.2.11.2.1   Refresh Rect PDU Data (TS_REFRESH_RECT_PDU)
type TSRefreshRectPdu
{
    TSShareDataHeader ShareDataHeader
        with Documentation
           {Description = "A Share Data Header containing information about the packet. The type subfield of the pduType field of the Share Control Header MUST be set to PDUTYPE_DATAPDU (7). The pduType2 field of the Share Data Header MUST be set to PDUTYPE2_REFRESH_RECT (33)."};
  
    byte NumberOfAreas
        with Documentation
           {Description = "An 8-bit, unsigned integer. The number of Inclusive Rectangle structures in the areasToRefresh field."};
  
    binary Pad3Octects
        with Documentation
           {Description = "A 3-element array of 8-bit, unsigned integer values. Padding. Values in this field MUST be ignored."},
        BinaryEncoding{Length = 3};
  
    array<TSRectangle16> AreasToRefresh
        with Documentation
           {Description = "An array of TS_RECTANGLE16 structures (variable number of bytes). Array of screen area Inclusive Rectangles to redraw. The number of rectangles is given by the numberOfAreas field."},
        BinaryEncoding{Length = (NumberOfAreas)};
}
with Documentation
       {Applicability = "2.2.11.2.1",
        Description = "The TS_REFRESH_RECT_PDU structure contains the contents of the Refresh Rect PDU, which is a Share Data Header and two fields."};

// 2.2.11.3   Client Suppress Output PDU
message ClientSuppressOutputPdu[TSUDSCSec1EncryptionLevel EncryptionLevel, TSUDSCSec1EncryptionMethod EncryptionMethod]
{
    optional (
              ([|EncryptionMethod in {TSUDSCSec1EncryptionMethod.EncryptionMethod40Bit,
                                      TSUDSCSec1EncryptionMethod.EncryptionMethod128Bit,
                                      TSUDSCSec1EncryptionMethod.EncryptionMethod56Bit}|] NonFipsSecurityHeader) |
              ([|(EncryptionMethod == TSUDSCSec1EncryptionMethod.EncryptionMethodFips)|] FipsSecurityHeader)
             ) SecurityHeader
        with Documentation
           {Description = "Optional security header. The presence and format of the security header depends on the Encryption Level and Encryption Method selected by the server (sections  and ). If the Encryption Level selected by the server is greater than ENCRYPTION_LEVEL_NONE (0) and the Encryption Method selected by the server is greater than ENCRYPTION_METHOD_NONE (0) then this field MUST contain one of the following headers:"};
  
    TSSuppressOutputPdu SuppressOutputPduData
        with Documentation
           {Description = "TS_SUPPRESS_OUTPUT_PDU (variable number of bytes):"};
           
    override string ToString()
    {
        return "Client Suppress Output PDU";
    }
}
with Documentation
       {Applicability = "2.2.11.3",
        Description = "The Suppress Output PDU is sent by the client to toggle all display updates from the server. This packet does not end the session or socket connection. Typically, a client sends this packet when its window is either minimized or restored. Server support for this PDU is indicated in the General Capability Set."};

// 2.2.11.3.1   Suppress Output PDU Data (TS_SUPPRESS_OUTPUT_PDU)
type TSSuppressOutputPdu
{
    TSShareDataHeader ShareDataHeader
        with Documentation
           {Description = "A Share Data Header containing information about the packet (see section ). The type subfield of the pduType field of the Share Control Header MUST be set to PDUTYPE_DATAPDU (7). The pduType2 field of the Share Data Header MUST be set to PDUTYPE2_SUPPRESS_OUTPUT (35)."};
  
    TSSuppressOutputPduAllowDisplayUpdates AllowDisplayUpdates
        with Documentation
           {Description = "An 8-bit, unsigned integer. Indicates whether the client wants to receive display updates from the server."};
  
    binary Pad3Octets
        with Documentation
           {Description = "A 3-element array of 8-bit, unsigned integer values. Padding. Values in this field MUST be ignored."},
        BinaryEncoding{Length = 3};
  
    optional [|AllowDisplayUpdates == TSSuppressOutputPduAllowDisplayUpdates.AllowDisplayUpdates|] TSRectangle16 DesktopRect
        with Documentation
           {Description = "An Inclusive Rectangle which contains the coordinates of the desktop rectangle if the allowDisplayUpdates field is set to ALLOW_DISPLAY_UPDATES (1). If the allowDisplayUpdates field is set to SUPPRESS_DISPLAY_UPDATES (0), this field MUST NOT be included in the PDU."};
}
with Documentation
       {Applicability = "2.2.11.3.1",
        Description = "The TS_SUPPRESS_OUTPUT_PDU structure contains the contents of the Suppress Output PDU, which is a Share Data Header and two fields."};


// 2.2.11.3.1   Suppress Output PDU Data (TS_SUPPRESS_OUTPUT_PDU)
pattern TSSuppressOutputPduAllowDisplayUpdates = enum byte
{
    SuppressDisplayUpdates = 0x00
        with Documentation {Description = "Turn off display updates from the server."},
    AllowDisplayUpdates = 0x01
        with Documentation {Description = "Turn on display updates from the server."}
} with Documentation {EmbeddedType = true};

// 2.2.12.1   Monitor Layout PDU
message MonitorLayoutPdu[TSUDSCSec1EncryptionLevel EncryptionLevel, TSUDSCSec1EncryptionMethod EncryptionMethod]
{
    optional (
              ([|EncryptionLevel == TSUDSCSec1EncryptionLevel.EncryptionLevelLow|] BasicSecurityHeader) |
              ([|EncryptionMethod in {TSUDSCSec1EncryptionMethod.EncryptionMethod40Bit,
                                      TSUDSCSec1EncryptionMethod.EncryptionMethod128Bit,
                                      TSUDSCSec1EncryptionMethod.EncryptionMethod56Bit}|] NonFipsSecurityHeader) |
              ([|(EncryptionMethod == TSUDSCSec1EncryptionMethod.EncryptionMethodFips)|] FipsSecurityHeader)
             ) SecurityHeader
        with Documentation
           {Description = "Optional security header. The presence and format of the security header depends on the Encryption Level and Encryption Method selected by the server (sections  and ). If the Encryption Level selected by the server is greater than ENCRYPTION_LEVEL_NONE (0) and the Encryption Method selected by the server is greater than ENCRYPTION_METHOD_NONE (0), then this field MUST contain one of the following headers:"};
  
    TSShareDataHeader ShareDataHeader
        with Documentation
           {Description = "A Share Data Header containing information about the packet. The type subfield of the pduType field of the Share Control Header MUST be set to PDUTYPE_DATAPDU (7). The pduType2 field of the Share Data Header MUST be set to PDUTYPE2_MONITOR_LAYOUT_PDU (55), and the pduSource field MUST be set to 0."};
  
    uint MonitorCount
        with Documentation
           {Description = "A 32-bit, unsigned integer. The number of display monitor definitions in the monitorDefArray field."};
  
    array<TSMonitorDef> MonitorDefArray
        with Documentation
           {Description = "A variable-length array containing a series of TS_MONITOR_DEF structures, which describe the display monitor layout of the session on the remote server. The number of TS_MONITOR_DEF structures that follows is given by the monitorCount field."},
        BinaryEncoding{Length = MonitorCount};
           
    override string ToString()
    {
        return "Monitor Layout PDU";
    }
}
with Documentation
       {Applicability = "2.2.12.1",
        Description = "The Monitor Layout PDU is used by the server to notify the client of the monitor layout in the session on the remote server."};
        
// 2.2.13.1   Server Redirection Packet (RDP_SERVER_REDIRECTION_PACKET)
type RdpServerRedirectionPacket
{
    ushort Flags where value == 0x0400
        with Documentation
           {Description = "A 16-bit unsigned integer. The server redirection identifier. This field MUST be set to SEC_REDIRECTION_PKT (0x0400)."};
  
    ushort Length
        with Documentation
           {Description = "A 16-bit unsigned integer. The overall length, in bytes, of the Server Redirection Packet structure."};
  
    uint SessionID
        with Documentation
           {Description = "A 32-bit unsigned integer. The session identifier to which the client MUST reconnect. This identifier MUST be specified in the RedirectSessionID field of the Client Cluster Data if a reconnect attempt takes place. The Client Cluster Data is transmitted as part of the MCS Connect Initial PDU with GCC Conference Create Request."};
  
    RdpServerRedirectionPacketRedirFlags RedirFlags
        with Documentation
           {Description = "A 32-bit unsigned integer. A bit field that contains redirection information flags, some of which indicate the presence of additional data at the end of the packet."};
  
    optional ([|(RedirFlags & RdpServerRedirectionPacketRedirFlags.LBTargetNetAddress) == RdpServerRedirectionPacketRedirFlags.LBTargetNetAddress|] uint) TargetNetAddressLength
        with Documentation
           {Description = "A 32-bit unsigned integer. The length, in bytes, of the TargetNetAddress field."};
  
    optional ([|!(TargetNetAddressLength is nothing)|] string) TargetNetAddress
        with Documentation
           {Description = "A variable-length array of bytes containing the IP address of the server (for example, 192.168.0.1 using dotted decimal notation) in Unicode format, including a null-terminator."},
        BinaryEncoding{TextEncoding = TextEncoding.UTF16};
  
    optional [|(RedirFlags & RdpServerRedirectionPacketRedirFlags.LBLoadBalanceInfo) == RdpServerRedirectionPacketRedirFlags.LBLoadBalanceInfo|] uint LoadBalanceInfoLength
        with Documentation
           {Description = "A 32-bit unsigned integer. The length, in bytes, of the LoadBalanceInfo field."};
  
    optional ([|!(LoadBalanceInfoLength is nothing)|] binary) LoadBalanceInfo
        with Documentation
           {Description = "A variable-length array of bytes containing load balancing information that MUST be treated as opaque data by the client and passed to the server if the LB_TARGET_NET_ADDRESS (0x00000001) flag is not present in the RedirFlags field and a reconnection takes place. See section  for details on populating the routingToken field of the X.224 Connection Request PDU."},
        BinaryEncoding{Length = LoadBalanceInfoLength as uint};
  
    optional [|(RedirFlags & RdpServerRedirectionPacketRedirFlags.LBUsername) == RdpServerRedirectionPacketRedirFlags.LBUsername|] uint UserNameLength
        with Documentation
           {Description = "A 32-bit unsigned integer. The length, in bytes, of the UserName field."};
  
    optional ([|!(UserNameLength is nothing)|] string) UserName
        with Documentation
           {Description = "A variable-length array of bytes containing the username of the user in Unicode format, including a null-terminator."},
        BinaryEncoding{TextEncoding = TextEncoding.UTF16};
  
    optional [|(RedirFlags & RdpServerRedirectionPacketRedirFlags.LBDomain) == RdpServerRedirectionPacketRedirFlags.LBDomain|] uint DomainLength
        with Documentation
           {Description = "A 32-bit unsigned integer. The length, in bytes, of the Domain field."};
  
    optional ([|!(DomainLength is nothing)|] string) Domain
        with Documentation
           {Description = "A variable-length array of bytes containing the domain to which the user connected in Unicode format, including a null-terminator."},
        BinaryEncoding{TextEncoding = TextEncoding.UTF16};
  
    optional [|(RedirFlags & RdpServerRedirectionPacketRedirFlags.LBPassword) == RdpServerRedirectionPacketRedirFlags.LBPassword|] uint PasswordLength
        with Documentation
           {Description = "A 32-bit unsigned integer. The length, in bytes, of the Password field."};
  
    optional ([|!(PasswordLength is nothing)|] string) Password
        with Documentation
           {Description = "A variable-length array of bytes containing the password used by the user in Unicode format, including a null-terminator or a cookie value that MUST be passed to the target server on successful connection."},
        BinaryEncoding{TextEncoding = TextEncoding.UTF16};
  
    optional [|(RedirFlags & RdpServerRedirectionPacketRedirFlags.LBTargetFqdn) == RdpServerRedirectionPacketRedirFlags.LBTargetFqdn|] uint TargetFqdnLength
        with Documentation
           {Description = "A 32-bit unsigned integer. The length, in bytes, of the TargetFQDN field."};
  
    optional ([|!(TargetFqdnLength is nothing)|] string) TargetFQDN
        with Documentation
           {Description = "A variable-length array of bytes containing the fully qualified domain name (FQDN) of the target machine, including a null-terminator."},
        BinaryEncoding{TextEncoding = TextEncoding.UTF16};
  
    optional [|(RedirFlags & RdpServerRedirectionPacketRedirFlags.LBTargetNetbiosName) == RdpServerRedirectionPacketRedirFlags.LBTargetNetbiosName|] uint TargetNetBiosNameLength
        with Documentation
           {Description = "A 32-bit unsigned integer. The length, in bytes, of the TargetNetBiosName field."};
  
    optional ([|!(TargetNetBiosNameLength is nothing)|] string) TargetNetBiosName
        with Documentation
           {Description = "A variable-length array of bytes containing the NETBIOS name of the target machine, including a null-terminator."},
        BinaryEncoding{TextEncoding = TextEncoding.UTF16};
  
    optional [|(RedirFlags & RdpServerRedirectionPacketRedirFlags.LBClientTsvUrl) == RdpServerRedirectionPacketRedirFlags.LBClientTsvUrl|] uint TsvUrlLength
        with Documentation
           {Description = "The length, in bytes, of the TsvUrl field.The TsvUrlLength field is supported only on windows_7 and windows_server_2008_r2."};
  
    optional ([|!(TsvUrlLength is nothing)|] binary) TsvUrl
        with Documentation
           {Description = "A variable-length array of bytes.The TsvUrl field is supported only on windows_7 and windows_server_2008_r2. If the client has previously sent a TsvUrl field in the LoadBalanceInfo to the server in the expected format, then the server will return the same TsvUrl to the client in this field. The client verifies that it is the same as the one that it previously passed to the server and if they don't match, the client immediately disconnects the connection."},
        BinaryEncoding{Length = TsvUrlLength as uint};
  
    optional [|(RedirFlags & RdpServerRedirectionPacketRedirFlags.LBTargetNetAddresses) == RdpServerRedirectionPacketRedirFlags.LBTargetNetAddresses|] uint TargetNetAddressesLength
        with Documentation
           {Description = "A 32-bit unsigned integer. The length, in bytes, of the TargetNetAddresses field."};
  
    optional ([|!(TargetNetAddressesLength is nothing)|] TargetNetAddresses) TargetNetAddresses
        with Documentation
           {Description = "A variable-length array of bytes containing the target IP addresses of the server to connect against, stored in a Target Net Addresses structure."};
  
    optional binary Pad
        with Documentation
           {Description = "An optional 8-element array of 8-bit unsigned integers. Padding. Values in this field MUST be ignored."},
            BinaryEncoding{Length = 8};
}
with Documentation
       {Applicability = "2.2.13.1",
        Description = "The RDP_SERVER_REDIRECTION_PACKET structure contains information to enable a client to reconnect to a session on a specified server. This data is sent to a client in a Redirection PDU to enable load-balancing of Remote Desktop sessions across a collection of machines. For more information about the load balancing of Remote Desktop sessions, see [MSFT-SDLBTS]Load-Balanced Configurations and Revectoring Clients."};

// 2.2.13.1   Server Redirection Packet (RDP_SERVER_REDIRECTION_PACKET)
pattern RdpServerRedirectionPacketRedirFlags = flags uint
{
    LBTargetNetAddress = 0x00000001
        with Documentation
             {Description = "Indicates that the TargetNetAddressLength and TargetNetAddress fields are present."},
    LBLoadBalanceInfo = 0x00000002
        with Documentation
             {Description = "Indicates that the LoadBalanceInfoLength and LoadBalanceInfo fields are present."},
    LBUsername = 0x00000004
        with Documentation
             {Description = "Indicates that the UserNameLength and UserName fields are present."},
    LBDomain = 0x00000008
        with Documentation
             {Description = "Indicates that the DomainLength and Domain fields are present."},
    LBPassword = 0x00000010
        with Documentation
             {Description = "Indicates that the PasswordLength and Password fields are present."},
    LBDontstoreusername = 0x00000020
        with Documentation
             {Description = "Indicates that when reconnecting, the client MUST send the username specified in the UserName field to the server in the Client Info PDU."},
    LBSmartcardLogon = 0x00000040
        with Documentation
             {Description = "Indicates that the user can use a smart card for authentication."},
    LBNoredirect = 0x00000080
        with Documentation
             {Description = "Indicates that the contents of the PDU are for informational purposes only. No actual redirection is required."},
    LBTargetFqdn = 0x00000100
        with Documentation
             {Description = "Indicates that the TargetFQDNLength and TargetFQDN fields are present."},
    LBTargetNetbiosName = 0x00000200
        with Documentation
             {Description = "Indicates that the TargetNetBiosNameLength and TargetNetBiosName fields are present."},
    LBTargetNetAddresses = 0x00000800
        with Documentation
             {Description = "Indicates that the TargetNetAddressesLength and TargetNetAddresses fields are present."},
    LBClientTsvUrl = 0x00001000
        with Documentation
             {Description = "Indicates that the TsvUrlLength and TsvUrl fields are present.The LB_CLIENT_TSV_URL redirection flag is supported only on windows_7 and windows_server_2008_r2."},
    LBServerTsvCapable = 0x00002000
        with Documentation
             {Description = "Indicates that the server supports redirection based on the TsvUrl present in the LoadBalanceInfo sent by the client.The LB_SERVER_TSV_CAPABLE redirection flag is supported only on windows_7 and windows_server_2008_r2."}
} with Documentation {EmbeddedType = true};

// 2.2.13.1.1   Target Net Addresses (TARGET_NET_ADDRESSES)
type TargetNetAddresses
{
    uint AddressCount
        with Documentation
           {Description = "A 32-bit, unsigned integer. The number of IP addresses present in the address field."};
  
    array<TargetNetAddress> Addresses
        with Documentation
           {Description = "An array of Target Net Address structures, each containing an IP address."},
        BinaryEncoding{Length = AddressCount};
}
with Documentation
       {Applicability = "2.2.13.1.1",
        Description = "The TARGET_NET_ADDRESSES structure is used to hold a collection of IP addresses in Unicode format."};

// 2.2.13.1.1.1   Target Net Address (TARGET_NET_ADDRESS)
type TargetNetAddress
{
    uint AddressLength
        with Documentation
           {Description = "A 32-bit, unsigned integer. The length in bytes of the address field."};
  
    string Address
        with Documentation
           {Description = "A variable-length array of bytes containing an IP address in Unicode format, including a null-terminator."},
        BinaryEncoding{TextEncoding = TextEncoding.UTF16};
}
with Documentation
       {Applicability = "2.2.13.1.1.1",
        Description = "The Target Net Address structure holds a Unicode text representation of an IP address."};
        
// 2.2.13.2.1   Standard Security Server Redirection PDU (TS_STANDARD_SECURITY_SERVER_REDIRECTION)
message TSStandardSecurityServerRedirectionPdu[TSUDSCSec1EncryptionLevel EncryptionLevel, TSUDSCSec1EncryptionMethod EncryptionMethod]
{
    optional (
              ([|EncryptionMethod in {TSUDSCSec1EncryptionMethod.EncryptionMethod40Bit,
                                      TSUDSCSec1EncryptionMethod.EncryptionMethod128Bit,
                                      TSUDSCSec1EncryptionMethod.EncryptionMethod56Bit}|] NonFipsSecurityHeader) |
              ([|(EncryptionMethod == TSUDSCSec1EncryptionMethod.EncryptionMethodFips)|] FipsSecurityHeader)
             ) SecurityHeader
        with Documentation
           {Description = "Security header. The format of the security header depends on the Encryption Level and Encryption Method selected by the server (sections  and ). This field MUST contain one of the following headers:"};
  
    RdpServerRedirectionPacket ServerRedirectionPdu
         with Documentation
           {Description = "Information required by the client to initiate a reconnection to a given session on a target server encapsulated in a Server Redirection Packet structure."};
           
    override string ToString()
    {
        return "Standard Security Server Redirection PDU";
    }
}
with Documentation
       {Applicability = "2.2.13.2.1",
        Description = "The Standard Security Server Redirection PDU is sent by the server to the client to instruct it to reconnect to an existing session on another server. The information required to perform the reconnection is contained in an embedded Server Redirection Packet. This PDU MUST NOT be sent if the Encryption Level selected by the server is ENCRYPTION_LEVEL_NONE (0); the Enhanced Security Server Redirection PDU MUST be used instead. Because the Standard Security Server Redirection PDU can contain confidential information, it MUST always be encrypted using Standard RDP Security mechanisms."};

// 2.2.13.3.1   Enhanced Security Server Redirection PDU (TS_ENHANCED_SECURITY_SERVER_REDIRECTION)
message TSEnhancedSecurityServerRedirection
{
    TSShareControlHeader ShareControlHeader
        with Documentation
           {Description = "A Share Control Header (as specified in section ) containing information on the packet. The type subfield of the pduType field of the Share Control Header MUST be set to PDUTYPE_SERVER_REDIR_PKT (10). The versionHigh and versionLow subfields MUST both be set to 0."};
  
    ushort Pad2Octets
        with Documentation
           {Description = "A 16-bit, unsigned integer. Padding. Values in this field MUST be ignored."};
  
    RdpServerRedirectionPacket ServerRedirectionPdu
        with Documentation
           {Description = "Information required by the client to initiate a reconnection to a given session on a target server encapsulated in a Server Redirection Packet structure."};
  
    byte Pad1Octet
        with Documentation
           {Description = "An optional 8-bit, unsigned integer. Padding. Values in this field MUST be ignored."};
           
    override string ToString()
    {
        return "Enhanced Security Server Redirection PDU";
    }
}
with Documentation
       {Applicability = "2.2.13.3.1",
        Description = "The Enhanced Security Server Redirection PDU is sent by the server to the client to instruct it to reconnect to an existing session on another server. The information required to perform the reconnection is contained in an embedded Server Redirection Packet. This PDU MUST NOT be sent if Standard RDP Security is in effect. The Standard Security Server Redirection PDU MUST be used instead. Because this PDU can contain confidential information, it MUST always be encrypted by the External Security Protocol layer."};

//  2.2.14.1   Server Auto-Detect Request PDU
message ServerAutoDetectRequestPdu[TSUDSCSec1EncryptionLevel EncryptionLevel, TSUDSCSec1EncryptionMethod EncryptionMethod]
{
    optional (
              ([|(EncryptionLevel == TSUDSCSec1EncryptionLevel.EncryptionLevelLow) |
                 (EncryptionLevel == TSUDSCSec1EncryptionLevel.EncryptionLevelNone)|] BasicSecurityHeader) |
              ([|EncryptionMethod in {TSUDSCSec1EncryptionMethod.EncryptionMethod40Bit,
                                      TSUDSCSec1EncryptionMethod.EncryptionMethod128Bit,
                                      TSUDSCSec1EncryptionMethod.EncryptionMethod56Bit}|] NonFipsSecurityHeader) |
              ([|(EncryptionMethod == TSUDSCSec1EncryptionMethod.EncryptionMethodFips)|] FipsSecurityHeader)
             ) SecurityHeader
        with Documentation
           {Description = "Security header. The format of the security header depends on the Encryption Level and Encryption Method selected by the server (sections 5.3.2 and 2.2.1.4.3). This field MUST contain one of the following headers:"};

    (RdpRttRequest | RdpBWStart | RdpBWPayload | RdpBWStop | RdpNetcharResult) AutoDetectReqPduData
        with Documentation
           {Description = "A variable-length field that contains auto-detect request data, specifically one of the four messages described in sections 2.2.14.1.1 to 2.2.14.1.4."};
           
    override string ToString()
    {
        return "Server Auto-Detect Request PDU, AutoDetectReqPduData: " + AutoDetectReqPduData.ToString();
    }
}
with Documentation
       {Applicability = "2.2.14.1",
        Description = "The Auto-Detect Request PDU is sent by the server to the client and is used to detect network characteristics such as bandwidth and round-trip time."};


//  2.2.14.1.1   RTT Measure Request (RDP_RTT_REQUEST)
pattern RdpRttRequestType = enum ushort
{
    RttRequestInSecurityHeaderOrTunnalSubHeader = 0x0001
        with Documentation
             {Description = "The RTT Measure Request message is encapsulated in the SubHeaderData field of an RDP_TUNNEL_SUBHEADER ([MS-RDPEMT] section 2.2.1.1.1) structure or is encapsulated in the autoDetectReqData field of a Basic (section 2.2.8.1.1.2.1), Non-FIPS (section 2.2.8.1.1.2.2) or FIPS (section 2.2.8.1.1.2.3) security header."},
    RttRequestInAutoDetectRequestPdu = 0x1001
        with Documentation
             {Description = "The RTT Measure Request message is encapsulated in the autoDetectReqData field of an Auto-Detect Request PDU (section 2.2.14.3)."}
}with Documentation {EmbeddedType = true};
        
type RdpRttRequest
{
    byte HeaderLength where value == 0x06
        with Documentation
           {Description = "An 8-bit unsigned integer that specifies the size, in bytes, of the header. This field MUST be set to 0x06."};
           
    byte HeaderTypeID where value == 0x00
        with Documentation
           {Description = "An 8-bit unsigned integer that specifies the high-level type. This field MUST be set to TYPE_ID_AUTODETECT_REQUEST (0x00)."};
           
    ushort SequenceNumber
        with Documentation
           {Description = "A 16-bit unsigned integer that specifies the message sequence number."};
           
   RdpRttRequestType RequestType
        with Documentation
           {Description = "A 16-bit unsigned integer that specifies a request type code."};
           
    override string ToString()
    {
        return "RTT Measure Request, SequenceNumber: " + (SequenceNumber as string) + ", RequestType: " + EnumToString(RequestType, "RDPBCGR.RdpRttRequestType");
    }
}
with Documentation {Applicability = "2.2.14.1.1", Description = "The RDP_RTT_REQUEST structure is used to initiate a round-trip time measurement operation."};
        
//  2.2.14.1.2   Bandwidth Measure Start (RDP_BW_START)
pattern RdpBWStartRequestType = enum ushort
{
    RdpBWStartInSecurityHeaderOrReliableTunnalSubHeader = 0x0014
        with Documentation
             {Description = "The Bandwidth Measure Start message is encapsulated in the SubHeaderData field of an RDP_TUNNEL_SUBHEADER ([MS-RDPEMT] section 2.2.1.1.1) structure that is being tunneled over a reliable UDP multitransport connection ([MS-RDPEMT] sections 1.3 and 2.1) or is encapsulated in the autoDetectReqData field of a Basic (section 2.2.8.1.1.2.1), Non-FIPS (section 2.2.8.1.1.2.2) or FIPS (section 2.2.8.1.1.2.3) security header."},
    RdpBWStartInLossyTunnalSubHeader = 0x0114
        with Documentation
             {Description = "The Bandwidth Measure Start message is encapsulated in the SubHeaderData field of an RDP_TUNNEL_SUBHEADER ([MS-RDPEMT] section 2.2.1.1.1) structure that is being tunneled over a lossy UDP multitransport connection ([MS-RDPEMT] sections 1.3 and 2.1)."},
    RdpBWStartInAutoDetectRequestPdu = 0x1014
        with Documentation
             {Description = "The Bandwidth Measure Start message is encapsulated in the autoDetectReqData field of an Auto-Detect Request PDU (section 2.2.14.3)."}
}with Documentation {EmbeddedType = true};

type RdpBWStart
{
    byte HeaderLength where value == 0x06
        with Documentation
           {Description = "An 8-bit unsigned integer that specifies the size, in bytes, of the header. This field MUST be set to 0x06."};
           
    byte HeaderTypeId where value == 0x00
        with Documentation
           {Description = "An 8-bit unsigned integer that specifies the high-level type. This field MUST be set to TYPE_ID_AUTODETECT_REQUEST (0x00)."};
           
    ushort SequenceNumber
        with Documentation
           {Description = "A 16-bit unsigned integer that specifies the message sequence number."};
           
    RdpBWStartRequestType RequestType
        with Documentation
           {Description = "A 16-bit unsigned integer that specifies a request type code."};
    
    override string ToString()
    {
        return "Bandwidth Measure Start, SequenceNumber: " + (SequenceNumber as string) + ", RequestType: " + EnumToString(RequestType, "RDPBCGR.RdpBWStartRequestType");
    }
}
with Documentation {Applicability = "2.2.14.1.2", Description = "The RDP_BW_START structure is used to start a bandwidth measurement operation."};

//  2.2.14.1.3   Bandwidth Measure Payload (RDP_BW_PAYLOAD)
type RdpBWPayload
{
    byte HeaderLength where value == 0x08
        with Documentation
           {Description = "An 8-bit unsigned integer that specifies the size, in bytes, of the header. This field MUST be set to 0x08."};
           
    byte HeaderTypeID where value == 0x00
        with Documentation
           {Description = "An 8-bit unsigned integer that specifies the high-level type. This field MUST be set to TYPE_ID_AUTODETECT_REQUEST (0x00)."};
           
    ushort SequenceNumber
        with Documentation
           {Description = "A 16-bit unsigned integer that specifies the message sequence number."};
           
    ushort RequestType where value == 0x0002
        with Documentation
           {Description = "A 16-bit unsigned integer that specifies a request type code. This field MUST be set to 0x0002."};
           
    ushort PayloadLength
        with Documentation
           {Description = "A 16-bit unsigned integer that specifies the size, in bytes, of the payload field."};
           
    binary Payload
        with Documentation
           {Description = "A variable-length array of bytes that contains random data. The number of bytes in this array is specified by the payloadLength field."},
           BinaryEncoding{Length = (PayloadLength)};
           
    override string ToString()
    {
        return "Bandwidth Measure Payload, SequenceNumber: " + (SequenceNumber as string);
    }
}
with Documentation {Applicability = "2.2.14.1.3", Description = "The RDP_BW_PAYLOAD structure is used to transfer data associated with a bandwidth measurement operation."};

//  2.2.14.1.4   Bandwidth Measure Stop (RDP_BW_STOP)
pattern RdpBWStopRequestType = enum ushort
{
    RdpBWStopInSecurityHeaderOrReliableTunnalSubHeader = 0x0429
        with Documentation
             {Description = "The Bandwidth Measure Stop message is encapsulated in the SubHeaderData field of an RDP_TUNNEL_SUBHEADER ([MS-RDPEMT] section 2.2.1.1.1) structure that is being tunneled over a reliable UDP multitransport connection ([MS-RDPEMT] sections 1.3 and 2.1) or is encapsulated in the autoDetectReqData field of a Basic (section 2.2.8.1.1.2.1), Non-FIPS (section 2.2.8.1.1.2.2) or FIPS (section 2.2.8.1.1.2.3) security header."},
    RdpBWStopInLossyTunnalSubHeader = 0x0629
        with Documentation
             {Description = "The Bandwidth Measure Stop message is encapsulated in the SubHeaderData field of an RDP_TUNNEL_SUBHEADER ([MS-RDPEMT] section 2.2.1.1.1) structure that is being tunneled over a lossy UDP multitransport connection ([MS-RDPEMT] sections 1.3 and 2.1)."},
    RdpBWStopInAutoDetectRequestPdu = 0x002B
        with Documentation
             {Description = "The Bandwidth Measure Stop message is encapsulated in the autoDetectReqData field of an Auto-Detect Request PDU (section 2.2.14.3)."}
}with Documentation {EmbeddedType = true};

type RdpBWStop
{
    byte HeaderLength where value == 0x06 || value == 0x08
        with Documentation
           {Description = "An 8-bit unsigned integer that specifies the size, in bytes, of the header. This field MUST be set to 0x06 or 0x08."};
           
    byte HeaderTypeID where value == 0x00
        with Documentation
           {Description = "An 8-bit unsigned integer that specifies the high-level type. This field MUST be set to TYPE_ID_AUTODETECT_REQUEST (0x00)."};
           
    ushort SequenceNumber
        with Documentation
           {Description = "A 16-bit unsigned integer that specifies the message sequence number."};
           
    RdpBWStopRequestType RequestType
        with Documentation
           {Description = "A 16-bit unsigned integer that specifies a request type code."};
    
    optional [|RequestType == RdpBWStopRequestType.RdpBWStopInAutoDetectRequestPdu|] ushort PayloadLength
        with Documentation
           {Description = "An optional 16-bit unsigned integer that specifies the size, in bytes, of the payload field. If this field is not present, then the size of the payload field is zero bytes. The payloadLength field MUST NOT be present if the value of the requestType field is not set to 0x002B. It MUST be present (and have a value greater than zero) if the value of the requestType field is set to 0x002B."};    
    
    optional [|PayloadLength != nothing|] binary Payload with BinaryEncoding{Length = (PayloadLength) as ushort},
        Documentation
           {Description = "A variable-length array of bytes that contains random data. The number of bytes in this array is specified by the payloadLength field."};
    
    override string ToString()
    {
        return "Bandwidth Measure Stop, SequenceNumber: " + (SequenceNumber as string) + ", RequestType: " + EnumToString(RequestType, "RDPBCGR.RdpBWStopRequestType");
    }
}
with Documentation {Applicability = "2.2.14.1.4", Description = "The RDP_BW_STOP structure is used to stop a bandwidth measurement operation."};

// 2.2.14.1.5   Network Characteristics Result (RDP_NETCHAR_RESULT)
pattern RdpNetcharResultRequestType = enum ushort
{
    BaseRTTAndAverageRTT   = 0x0840,
    BandwidthAndAverageRTT  = 0x0880,
    BaseRTTAndBandwidthAndAverageRTT = 0x08C0,
    ...
} with Documentation {EmbeddedType = true};

type RdpNetcharResult
{
    byte HeaderLength where value == 0x0E || value == 0x12
        with Documentation
           {Description = "An 8-bit unsigned integer that specifies the size, in bytes, of the header data. This field MUST be set to 0x0E if the requestType field is not set to 0x08C0 and 0x12 if the requestType field is set to 0x08C0."};
           
    byte HeaderTypeID where value == 0x00
        with Documentation
           {Description = "An 8-bit unsigned integer that specifies the high-level type. This field MUST be set to TYPE_ID_AUTODETECT_REQUEST (0x00)."};
           
    ushort SequenceNumber
        with Documentation
           {Description = "A 16-bit unsigned integer that specifies the message sequence number."};
           
    RdpNetcharResultRequestType RequestType where ValidationCheckEnumValue(InRange<RdpNetcharResultRequestType>(value), null, false, ReferenceType.Type, "RDPBCGR", "RequestType", "RdpNetcharResult", "0x0840, 0x0880, 0x08C0.", value)
        with Documentation
           {Description = "A 16-bit unsigned integer that specifies a request type code."};
    
    optional [|(RequestType == RdpNetcharResultRequestType.BaseRTTAndAverageRTT|| RequestType == RdpNetcharResultRequestType.BaseRTTAndBandwidthAndAverageRTT)|] uint BaseRTT 
        with Documentation
           {Description = "An optional 32-bit unsigned integer that specifies the lowest detected round-trip time in milliseconds."};
           
    optional [|(RequestType == RdpNetcharResultRequestType.BandwidthAndAverageRTT|| RequestType == RdpNetcharResultRequestType.BaseRTTAndBandwidthAndAverageRTT)|] uint Bandwidth 
        with Documentation
           {Description = "An optional 32-bit unsigned integer that specifies the current bandwidth in kilobits per second."};
    
    optional [|RequestType in {RdpNetcharResultRequestType.BaseRTTAndAverageRTT, RdpNetcharResultRequestType.BandwidthAndAverageRTT, RdpNetcharResultRequestType.BaseRTTAndBandwidthAndAverageRTT}|] uint AverageRTT 
        with Documentation
           {Description = "An optional 32-bit unsigned integer that specifies the current average round-trip time in milliseconds."};
           
    override string ToString()
    {
        string summary = "Network Characteristics Result, RequestType: " + EnumToString(RequestType, "RDPBCGR.RdpNetcharResultRequestType");
        if (BaseRTT != nothing)
        {
            summary += ", BaseRTT: " + (BaseRTT as string);
        }
        if (Bandwidth != nothing)
        {
            summary += ", Bandwidth: " + (Bandwidth as string);
        }
        if (AverageRTT != nothing)
        {
            summary += ", AverageRTT: " + (AverageRTT as string);
        }
        return summary;
    }
           
}
with Documentation {Applicability = "2.2.14.1.5", Description = "The RDP_NETCHAR_RESULTS structure is used by the server to send detected network characteristics to the client."};

//  2.2.14.2   Client Auto-Detect Response PDU
message ClientAutoDetectResponsePdu[TSUDSCSec1EncryptionLevel EncryptionLevel, TSUDSCSec1EncryptionMethod EncryptionMethod]
{
    optional (([|EncryptionLevel == TSUDSCSec1EncryptionLevel.EncryptionLevelNone|] BasicSecurityHeader) |
              ([|EncryptionMethod in {TSUDSCSec1EncryptionMethod.EncryptionMethod40Bit,
                                      TSUDSCSec1EncryptionMethod.EncryptionMethod128Bit,
                                      TSUDSCSec1EncryptionMethod.EncryptionMethod56Bit}|] NonFipsSecurityHeader) |
              ([|(EncryptionMethod == TSUDSCSec1EncryptionMethod.EncryptionMethodFips)|] FipsSecurityHeader)
             ) SecurityHeader
        with Documentation
           {Description = "Optional security header. The presence and format of the security header depends on the Encryption Level and Encryption Method selected by the server (sections 5.3.2 and 2.2.1.4.3). If the Encryption Level selected by the server is greater than ENCRYPTION_LEVEL_NONE (0) and the Encryption Method selected by the server is greater than ENCRYPTION_METHOD_NONE (0) then this field MUST contain one of the following headers:"};

    (RdpRttResponse | RdpBWResults | RdpNetcharSync) AutoDetectResPduData
        with Documentation
           {Description = "A variable-length field that contains auto-detect response data, specifically one of the two messages described in sections 2.2.14.2.1 to 2.2.14.2.2."};
           
    override string ToString()
    {
        return "Client Auto-Detect Response PDU, AutoDetectResPduData: " + AutoDetectResPduData.ToString();
    }
}
with Documentation {Applicability = "2.2.14.2", Description = "The Auto-Detect Response PDU is sent by the client to the server and is used to detect network characteristics such as bandwidth and round-trip time."};

//  2.2.14.2.1   RTT Measure Response (RDP_RTT_RESPONSE)
type RdpRttResponse
{
    byte HeaderLength where value == 0x06
        with Documentation
           {Description = "An 8-bit unsigned integer that specifies the size, in bytes, of the header. This field MUST be set to 0x06."};
           
    byte HeaderTypeID where value == 0x01
        with Documentation
           {Description = "An 8-bit unsigned integer that specifies the high-level type. This field MUST be set to TYPE_ID_AUTODETECT_RESPONSE (0x01)."};
           
    ushort SequenceNumber
        with Documentation
           {Description = "A 16-bit unsigned integer that specifies the message sequence number."};
           
    ushort ResponseType where value == 0x0000
        with Documentation
           {Description = "A 16-bit unsigned integer that specifies a response type code. This field MUST be set to 0x0000."};
               
    override string ToString()
    {
        return "RTT Measure Response, SequenceNumber: " + (SequenceNumber as string);
    }
}
with Documentation {Applicability = "2.2.14.2.1", Description = "The RDP_RTT_RESPONSE structure is used to respond to round-trip time measurement operation initiated by the RTT Measure Request (section 2.2.14.1.1) message."};

//  2.2.14.2.2   Bandwidth Measure Results (RDP_BW_RESULTS)
pattern RdpBWResultsResponseType = enum ushort
{
    RdpBWResultsInConnectionPhase    = 0x0003
        with Documentation
             {Description = "The Bandwidth Measure Results message is encapsulated in the autoDetectReqData field of an Auto-Detect Request PDU (section 2.2.14.3) sent during the Optional Connect-Time Auto-Detection phase of the RDP Connection Sequence (see section 1.3.1.1 for an overview of the RDP Connection Sequence phases)."},
    RdpBWResultsAfterConnectionPhase  = 0x000B
        with Documentation
             {Description = "The Bandwidth Measure Results message is encapsulated in the autoDetectReqData field of an Auto-Detect Request PDU (section 2.2.14.3) sent after the Optional Connect-Time Auto-Detection phase of the RDP Connection Sequence (see section 1.3.1.1 for an overview of the RDP Connection Sequence phases) or The Bandwidth Measure Results message is encapsulated in the SubHeaderData field of an RDP_TUNNEL_SUBHEADER ([MS-RDPEMT] section 2.2.1.1.1) structure."}
                 
}with Documentation {EmbeddedType = true};

type RdpBWResults
{
    byte HeaderLength where value == 0x0E
        with Documentation
           {Description = "An 8-bit unsigned integer that specifies the size, in bytes, of the header. This field MUST be set to 0x0E."};
           
    byte HeaderTypeID where value == 0x01
        with Documentation
           {Description = "An 8-bit unsigned integer that specifies the high-level type. This field MUST be set to TYPE_ID_AUTODETECT_RESPONSE (0x01)."};
           
    ushort SequenceNumber
        with Documentation
           {Description = "A 16-bit unsigned integer that specifies the message sequence number."};
           
    RdpBWResultsResponseType ResponseType
        with Documentation
           {Description = "A 16-bit unsigned integer that specifies a response type code. This field MUST be set to 0x0003."};
           
    uint TimeDelta
        with Documentation
           {Description = "A 32-bit unsigned integer that specifies the time delta between the receipt of the Bandwidth Measure Start and the Bandwidth Measure Stop messages."};
           
    uint ByteCount
        with Documentation
            {Description = "A 32-bit unsigned integer that specifies the total data received in the Bandwidth Measure Payload messages."};
            
    override string ToString()
    {
        return "Bandwidth Measure Results, SequenceNumber: " + (SequenceNumber as string) + ", ResponseType: " + EnumToString(ResponseType, "RDPBCGR.RdpBWResultsResponseType")+ ", TimeDelta: " + (TimeDelta as string) + ", ByteCount: " + (ByteCount as string);
    }
}
with Documentation {Applicability = "2.2.14.2.2", Description = "The RDP_BW_RESULTS structure is used to send the results of a bandwidth measurement operation to the initiating end-point. Bandwidth measurement is started by the initiating end-point using the Bandwidth Measure Start (section 2.2.14.1.2) message and stopped by the same end-point using the Bandwidth Measure Stop (section 2.2.14.1.4) message. Between the start and stop messages, payloads of random data are transmitted by the initiating end-point using a sequence of Bandwidth Measure Payload (section 2.2.14.1.3) messages."};

// 2.2.14.2.3   Network Characteristics Sync (RDP_NETCHAR_SYNC)
type RdpNetcharSync
{
    byte HeaderLength where value == 0x0E
        with Documentation
           {Description = "An 8-bit unsigned integer that specifies the size, in bytes, of the header. This field MUST be set to 0x0E."};
           
    byte HeaderTypeID where value == 0x01
        with Documentation
           {Description = "An 8-bit unsigned integer that specifies the high-level type. This field MUST be set to TYPE_ID_AUTODETECT_RESPONSE (0x01)."};
           
    ushort SequenceNumber
        with Documentation
           {Description = "A 16-bit unsigned integer that specifies the message sequence number."};
           
    ushort ResponseType where value == 0x0018
        with Documentation
           {Description = "A 16-bit unsigned integer that specifies a request type code. This field MUST be set to 0x0018."};
           
    uint Bandwidth 
        with Documentation
           {Description = "A 32-bit unsigned integer that specifies the previously detected bandwidth in kilobits per second."};
           
    uint Rtt 
        with Documentation
           {Description = "A 32-bit unsigned integer that specifies the previously detected round-trip time in milliseconds."};
           
    override string ToString()
    {
        return "Network Characteristics Sync, SequenceNumber: " + (SequenceNumber as string) + ", Bandwidth: " + (Bandwidth as string) + ", Rtt: " + (Rtt as string);
    }
}
with Documentation {Applicability = "2.2.14.2.3", Description = "The RDP_NETCHAR_SYNC structure is sent in response to the RTT Measure Request (section 2.2.14.1.1) message or Bandwidth Measure Start (section 2.2.14.1.2) message and is used to short-circuit connect-time network characteristics detection in the case of an auto-reconnect (section 1.3.1.5 and 2.2.4)."};

// Encrypted message
message EncryptedMessage[TSUDSCSec1EncryptionLevel EncryptionLevel, TSUDSCSec1EncryptionMethod EncryptionMethod]
{
    optional (
              ([|EncryptionLevel == TSUDSCSec1EncryptionLevel.EncryptionLevelLow|] BasicSecurityHeader) |
              ([|EncryptionMethod in {TSUDSCSec1EncryptionMethod.EncryptionMethod40Bit,
                                      TSUDSCSec1EncryptionMethod.EncryptionMethod128Bit,
                                      TSUDSCSec1EncryptionMethod.EncryptionMethod56Bit}|] NonFipsSecurityHeader) |
              ([|(EncryptionMethod == TSUDSCSec1EncryptionMethod.EncryptionMethodFips)|] FipsSecurityHeader)
             ) SecurityHeader;
    
    binary EncryptedData;
           
    override string ToString()
    {
        ushort Flags;
        if (SecurityHeader is BasicSecurityHeader)
        {
            Flags = (SecurityHeader as BasicSecurityHeader).Flags;
        }
        else if (SecurityHeader is NonFipsSecurityHeader)
        {
            Flags = (SecurityHeader as NonFipsSecurityHeader).BasicSecurityHeader.Flags;
        }
        else 
        {
            Flags = (SecurityHeader as FipsSecurityHeader).BasicSecurityHeader.Flags;
        }
        if ((Flags & TSSecurityHeaderFlags.SecExchangePkt) == TSSecurityHeaderFlags.SecExchangePkt)
        {
            return "Client Security Exchange PDU, Encrypted";
        }
        else if ((Flags & TSSecurityHeaderFlags.SecTransportReq) == TSSecurityHeaderFlags.SecTransportReq)
        {
            return "Server Initiate Multitransport Request PDU, Encrypted";
        }
        else if ((Flags & TSSecurityHeaderFlags.SecTransportRsp) == TSSecurityHeaderFlags.SecTransportRsp)
        {
            return "Client Initiate Multitransport Error PDU, Encrypted";
        }
        else if ((Flags & TSSecurityHeaderFlags.SecInfoPkt) == TSSecurityHeaderFlags.SecInfoPkt)
        {
            return "Client Info PDU, Encrypted";
        }
        else if ((Flags & TSSecurityHeaderFlags.SecLicensePkt) == TSSecurityHeaderFlags.SecLicensePkt)
        {
            return "Server License Error PDU - Valid Client, Encrypted";
        }
        else if ((Flags & TSSecurityHeaderFlags.SecRedirectionPkt) == TSSecurityHeaderFlags.SecRedirectionPkt)
        {
            return "Standard Security Server Redirection PDU, Encrypted";
        }
        else if ((Flags & TSSecurityHeaderFlags.SecAutodetectReq) == TSSecurityHeaderFlags.SecAutodetectReq)
        {
            return "Server Auto-Detect Request PDU, Encrypted";
        }
        else if ((Flags & TSSecurityHeaderFlags.SecAutodetectRsp) == TSSecurityHeaderFlags.SecAutodetectRsp)
        {
            return "Client Auto-Detect Response PDU, Encrypted";
        }
        return "Encrypted Message";
    }
}

// 2.2.15.1   Server Initiate Multitransport Request
message ServerInitiateMultitransportRequest[TSUDSCSec1EncryptionLevel EncryptionLevel, TSUDSCSec1EncryptionMethod EncryptionMethod]
{
    optional (
              ([|EncryptionLevel in {TSUDSCSec1EncryptionLevel.EncryptionLevelLow,
                                     TSUDSCSec1EncryptionLevel.EncryptionLevelNone}|] BasicSecurityHeader) |
              ([|EncryptionMethod in {TSUDSCSec1EncryptionMethod.EncryptionMethod40Bit,
                                      TSUDSCSec1EncryptionMethod.EncryptionMethod128Bit,
                                      TSUDSCSec1EncryptionMethod.EncryptionMethod56Bit}|] NonFipsSecurityHeader) |
              ([|(EncryptionMethod == TSUDSCSec1EncryptionMethod.EncryptionMethodFips)|] FipsSecurityHeader)
             ) SecurityHeader
        with Documentation
           {Description = "Security header. The format of the security header depends on the Encryption Level and Encryption Method selected by the server (sections 5.3.2 and 2.2.1.4.3). This field MUST contain one of the following headers:"};

     uint RequestId
        with Documentation
           {Description = "A 32-bit unsigned integer that specifies a unique ID that the server MUST use to associate this Initiate Multitransport Request PDU with the Tunnel Create Request PDU ([MS-RDPEMT] section 2.2.3) sent by the client once the transport has been established."};

     RequestedProtocolType RequestedProtocol where ValidationCheckEnumValue(InRange<RequestedProtocolType>(value), this, false, ReferenceType.Message, "RDPBCGR", "RequestedProtocol", "ServerInitiateMultitransportRequest", "0x0001, 0x0002", value)
        with Documentation
           {Description = "A 16-bit unsigned integer that specifies the protocol to use in the transport."};

     ushort Reserved where ValidationCheckReservedZero(value == 0, this, true, ReferenceType.Message, "RDPBCGR", "Reserved", "ServerInitiateMultitransportRequest", value)
        with Documentation
           {Description = "A 16-bit unsigned integer. This field is unused and reserved for future use. It MUST be set to zero."};

     binary SecurityCookie with BinaryEncoding{Length = 16},
            Documentation
           {Description = "A 32-bit unsigned integer that specifies a unique ID that the server MUST use to associate this Initiate Multitransport Request PDU with the Tunnel Create Request PDU ([MS-RDPEMT] section 2.2.3) sent by the client once the transport has been established."};
           
    override string ToString()
    {
        return "Server Initiate Multitransport Request, RequestId: " + (RequestId as string) + ", RequestedProtocol: " + EnumToString(RequestedProtocol, "RDPBCGR.RequestedProtocolType");
    }
}
with Documentation
       {Applicability = "2.2.15.1",
        Description = "The Initiate Multitransport Request PDU is sent by the server to the client and is used to bootstrap the creation of a side-band channel."};

pattern RequestedProtocolType = enum ushort
{
    InititateRequestProtocolUdpfecr = 0x0001,
    InititateRequestProtocolUdpfecl = 0x0002,
    ...
};

pattern HrResponseType = enum uint
{
    E_ABORT = 0x80004004,
    ...
};

// 2.2.15.2   Client Initiate Multitransport Error
message ClientInitiateMultitransportError[TSUDSCSec1EncryptionLevel EncryptionLevel, TSUDSCSec1EncryptionMethod EncryptionMethod]
{
    optional (
              ([|EncryptionLevel == TSUDSCSec1EncryptionLevel.EncryptionLevelNone|] BasicSecurityHeader) |
              ([|EncryptionMethod in {TSUDSCSec1EncryptionMethod.EncryptionMethod40Bit,
                                      TSUDSCSec1EncryptionMethod.EncryptionMethod128Bit,
                                      TSUDSCSec1EncryptionMethod.EncryptionMethod56Bit}|] NonFipsSecurityHeader) |
              ([|(EncryptionMethod == TSUDSCSec1EncryptionMethod.EncryptionMethodFips)|] FipsSecurityHeader)
             ) SecurityHeader
        with Documentation
           {Description = "Security header. The format of the security header depends on the Encryption Level and Encryption Method selected by the server (sections 5.3.2 and 2.2.1.4.3). This field MUST contain one of the following headers:"};

     uint RequestId
        with Documentation
           {Description = "A 32-bit unsigned integer that specifies a unique ID that MUST contain the corresponding ID which was sent to client in the requestId field of the associated Initiate Multitransport Request PDU (section 2.2.15.1)."};

     HrResponseType HrResponse where ValidationCheckValue(value == HrResponseType.E_ABORT, this, false, ReferenceType.Message, "RDPBCGR", "HrResponse", "ClientInitiateMultitransportError", "0x80004004", value)
        with Documentation
           {Description = "A 32-bit unsigned integer that specifies an error code."};
           
    override string ToString()
    {
        return "Client Initiate Multitransport Error, RequestId: " + (RequestId as string) + ", HrResponse: " + EnumToString(HrResponse, "RDPBCGR.HrResponseType");
    }
}
with Documentation
       {Applicability = "2.2.15.2",
        Description = "The Initiate Multitransport Error PDU is sent by the client to the server and is used to indicate to the server that the client was unable to complete the multitransport initiation request associated with the ID specified in the requestId field."};

// Structures in [MS-RDPEGDI]
// [MS-RDPEGDI] 2.2.1.1   Color Table Cache Capability Set (TS_COLORTABLE_CAPABILITYSET) 
type TSColorTableCapabilitySet
{
    ushort CapabilitySetType where value == 0x000A
        with Documentation
           {Description = "A 16-bit, unsigned integer. The type of the capability set. This field MUST be set to CAPSTYPE_COLORCACHE (0x000A)."};
  
    ushort LengthCapability
        with Documentation
           {Description = "):  A 16-bit, unsigned integer. The length, in bytes, of the capability data, including the size of the capabilitySetType and lengthCapability fields. "};
  
    ushort ColorTableCacheSize 
        with Documentation
           {Description = "A 16-bit, unsigned integer. The number of entries in the color table cache (each entry stores a color table). This value MUST be ignored during capability exchange and is assumed to be 0x0006."};
           
    ushort Pad2octets  
        with Documentation
           {Description = "A 16-bit, unsigned integer used as padding. Values in this field are arbitrary and MUST be ignored."};       
}
with Documentation
       {Applicability = "2.2.1.1",
        Description = "The TS_COLORTABLE_CAPABILITYSET structure is an unused capability set that advertises the size of the color table cache used in conjunction with the Cache Color Table Secondary Drawing Order (see section 2.2.2.2.1.2.4) and is based on the capability set in [T128] section 8.2.8. This capability is sent by both client and server."};

// [MS-RDPEGDI] 2.2.1.2   DrawNineGrid Cache Capability Set (TS_DRAW_NINEGRID_CAPABILITYSET)
pattern DrawNineGridSupportLevelValue = enum uint
{
    DRAW_NINEGRID_NO_SUPPORT = 0x00000000
        with Documentation
           {Description = "NineGrid bitmap caching and rendering is not supported."},
           
    DRAW_NINEGRID_SUPPORTED = 0x00000001
        with Documentation
           {Description = "Revision 1 NineGrid bitmap caching and rendering is supported. The Revision 1 versions of the stream bitmap alternate secondary orders (see section 2.2.2.2.1.3.5) MUST be used to send the NineGrid bitmap from server to client."},
           
    DRAW_NINEGRID_SUPPORTED_REV2 = 0x00000002
        with Documentation
           {Description = "Revision 2 NineGrid bitmap caching and rendering is supported. The Revision 2 versions of the stream bitmap alternate secondary orders (see section 2.2.2.2.1.3.5) MUST be used to send the NineGrid bitmap from server to client."}
}with Documentation {EmbeddedType = true};
        
type TSDrawNinegridCapabilitySet
{
    ushort CapabilitySetType where value == 0x0015
        with Documentation
           {Description = "A 16-bit, unsigned integer. The type of the capability set. This field MUST be set to CAPSTYPE_DRAWNINEGRIDCACHE (0x0015)."};
     
    ushort LengthCapability
        with Documentation
           {Description = "A 16-bit, unsigned integer. The length, in bytes, of the capability data, including the size of the capabilitySetType and lengthCapability fields."};
           
    DrawNineGridSupportLevelValue DrawNineGridSupportLevel  
        with Documentation
           {Description = "A 32-bit, unsigned integer. The level of support for NineGrid drawing. This field MUST be set to one of the following values."};  
           
    ushort DrawNineGridCacheSize 
        with Documentation
           {Description = "A 16-bit, unsigned integer. The maximum size of the NineGrid Bitmap Cache. The largest size allowed by current RDP servers is 2,560 kilobytes."};
           
    ushort DrawNineGridCacheEntries  
        with Documentation
           {Description = "A 16-bit, unsigned integer. The maximum number of entries allowed in the NineGrid Bitmap Cache. The maximum number of entries allowed by current RDP servers is 256."};    
}        
with Documentation
       {Applicability = "2.2.1.2",
        Description = "The TS_DRAW_NINEGRID_CAPABILITYSET structure is used to advertise support for NineGrid bitmap caching and rendering (see sections 2.2.2.2.1.1.2.21, 2.2.2.2.1.1.2.22, and 2.2.2.2.1.3.4). This capability set is sent only from client to server."};

// [MS-RDPEGDI] 2.2.1.3   Draw GDI+ Capability Set (TS_DRAW_GDIPLUS_CAPABILITYSET)
pattern DrawGDIPlusSupportLevelValue = enum uint
{
    TS_DRAW_GDIPLUS_DEFAULT = 0x00000000
        with Documentation
           {Description = "GDI+ 1.1 is not supported"},
           
    TS_DRAW_GDIPLUS_SUPPORTED = 0x00000001
        with Documentation
           {Description = "GDI+ 1.1 is supported."}
}with Documentation {EmbeddedType = true};

pattern DrawGdiplusCacheLevelValue = enum uint
{
    TS_DRAW_GDIPLUS_CACHE_LEVEL_DEFAULT = 0x00000000
        with Documentation
           {Description = "Caching of GDI+ 1.1 rendering primitives is not supported."},
           
    TS_DRAW_GDIPLUS_CACHE_LEVEL_ONE = 0x00000001
        with Documentation
           {Description = "Caching of GDI+ 1.1 rendering primitives is supported."}
}with Documentation {EmbeddedType = true};
          
type TSDrawGDIPlusCapabilitySet
{
    ushort CapabilitySetType where value == 0x0016
        with Documentation
           {Description = "A 16-bit, unsigned integer. The type of the capability set. This field MUST be set to CAPSTYPE_DRAWGDIPLUS (0x0016)."};
           
    ushort LengthCapability
        with Documentation
           {Description = "A 16-bit, unsigned integer. The length, in bytes, of the capability data, including the size of the capabilitySetType and lengthCapability fields."};
    
    DrawGDIPlusSupportLevelValue DrawGDIPlusSupportLevel     
        with Documentation
           {Description = "A 32-bit, unsigned integer. The level of support for GDI+ 1.1 remoting. This field MUST be set to one of the following values."};
           
    uint GdipVersion
        with Documentation
           {Description = "A 32-bit, unsigned integer. The build number of the underlying GDI+ 1.1 subsystem. Only the client-to-server instance of the GDI+ Capability Set MUST contain a valid value for this field."};        
   
    DrawGdiplusCacheLevelValue DrawGdiplusCacheLevel  
         with Documentation
           {Description = "A 32-bit, unsigned integer. The level of support for the caching of GDI+ 1.1 rendering primitives. This field MUST be set to one of the following values."};
      
    TSGDIplusCacheEntries GdipCacheEntries 
        with Documentation
           {Description = "A GDI+ Cache Entries (section 2.2.1.3.1) structure that specifies the total number of entries within the GDI+ Graphics, Pen, Brush, Image, and Image Attributes caches. Only the client-to-server instance of the GDI+ Capability Set MUST contain a valid value for this field."};          
     
    TSGDIplusCacheChunkSize GdipCacheChunkSize
        with Documentation
           {Description = "A GDI+ Cache Chunk Size structure that specifies the size of individual entries in the GDI+ Graphics, Brush, Pen, and Image Attributes caches. Only the client-to-server instance of the GDI+ Capability Set MUST contain a valid value for this field."};
   
    TSGDIplusImageCacheProperties GdipImageCacheProperties 
        with Documentation
           {Description = "A GDI+ Image Cache Properties structure that contains sizing information for the GDI+ Image cache. Only the client-to-server instance of the GDI+ Capability Set MUST contain a valid value for this field."};                                        
}    
with Documentation
       {Applicability = "2.2.1.3",
        Description = "The TS_DRAW_GDIPLUS_CAPABILITYSET structure is used to advertise the level of GDI+ 1.1 rendering and caching support and the GDI+ cache configuration. This capability is sent by both client and server. However, only the client initializes the GdipVersion, GdipCacheEntries, GdipCacheChunkSize, and GdipImageCacheProperties fields. The server uses this capability set only to advertise its level of GDI+ 1.1 rendering and caching support."};
    
// [MS-RDPEGDI] 2.2.1.3.1   GDI+ Cache Entries (TS_GDIPLUS_CACHE_ENTRIES)
type TSGDIplusCacheEntries
{
    ushort GdipGraphicsCacheEntries
        with Documentation
           {Description = "A 16-bit, unsigned integer. The total number of entries allowed in the GDI+ Graphics cache. The maximum allowed value is 10 entries."};
           
    ushort GdipBrushCacheEntries 
        with Documentation
           {Description = "A 16-bit, unsigned integer. The total number of entries allowed in the GDI+ Brush cache. The maximum allowed value is 5 entries."};
           
    ushort GdipPenCacheEntries 
        with Documentation
           {Description = "A 16-bit, unsigned integer. The total number of entries allowed in the GDI+ Pen cache. The maximum allowed value is 5 entries."};
           
    ushort GdipImageCacheEntries 
        with Documentation
           {Description = "A 16-bit, unsigned integer. The total number of entries allowed in the GDI+ Image cache. The maximum allowed value is 10 entries."};
           
    ushort GdipImageAttributesCacheEntries 
        with Documentation
           {Description = "A 16-bit, unsigned integer. The total number of entries allowed in the GDI+ Image Attributes cache. The maximum allowed value is 2 entries."};
}
with Documentation
       {Applicability = "2.2.1.3.1",
        Description = "The TS_GDIPLUS_CACHE_ENTRIES structure specifies the total number of cache entries for the GDI+ Graphics, Brush, Pen, Image, and Image Attributes caches."};
        
// [MS-RDPEGDI] 2.2.1.3.2   GDI+ Cache Chunk Size (TS_GDIPLUS_CACHE_CHUNK_SIZE)
type TSGDIplusCacheChunkSize
{
    ushort GdipGraphicsCacheChunkSize
        with Documentation
           {Description = "A 16-bit, unsigned integer. The maximum size in bytes of a GDI+ Graphics cache entry. The maximum allowed value is 512 bytes."};
           
    ushort GdipObjectBrushCacheChunkSize
        with Documentation
           {Description = "A 16-bit, unsigned integer. The maximum size in bytes of a GDI+ Brush cache entry. The maximum allowed value is 2,048 bytes."};
           
    ushort GdipObjectPenCacheChunkSize
        with Documentation
           {Description = "A 16-bit, unsigned integer. The maximum size in bytes of a GDI+ Pen cache entry. The maximum allowed value is 1,024 bytes."};
           
    ushort GdipObjectImageAttributesCacheChunkSize
        with Documentation
           {Description = "A 16-bit, unsigned integer. The maximum size in bytes of a GDI+ Image Attributes cache entry. The maximum allowed value is 64 bytes."};
}  
with Documentation
       {Applicability = "2.2.1.3.2",
        Description = "The TS_GDIPLUS_CACHE_CHUNK_SIZE structure specifies the maximum size of individual entries in the GDI+ Graphics, Brush, Pen, and Image Attributes caches."};
       
// [MS-RDPEGDI] 2.2.1.3.3   GDI+ Image Cache Properties (TS_GDIPLUS_IMAGE_CACHE_PROPERTIES)                        
type TSGDIplusImageCacheProperties
{
    ushort GdipObjectImageCacheChunkSize
        with Documentation
           {Description = "A 16-bit, unsigned integer. The maximum size in bytes of a chunk in the GDI+ Image cache. The maximum allowed value is 4,096 bytes."};
         
    ushort GdipObjectImageCacheTotalSize
        with Documentation
           {Description = "A 16-bit, unsigned integer. The total number of chunks in the GDI+ Image cache. The maximum allowed value is 256 chunks."};
         
    ushort GdipObjectImageCacheMaxSize
        with Documentation
           {Description = "):  A 16-bit, unsigned integer. The total number of chunks that can be used by an entry in the GDI+ Image cache. The maximum allowed value is 128 chunks."};
}
with Documentation
       {Applicability = "2.2.1.3.3",
        Description = "The TS_GDIPLUS_IMAGE_CACHE_PROPERTIES structure contains sizing information for the GDI+ Image cache."};
        
// [MS-RDPEGDI] 2.2.2.1   Orders Update (TS_UPDATE_ORDERS_PDU_DATA)       
type UpdateOrdersPDUData
{
    TSShareDataHeader ShareDataHeader
        with Documentation
           {Description = "Share Data Header (see [MS-RDPBCGR], section 2.2.8.1.1.1.2) containing information about the packet. The type subfield of the pduType field of the Share Control Header (section 2.2.8.1.1.1.1) MUST be set to PDUTYPE_DATAPDU (7). The pduType2 field of the Share Data Header MUST be set to PDUTYPE2_UPDATE (2)."};
  
    (TSGraphicsUpdateUpdateType where value == TSGraphicsUpdateUpdateType.UpdateTypeOrders) UpdateType
        with Documentation
           {Description = "A 16-bit, unsigned integer. The field contains the graphics update type. This field MUST be set to UPDATETYPE_ORDERS (0x0000)."};
           
    ushort Pad2OctetsA
        with Documentation
           {Description = "A 16-bit, unsigned integer used as a padding field. Values in this field are arbitrary and MUST be ignored."};
           
    ushort NumberOrders
        with Documentation
           {Description = "A 16-bit, unsigned integer. The number of Drawing Order (section 2.2.2.1.1) structures contained in the orderData field."};
           
    ushort Pad2OctetsB
        with Documentation
           {Description = "A 16-bit, unsigned integer used as a padding field. Values in this field are arbitrary and MUST be ignored."};
           
    (binary | any) OrderData
        with Documentation
           {Description = "A variable-sized array of Drawing Order (section 2.2.2.1.1) structures packed on byte boundaries. Each structure contains a primary, secondary, or alternate secondary drawing order. The controlFlags field of the Drawing Order identifies the type of drawing order."};
}
with Documentation
       {Applicability = "2.2.2.1",
        Description = "The TS_UPDATE_ORDERS_PDU_DATA structure contains primary, secondary, and alternate secondary drawing orders aligned on byte boundaries. "};
        
// [MS-RDPEGDI] 2.2.2.2   Fast-Path Orders Update (TS_FP_UPDATE_ORDERS)
type TSFPUpdateOrders
{
    TSFPUpdateUpdateHeader UpdateHeader where value.UpdateCode == TSFPUpdateUpdateHeaderUpdateCode.FastPathUpdatetypeOrders
        with Documentation
           {Description = "An 8-bit, unsigned integer. The format of this field is the same as the updateHeader byte field described in the Fast-Path Update structure (see [MS-RDPBCGR] section 2.2.9.1.2.1). The updateCode bitfield (4 bits in size) MUST be set to FASTPATH_UPDATETYPE_ORDERS (0x0)."};
           
    (optional [|UpdateHeader.Compression == TSFPUpdateUpdateHeaderCompression.FastPathOutputCompressionUsed|] TSShareDataHeaderCompressedType) CompressionFlags
        with Documentation
           {Description = "An 8-bit, unsigned integer. The format of this optional field (as well as the possible values) is the same as the compressionFlags field described in the Fast-Path Update structure specified in [MS-RDPBCGR] section 2.2.9.1.2.1."};
           
    ushort Size
        with Documentation
           {Description = "A 16-bit, unsigned integer. The format of this field (as well as the possible values) is the same as the size field described in the Fast-Path Update structure specified in [MS-RDPBCGR] section 2.2.9.1.2.1."};

    optional [|CompressionFlags != nothing  && ((CompressionFlags as TSShareDataHeaderCompressedType).compressedFlags & TSShareDataHeaderCompressedFlags.PacketCompressed) != 0 |] binary CompressedData with BinaryEncoding{Length = Size};
           
    optional [|CompressionFlags == nothing  || ((CompressionFlags as TSShareDataHeaderCompressedType).compressedFlags & TSShareDataHeaderCompressedFlags.PacketCompressed) == 0 |] ushort NumberOrders
        with Documentation
           {Description = "A 16-bit, unsigned integer. The number of Drawing Order (section 2.2.2.1.1) structures contained in the orderData field."};
           
    optional [|CompressionFlags == nothing  || ((CompressionFlags as TSShareDataHeaderCompressedType).compressedFlags & TSShareDataHeaderCompressedFlags.PacketCompressed) == 0 |] (binary | any) OrderData 
        with BinaryEncoding{Length = (Size - 2)}
        with Documentation
           {Description = "A variable-sized array of Drawing Order (section 2.2.2.1.1) structures packed on byte boundaries. Each structure contains a primary, secondary, or alternate secondary drawing order. The controlFlags field of the Drawing Order identifies the type of drawing order."};
}  
with Documentation
       {Applicability = "2.2.2.2",
        Description = "The TS_FP_UPDATE_ORDERS structure contains primary, secondary, and alternate secondary drawing orders aligned on byte boundaries. This structure conforms to the layout of a Fast-Path Update (see [MS-RDPBCGR] section 2.2.9.1.2.1) and is encapsulated within a Fast-Path Update PDU (see [MS-RDPBCGR] section 2.2.9.1.2.1.1)."};

// [MS-RDPEGDI] 2.2.2.2.1.1 Primary Drawing Orders
// [MS-RDPEGDI] 2.2.2.2.1.1.1 Common Data Types
type COORD_FIELD[ControlFlags controlFlags]
{
    ([|(controlFlags & ControlFlags.TS_DELTA_COORDINATES) != 0|] sbyte | short) signedValue;
}
        
type VARIABLE1_FIELD
{
    byte cbData;
    binary rgbData with BinaryEncoding{Length = cbData};
}

type VARIABLE2_FIELD
{
    ushort cbData;
    binary rgbData with BinaryEncoding{Length = cbData};
}

type VARIABLE2_DELTA_RECTS_FIELD[optional byte Number]
{
    ushort cbData;
    ([|Number != nothing|] DELTA_RECTS_FIELD[Number as byte] | binary) rgbData with BinaryEncoding{WidthForComposedType = cbData * 8 as int, Length = cbData};
}

type DELTA_PTS_FIELD[byte NumOfPoints]
{
    binary zeroBits with BinaryEncoding{Length = (NumOfPoints + 3) / 4};
    array<PackedSignedFormat> deltaEncodedPoints;
}

type VARIABLE1_DELTA_PTS_FIELD[optional byte Number]
{
    byte cbData;
    ([|Number != nothing|] DELTA_PTS_FIELD[Number as byte] | binary) rgbData with BinaryEncoding{WidthForComposedType = cbData * 8 as int, Length = cbData};
}

type PackedSignedFormat
{
    byte First;
    optional [|(First & 0x80) != 0|] byte Second;
    
    any Value()
    {
        if ((First & 0x80) == 0)
        {
            sbyte result = (First << 1) as sbyte;
            return (result >> 1) as sbyte;
        }
        else
        {
            short result = (First & 0x7F) as short;
            result = (((result << 8) | (Second as byte)) << 1) as short;
            return (result >> 1) as short;
        }
    }
    
    override string ToString()
    {
        return Value().ToString();
    }
}

type DELTA_RECTS_FIELD[byte NumOfRects]
{
    binary zeroBits with BinaryEncoding{Length = (NumOfRects + 1) / 2};
    array<PackedSignedFormat> deltaEncodedRectangles;
}

type ROP2_OPERATION
{
    Rop2Operation rop2Operation where ValidationCheckEnumValueTooManyItems(InRange<Rop2Operation>(value), null, false, ReferenceType.Type, "RDPBCGR", "rop2Operation", "ROP2_OPERATION", "ROP2_OPERATION", "[MS-RDPEGDI]");
}

pattern Rop2Operation = enum byte
{
    R2_BLACK            = 0x01,
    R2_NOTMERGEPEN      = 0x02,
    R2_MASKNOTPEN       = 0x03,
    R2_NOTCOPYPEN       = 0x04,
    R2_MASKPENNOT       = 0x05,
    R2_NOT              = 0x06,
    R2_XORPEN           = 0x07,
    R2_NOTMASKPEN       = 0x08,
    R2_MASKPEN          = 0x09,
    R2_NOTXORPEN        = 0x0A,
    R2_NOP              = 0x0B,
    R2_MERGENOTPEN      = 0x0C,
    R2_COPYPEN          = 0x0D,
    R2_MERGEPENNOT      = 0x0E,
    R2_MERGEPEN         = 0x0F,
    R2_WHITE            = 0x10,
    ...
};

type ROP3_OPERATION_INDEX
{
    byte rop3Index;
}

type TS_COLOR
{
    byte RedOrPaletteIndex;
    byte Green;
    byte Blue;
}

type FILL_MODE
{
    FillModeValue FillMode where ValidationCheckEnumValue(InRange<FillModeValue>(value), null, true, ReferenceType.Type, "RDPBCGR", "FillMode", "FILL_MODE", "0x01, 0x02", value);
}

pattern FillModeValue = enum byte
{
    ALTERNATE   = 0x01,
    WINDING     = 0x02,
    ...
};

// [MS-RDPEGDI] 2.2.2.2.1.1.2 Primary Drawing Order 
type PRIMARY_DRAWING_ORDER[byte Type]
{
    ControlFlags controlFlags where ((value & ControlFlags.TS_STANDARD) != 0 && (value & ControlFlags.TS_SECONDARY) == 0);
    optional [|(controlFlags & ControlFlags.TS_TYPE_CHANGE) != 0|] PrimaryDrawingOrderType orderType where ValidationCheckValid((value == nothing || InRange<PrimaryDrawingOrderType>(value as byte)), null, false, ReferenceType.Type, "RDPBCGR", "orderType", "PRIMARY_DRAWING_ORDER", "type of primary drawing order");
    array<byte> fieldFlags with BinaryEncoding{Length = CountFieldFlagsBytesNum(controlFlags, (orderType != nothing ? (orderType as PrimaryDrawingOrderType) : Type))};
    optional [|(controlFlags & ControlFlags.TS_BOUNDS) != 0 && (controlFlags & ControlFlags.TS_ZERO_BOUNDS_DELTAS) == 0|] Bounds bounds;
    ([|orderType == 0x00 || (orderType == nothing && Type == 0x00)|] DSTBLT_ORDER[controlFlags, fieldFlags] |
     [|orderType == 0x01 || (orderType == nothing && Type == 0x01)|] PATBLT_ORDER[controlFlags, fieldFlags] |
     [|orderType == 0x02 || (orderType == nothing && Type == 0x02)|] SCRBLT_ORDER[controlFlags, fieldFlags] |
     [|orderType == 0x07 || (orderType == nothing && Type == 0x07)|] DRAWNINEGRID_ORDER[controlFlags, fieldFlags] |
     [|orderType == 0x08 || (orderType == nothing && Type == 0x08)|] MULTI_DRAWNINEGRID_ORDER[controlFlags, fieldFlags] |
     [|orderType == 0x09 || (orderType == nothing && Type == 0x09)|] LINETO_ORDER[controlFlags, fieldFlags] |
     [|orderType == 0x0A || (orderType == nothing && Type == 0x0A)|] OPAQUERECT_ORDER[controlFlags, fieldFlags] |
     [|orderType == 0x0B || (orderType == nothing && Type == 0x0B)|] SAVEBITMAP_ORDER[controlFlags, fieldFlags] |
     [|orderType == 0x0D || (orderType == nothing && Type == 0x0D)|] MEMBLT_ORDER[controlFlags, fieldFlags] |
     [|orderType == 0x0E || (orderType == nothing && Type == 0x0E)|] MEM3BLT_ORDER[controlFlags, fieldFlags] |
     [|orderType == 0x0F || (orderType == nothing && Type == 0x0F)|] MULTI_DSTBLT_ORDER[controlFlags, fieldFlags] |
     [|orderType == 0x10 || (orderType == nothing && Type == 0x10)|] MULTI_PATBLT_ORDER[controlFlags, fieldFlags] |
     [|orderType == 0x11 || (orderType == nothing && Type == 0x11)|] MULTI_SCRBLT_ORDER[controlFlags, fieldFlags] |
     [|orderType == 0x12 || (orderType == nothing && Type == 0x12)|] MULTI_OPAQUERECT_ORDER[controlFlags, fieldFlags] |
     [|orderType == 0x13 || (orderType == nothing && Type == 0x13)|] FASTINDEX_ORDER[controlFlags, fieldFlags] |
     [|orderType == 0x14 || (orderType == nothing && Type == 0x14)|] POLYGON_SC_ORDER[controlFlags, fieldFlags] |
     [|orderType == 0x15 || (orderType == nothing && Type == 0x15)|] POLYGON_CB_ORDER[controlFlags, fieldFlags] |
     [|orderType == 0x16 || (orderType == nothing && Type == 0x16)|] POLYLINE_ORDER[controlFlags, fieldFlags] |
     [|orderType == 0x18 || (orderType == nothing && Type == 0x18)|] FASTGLYPH_ORDER[controlFlags, fieldFlags] |
     [|orderType == 0x19 || (orderType == nothing && Type == 0x19)|] ELLIPSE_SC_ORDER[controlFlags, fieldFlags] |
     [|orderType == 0x1A || (orderType == nothing && Type == 0x1A)|] ELLIPSE_CB_ORDER[controlFlags, fieldFlags] |
     [|orderType == 0x1B || (orderType == nothing && Type == 0x1B)|] GLYPHINDEX_ORDER[controlFlags, fieldFlags] |
     binary) primaryOrderData;
     
     override string ToString()
     {
         byte primaryOrderType = (orderType != nothing) ? (orderType as byte) : Type;
         switch (primaryOrderType)
         {
             case 0x00 =>
                return "DSTBLT_ORDER";
             case 0x01 =>
                return "PATBLT_ORDER";
             case 0x02 =>
                return "SCRBLT_ORDER";
             case 0x07 =>
                return "DRAWNINEGRID_ORDER";
             case 0x08 =>
                return "MULTI_DRAWNINEGRID_ORDER";
             case 0x09 =>
                return "LINETO_ORDER";
             case 0x0A =>
                return "OPAQUERECT_ORDER";
             case 0x0B =>
                return "SAVEBITMAP_ORDER";
             case 0x0D =>
                return "MEMBLT_ORDER";
             case 0x0E =>
                return "MEM3BLT_ORDER";
             case 0x0F =>
                return "MULTI_DSTBLT_ORDER";
             case 0x10 =>
                return "MULTI_PATBLT_ORDER";
             case 0x11 =>
                return "MULTI_SCRBLT_ORDER";
             case 0x12 =>
                return "MULTI_OPAQUERECT_ORDER";
             case 0x13 =>
                return "FASTINDEX_ORDER";
             case 0x14 =>
                return "POLYGON_SC_ORDER";
             case 0x15 =>
                return "POLYGON_CB_ORDER";
             case 0x16 =>
                return "POLYLINE_ORDER";
             case 0x18 =>
                return "FASTGLYPH_ORDER";
             case 0x19 =>
                return "ELLIPSE_SC_ORDER";
             case 0x1A =>
                return "ELLIPSE_CB_ORDER";
             case 0x1B =>
                return "GLYPHINDEX_ORDER";
             default =>
                return "Unknown PRIMARY_DRAWING_ORDER";
         }
     }
}

pattern ControlFlags = flags byte
{
    TS_STANDARD             = 0x01,
    TS_SECONDARY            = 0x02,
    TS_BOUNDS               = 0x04,
    TS_TYPE_CHANGE          = 0x08,
    TS_DELTA_COORDINATES    = 0x10,
    TS_ZERO_BOUNDS_DELTAS   = 0x20,
    TS_ZERO_FIELD_BYTE_BIT0 = 0x40,
    TS_ZERO_FIELD_BYTE_BIT1 = 0x80,
};

pattern PrimaryDrawingOrderType = enum byte
{
    TS_ENC_DSTBLT_ORDER             = 0x00,
    TS_ENC_PATBLT_ORDER             = 0x01,
    TS_ENC_SCRBLT_ORDER             = 0x02,
    TS_ENC_DRAWNINEGRID_ORDER       = 0x07,
    TS_ENC_MULTI_DRAWNINEGRID_ORDER = 0x08,
    TS_ENC_LINETO_ORDER             = 0x09,
    TS_ENC_OPAQUERECT_ORDER         = 0x0A,
    TS_ENC_SAVEBITMAP_ORDER         = 0x0B,
    TS_ENC_MEMBLT_ORDER             = 0x0D,
    TS_ENC_MEM3BLT_ORDER            = 0x0E,
    TS_ENC_MULTIDSTBLT_ORDER        = 0x0F,
    TS_ENC_MULTIPATBLT_ORDER        = 0x10,
    TS_ENC_MULTISCRBLT_ORDER        = 0x11,
    TS_ENC_MULTIOPAQUERECT_ORDER    = 0x12,
    TS_ENC_FAST_INDEX_ORDER         = 0x13,
    TS_ENC_POLYGON_SC_ORDER         = 0x14,
    TS_ENC_POLYGON_CB_ORDER         = 0x15,
    TS_ENC_POLYLINE_ORDER           = 0x16,
    TS_ENC_FAST_GLYPH_ORDER         = 0x18,
    TS_ENC_ELLIPSE_SC_ORDER         = 0x19,
    TS_ENC_ELLIPSE_CB_ORDER         = 0x1A,
    TS_ENC_INDEX_ORDER              = 0x1B,
    ...
};

// Mapping the number of fields of each primary drawing order
const map<byte, int> PrimaryDrawingOrderNumOfFieldsMap = 
{
    0x00 -> 5,
    0x01 -> 12,
    0x02 -> 7,
    0x07 -> 5,
    0x08 -> 7,
    0x09 -> 10,
    0x0A -> 7,
    0x0B -> 6,
    0x0D -> 9,
    0x0E -> 16,
    0x0F -> 7,
    0x10 -> 14,
    0x11 -> 9,
    0x12 -> 9,
    0x13 -> 15,
    0x14 -> 7,
    0x15 -> 13,
    0x16 -> 7,
    0x18 -> 15,
    0x19 -> 7,
    0x1A -> 13,
    0x1B -> 22,
};

uint CountFieldFlagsBytesNum(ControlFlags controlFlags, byte orderType)
{
    if (!InRange<PrimaryDrawingOrderType>(orderType))
    {
        return 0;
    }
    uint maxFieldFlagsBytes = (PrimaryDrawingOrderNumOfFieldsMap[orderType] + 8) / 8 as uint;
    uint zeroBitsCount = 0;
    if ((controlFlags & ControlFlags.TS_ZERO_FIELD_BYTE_BIT1) != 0)
    {
        zeroBitsCount += 2;
    }
    if ((controlFlags & ControlFlags.TS_ZERO_FIELD_BYTE_BIT0) != 0)
    {
        zeroBitsCount += 1;
    }
    if (maxFieldFlagsBytes < zeroBitsCount)
    {
         return 0;
    }
    return (maxFieldFlagsBytes - zeroBitsCount) as uint;
}

pattern BoundsFlag = flags byte
{
    TS_BOUND_LEFT           = 0x01,
    TS_BOUND_TOP            = 0x02,
    TS_BOUND_RIGHT          = 0x04,
    TS_BOUND_BOTTOM         = 0x08,
    TS_BOUND_DELTA_LEFT     = 0x10,
    TS_BOUND_DELTA_TOP      = 0x20,
    TS_BOUND_DELTA_RIGHT    = 0x40,
    TS_BOUND_DELTA_BOTTOM   = 0x80,
};

type Bounds
{
    BoundsFlag Description;
    optional ([|(Description & BoundsFlag.TS_BOUND_DELTA_LEFT) != 0|] sbyte | 
              [|(Description & BoundsFlag.TS_BOUND_DELTA_LEFT) == 0 && (Description & BoundsFlag.TS_BOUND_LEFT) != 0|] short) Left;
    optional ([|(Description & BoundsFlag.TS_BOUND_DELTA_TOP) != 0|] sbyte | 
              [|(Description & BoundsFlag.TS_BOUND_DELTA_TOP) == 0 && (Description & BoundsFlag.TS_BOUND_TOP) != 0|] short) Top;
    optional ([|(Description & BoundsFlag.TS_BOUND_DELTA_RIGHT) != 0|] sbyte | 
              [|(Description & BoundsFlag.TS_BOUND_DELTA_RIGHT) == 0 && (Description & BoundsFlag.TS_BOUND_RIGHT) != 0|] short) Right;
    optional ([|(Description & BoundsFlag.TS_BOUND_DELTA_BOTTOM) != 0|] sbyte | 
              [|(Description & BoundsFlag.TS_BOUND_DELTA_BOTTOM) == 0 && (Description & BoundsFlag.TS_BOUND_BOTTOM) != 0|] short) Bottom;
}
  
type DSTBLT_ORDER[ControlFlags controlFlags, array<byte> fieldFlags]
{
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x01) != 0|] COORD_FIELD[controlFlags] nLeftRect;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x02) != 0|] COORD_FIELD[controlFlags] nTopRect;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x04) != 0|] COORD_FIELD[controlFlags] nWidth;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x08) != 0|] COORD_FIELD[controlFlags] nHeight;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x10) != 0|] byte bRop;
}       

type MULTI_DSTBLT_ORDER[ControlFlags controlFlags, array<byte> fieldFlags]
{
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x01) != 0|] COORD_FIELD[controlFlags] nLeftRect;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x02) != 0|] COORD_FIELD[controlFlags] nTopRect;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x04) != 0|] COORD_FIELD[controlFlags] nWidth;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x08) != 0|] COORD_FIELD[controlFlags] nHeight;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x10) != 0|] byte bRop;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x20) != 0|] byte nDeltaEntries;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x40) != 0|] VARIABLE2_DELTA_RECTS_FIELD[nDeltaEntries] CodedDeltaList;
}

type PATBLT_ORDER[ControlFlags controlFlags, array<byte> fieldFlags]
{
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x01) != 0|] COORD_FIELD[controlFlags] nLeftRect;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x02) != 0|] COORD_FIELD[controlFlags] nTopRect;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x04) != 0|] COORD_FIELD[controlFlags] nWidth;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x08) != 0|] COORD_FIELD[controlFlags] nHeight;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x10) != 0|] byte bRop;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x20) != 0|] TS_COLOR BackColor;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x40) != 0|] TS_COLOR ForeColor;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x80) != 0|] sbyte BrushOrgX;
    optional [|fieldFlags.Count > 1 && (fieldFlags[1] & 0x01) != 0|] sbyte BrushOrgY;
    optional [|fieldFlags.Count > 1 && (fieldFlags[1] & 0x02) != 0|] byte BrushStyle with DisplayInfo{ToText = BrushStyleToString};
    optional [|fieldFlags.Count > 1 && (fieldFlags[1] & 0x04) != 0|] byte BrushHatch with DisplayInfo{ToText = GetToTextForBrushHatch(BrushStyle)};
    optional [|fieldFlags.Count > 1 && (fieldFlags[1] & 0x08) != 0|] array<byte> BrushExtra with BinaryEncoding{Length = 7};
}

static string BrushStyleToString(any data)
{
    var d = data as (optional byte);
    if (d == nothing)
    {
        return "";
    }
    byte brushStyle = d as byte;
    byte lowNibble = (brushStyle & 0x0F) as byte;
    if ((brushStyle & 0x80) != 0)
    {
        if (InRange<BrushColorDepth>(lowNibble))
        {
            return EnumToString(lowNibble, "RDPBCGR.BrushColorDepth");
        }
    }
    else
    {
        if (InRange<BrushStyle>(brushStyle))
        {
            return EnumToString(brushStyle, "RDPBCGR.BrushStyle");
        }
    }
    return brushStyle.ToString() + " (" + Utility.DecToHexFormat(brushStyle) + ")";
}

pattern BrushColorDepth = enum byte
{
    BMF_1BPP    = 0x1,
    BMF_8BPP    = 0x3,
    BMF_16BPP   = 0x4,
    BMF_24BPP   = 0x5,
    BMF_32BPP   = 0x6,
};

pattern BrushStyle  = enum byte
{
    BS_SOLID    = 0x00,
    BS_NULL     = 0x01,
    BS_HATCHED  = 0x02,
    BS_PATTERN  = 0x03,
};

pattern BrushHatch = enum byte
{
    HS_HORIZONTAL   = 0x00,
    HS_VERTICAL     = 0x01,
    HS_FDIAGONAL    = 0x02,
    HS_BDIAGONAL    = 0x03,
    HS_CROSS        = 0x04,
    HS_DIAGCROSS    = 0x05,
};

string(any) GetToTextForBrushHatch(optional byte brushStyle)
{
    switch (brushStyle)
    {
        case 0x02 =>
            return BrushHatchToString;
        default =>
            return OptionalByteToString;            
    }
}

static string BrushHatchToString(any data)
{
    var d = data as (optional byte);
    if (d == nothing)
    {
        return "";
    }
    byte brushHatch = d as byte;
    if (InRange<BrushHatch>(brushHatch))
    {
        return EnumToString(brushHatch, "RDPBCGR.BrushHatch");
    }
    return brushHatch.ToString() + " (" + Utility.DecToHexFormat(brushHatch) + ")";
}

static string OptionalByteToString(any data)
{
    var d = data as (optional byte);
    if (d == nothing)
    {
        return "";
    }
    byte b = d as byte;
    return b.ToString() + " (" + Utility.DecToHexFormat(b) + ")";
}

type MULTI_PATBLT_ORDER[ControlFlags controlFlags, array<byte> fieldFlags]
{
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x01) != 0|] COORD_FIELD[controlFlags] nLeftRect;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x02) != 0|] COORD_FIELD[controlFlags] nTopRect;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x04) != 0|] COORD_FIELD[controlFlags] nWidth;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x08) != 0|] COORD_FIELD[controlFlags] nHeight;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x10) != 0|] byte bRop;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x20) != 0|] TS_COLOR BackColor;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x40) != 0|] TS_COLOR ForeColor;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x80) != 0|] sbyte BrushOrgX;
    optional [|fieldFlags.Count > 1 && (fieldFlags[1] & 0x01) != 0|] sbyte BrushOrgY;
    optional [|fieldFlags.Count > 1 && (fieldFlags[1] & 0x02) != 0|] byte BrushStyle with DisplayInfo{ToText = BrushStyleToString};
    optional [|fieldFlags.Count > 1 && (fieldFlags[1] & 0x04) != 0|] byte BrushHatch with DisplayInfo{ToText = GetToTextForBrushHatch(BrushStyle)};
    optional [|fieldFlags.Count > 1 && (fieldFlags[1] & 0x08) != 0|] array<byte> BrushExtra with BinaryEncoding{Length = 7};
    optional [|fieldFlags.Count > 1 && (fieldFlags[1] & 0x10) != 0|] byte nDeltaEntries;
    optional [|fieldFlags.Count > 1 && (fieldFlags[1] & 0x20) != 0|] VARIABLE2_DELTA_RECTS_FIELD[nDeltaEntries] CodedDeltaList;
}

type OPAQUERECT_ORDER[ControlFlags controlFlags, array<byte> fieldFlags]
{
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x01) != 0|] COORD_FIELD[controlFlags] nLeftRect;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x02) != 0|] COORD_FIELD[controlFlags] nTopRect;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x04) != 0|] COORD_FIELD[controlFlags] nWidth;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x08) != 0|] COORD_FIELD[controlFlags] nHeight;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x10) != 0|] byte RedOrPaletteIndex;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x20) != 0|] byte Green;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x40) != 0|] byte Blue;
}

type MULTI_OPAQUERECT_ORDER[ControlFlags controlFlags, array<byte> fieldFlags]
{
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x01) != 0|] COORD_FIELD[controlFlags] nLeftRect;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x02) != 0|] COORD_FIELD[controlFlags] nTopRect;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x04) != 0|] COORD_FIELD[controlFlags] nWidth;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x08) != 0|] COORD_FIELD[controlFlags] nHeight;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x10) != 0|] byte RedOrPaletteIndex;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x20) != 0|] byte Green;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x40) != 0|] byte Blue;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x80) != 0|] byte nDeltaEntries;
    optional [|fieldFlags.Count > 1 && (fieldFlags[1] & 0x01) != 0|] VARIABLE2_DELTA_RECTS_FIELD[nDeltaEntries] CodedDeltaList;
}

type SCRBLT_ORDER[ControlFlags controlFlags, array<byte> fieldFlags]
{
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x01) != 0|] COORD_FIELD[controlFlags] nLeftRect;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x02) != 0|] COORD_FIELD[controlFlags] nTopRect;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x04) != 0|] COORD_FIELD[controlFlags] nWidth;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x08) != 0|] COORD_FIELD[controlFlags] nHeight;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x10) != 0|] byte bRop;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x20) != 0|] COORD_FIELD[controlFlags] nXSrc;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x40) != 0|] COORD_FIELD[controlFlags] nYSrc;
}

type MULTI_SCRBLT_ORDER[ControlFlags controlFlags, array<byte> fieldFlags]
{
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x01) != 0|] COORD_FIELD[controlFlags] nLeftRect;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x02) != 0|] COORD_FIELD[controlFlags] nTopRect;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x04) != 0|] COORD_FIELD[controlFlags] nWidth;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x08) != 0|] COORD_FIELD[controlFlags] nHeight;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x10) != 0|] byte bRop;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x20) != 0|] COORD_FIELD[controlFlags] nXSrc;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x40) != 0|] COORD_FIELD[controlFlags] nYSrc;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x80) != 0|] byte nDeltaEntries;
    optional [|fieldFlags.Count > 1 && (fieldFlags[1] & 0x01) != 0|] VARIABLE2_DELTA_RECTS_FIELD[nDeltaEntries] CodedDeltaList;
}

type MEMBLT_ORDER[ControlFlags controlFlags, array<byte> fieldFlags]
{
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x01) != 0|] ushort cacheId;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x02) != 0|] COORD_FIELD[controlFlags] nLeftRect;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x04) != 0|] COORD_FIELD[controlFlags] nTopRect;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x08) != 0|] COORD_FIELD[controlFlags] nWidth;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x10) != 0|] COORD_FIELD[controlFlags] nHeight;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x20) != 0|] byte bRop;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x40) != 0|] COORD_FIELD[controlFlags] nXSrc;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x80) != 0|] COORD_FIELD[controlFlags] nYSrc;
    optional [|fieldFlags.Count > 1 && (fieldFlags[1] & 0x01) != 0|] ushort cacheIndex;
}

type MEM3BLT_ORDER[ControlFlags controlFlags, array<byte> fieldFlags]
{
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x01) != 0|] ushort cacheId;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x02) != 0|] COORD_FIELD[controlFlags] nLeftRect;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x04) != 0|] COORD_FIELD[controlFlags] nTopRect;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x08) != 0|] COORD_FIELD[controlFlags] nWidth;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x10) != 0|] COORD_FIELD[controlFlags] nHeight;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x20) != 0|] byte bRop;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x40) != 0|] COORD_FIELD[controlFlags] nXSrc;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x80) != 0|] COORD_FIELD[controlFlags] nYSrc;
    optional [|fieldFlags.Count > 1 && (fieldFlags[1] & 0x01) != 0|] TS_COLOR BackColor;
    optional [|fieldFlags.Count > 1 && (fieldFlags[1] & 0x02) != 0|] TS_COLOR ForeColor;
    optional [|fieldFlags.Count > 1 && (fieldFlags[1] & 0x04) != 0|] sbyte BrushOrgX;
    optional [|fieldFlags.Count > 1 && (fieldFlags[1] & 0x08) != 0|] sbyte BrushOrgY;
    optional [|fieldFlags.Count > 1 && (fieldFlags[1] & 0x10) != 0|] byte BrushStyle with DisplayInfo{ToText = BrushStyleToString};
    optional [|fieldFlags.Count > 1 && (fieldFlags[1] & 0x20) != 0|] byte BrushHatch with DisplayInfo{ToText = GetToTextForBrushHatch(BrushStyle)};
    optional [|fieldFlags.Count > 1 && (fieldFlags[1] & 0x40) != 0|] array<byte> BrushExtra with BinaryEncoding{Length = 7};
    optional [|fieldFlags.Count > 1 && (fieldFlags[1] & 0x80) != 0|] ushort cacheIndex;
}

type LINETO_ORDER[ControlFlags controlFlags, array<byte> fieldFlags]
{
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x01) != 0|] BackModeValue BackMode where ValidationCheckEnumValue((value == nothing || InRange<BackModeValue>(value as ushort)), null, true, ReferenceType.Type, "RDPBCGR", "BackMode", "LINETO_ORDER", "0x0001, 0x0002", value);
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x02) != 0|] COORD_FIELD[controlFlags] nXStart;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x04) != 0|] COORD_FIELD[controlFlags] nYStart;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x08) != 0|] COORD_FIELD[controlFlags] nXEnd;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x10) != 0|] COORD_FIELD[controlFlags] nYEnd;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x20) != 0|] TS_COLOR BackColor;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x40) != 0|] byte bRop2;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x80) != 0|] byte PenStyle where ValidationCheckZero(value == nothing || (value as byte) == 0x00, null, true, ReferenceType.Type, "RDPBCGR", "PenStyle", "LINETO_ORDER", value);
    optional [|fieldFlags.Count > 1 && (fieldFlags[1] & 0x01) != 0|] byte PenWidth where ValidationCheckValue(value == nothing || (value as byte) == 0x01, null, true, ReferenceType.Type, "RDPBCGR", "PenWidth", "LINETO_ORDER", 1, value);
    optional [|fieldFlags.Count > 1 && (fieldFlags[1] & 0x02) != 0|] TS_COLOR PenColor;
}

pattern BackModeValue = enum ushort
{
    TRANSPARENT = 0x0001,
    OPAQUE      = 0x0002,
    ...
};

type SAVEBITMAP_ORDER[ControlFlags controlFlags, array<byte> fieldFlags]
{
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x01) != 0|] uint SavedBitmapPosition;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x02) != 0|] COORD_FIELD[controlFlags] nLeftRect;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x04) != 0|] COORD_FIELD[controlFlags] nTopRect;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x08) != 0|] COORD_FIELD[controlFlags] nRightRect;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x10) != 0|] COORD_FIELD[controlFlags] nBottomRect;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x20) != 0|] OperationValue Operation where ValidationCheckEnumValue((value == nothing || InRange<OperationValue>(value as byte)), null, true, ReferenceType.Type, "RDPBCGR", "Operation", "SAVEBITMAP_ORDER", "0x00, 0x01", value);
}

pattern OperationValue = enum byte
{
    SV_SAVEBITS     = 0x00,
    SV_RESTOREBITS  = 0x01,
    ...
};

type GLYPHINDEX_ORDER[ControlFlags controlFlags, array<byte> fieldFlags]
{
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x01) != 0|] byte cacheId where ValidationCheckValueInRange((value == nothing || (value as byte <= 9 && value as byte >= 0)), null, true, ReferenceType.Type, "RDPBCGR", "cacheId", "GLYPHINDEX_ORDER", 0, 9, value);
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x02) != 0|] AcceleratorFlags flAccel where ValidationCheckCombinationValueTooManyItems((value == nothing || InRange<AcceleratorFlags>(value as byte)), null, true, ReferenceType.Type, "RDPBCGR", "flAccel", "GLYPHINDEX_ORDER", "GLYPHINDEX_ORDER", "[MS-RDPEGDI]");
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x04) != 0|] byte ulCharInc;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x08) != 0|] bool fOpRedundant;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x10) != 0|] TS_COLOR BackColor;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x20) != 0|] TS_COLOR ForeColor;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x40) != 0|] short BkLeft;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x80) != 0|] short BkTop;
    optional [|fieldFlags.Count > 1 && (fieldFlags[1] & 0x01) != 0|] short BkRight;
    optional [|fieldFlags.Count > 1 && (fieldFlags[1] & 0x02) != 0|] short BkBottom;
    optional [|fieldFlags.Count > 1 && (fieldFlags[1] & 0x04) != 0|] short OpLeft where ValidationCheck(value == nothing || fOpRedundant == nothing || !(fOpRedundant as bool) || ((fOpRedundant as bool) && (value as short == 0)), null, DiagnosisLevel.Error, () => Format(RDPBCGR_RDPEGDI_GLYPHINDEX_STR, ["OpLeft", value]));
    optional [|fieldFlags.Count > 1 && (fieldFlags[1] & 0x08) != 0|] short OpTop where ValidationCheck(value == nothing || fOpRedundant == nothing || !(fOpRedundant as bool) || ((fOpRedundant as bool) && (value as short == 0)), null, DiagnosisLevel.Error, () => Format(RDPBCGR_RDPEGDI_GLYPHINDEX_STR, ["OpTop", value]));
    optional [|fieldFlags.Count > 1 && (fieldFlags[1] & 0x10) != 0|] short OpRight where ValidationCheck(value == nothing || fOpRedundant == nothing || !(fOpRedundant as bool) || ((fOpRedundant as bool) && (value as short == 0)), null, DiagnosisLevel.Error, () => Format(RDPBCGR_RDPEGDI_GLYPHINDEX_STR, ["OpRight", value]));
    optional [|fieldFlags.Count > 1 && (fieldFlags[1] & 0x20) != 0|] short OpBottom where ValidationCheck(value == nothing || fOpRedundant == nothing || !(fOpRedundant as bool) || ((fOpRedundant as bool) && (value as short == 0)), null, DiagnosisLevel.Error, () => Format(RDPBCGR_RDPEGDI_GLYPHINDEX_STR, ["OpBottom", value]));
    optional [|fieldFlags.Count > 1 && (fieldFlags[1] & 0x40) != 0|] sbyte BrushOrgX;
    optional [|fieldFlags.Count > 1 && (fieldFlags[1] & 0x80) != 0|] sbyte BrushOrgY;
    optional [|fieldFlags.Count > 2 && (fieldFlags[2] & 0x01) != 0|] byte BrushStyle where ValidationCheckZero(value == nothing || (value as byte) == 0x00, null, true, ReferenceType.Type, "RDPBCGR", "BrushStyle", "GLYPHINDEX_ORDER", value);
    optional [|fieldFlags.Count > 2 && (fieldFlags[2] & 0x02) != 0|] byte BrushHatch where ValidationCheckZero(value == nothing || (value as byte) == 0x00, null, true, ReferenceType.Type, "RDPBCGR", "BrushHatch", "GLYPHINDEX_ORDER", value);
    optional [|fieldFlags.Count > 2 && (fieldFlags[2] & 0x04) != 0|] array<byte> BrushExtra with BinaryEncoding{Length = 7};
    optional [|fieldFlags.Count > 2 && (fieldFlags[2] & 0x08) != 0|] short X;
    optional [|fieldFlags.Count > 2 && (fieldFlags[2] & 0x10) != 0|] short Y;
    optional [|fieldFlags.Count > 2 && (fieldFlags[2] & 0x20) != 0|] VARIABLE1_FIELD VariableBytes;
}

pattern AcceleratorFlags = flags byte
{
    SO_FLAG_DEFAULT_PLACEMENT   = 0x01,
    SO_HORIZONTAL               = 0x02,
    SO_VERTICAL                 = 0x04,
    SO_REVERSED                 = 0x08,
    SO_ZERO_BEARINGS            = 0x10,
    SO_CHAR_INC_EQUAL_BM_BASE   = 0x20,
    SO_MAXEXT_EQUAL_BM_SIDE     = 0x40,
    ...
};

type FASTINDEX_ORDER[ControlFlags controlFlags, array<byte> fieldFlags]
{
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x01) != 0|] byte cacheId where ValidationCheckValueInRange((value == nothing || (value as byte <= 9 && value as byte >= 0)), null, true, ReferenceType.Type, "RDPBCGR", "cacheId", "FASTINDEX_ORDER", 0, 9, value);
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x02) != 0|] FDrawing fDrawing;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x04) != 0|] TS_COLOR BackColor;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x08) != 0|] TS_COLOR ForeColor;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x10) != 0|] COORD_FIELD[controlFlags] BkLeft;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x20) != 0|] COORD_FIELD[controlFlags] BkTop;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x40) != 0|] COORD_FIELD[controlFlags] BkRight;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x80) != 0|] COORD_FIELD[controlFlags] BkBottom;
    optional [|fieldFlags.Count > 1 && (fieldFlags[1] & 0x01) != 0|] COORD_FIELD[controlFlags] OpLeft;
    optional [|fieldFlags.Count > 1 && (fieldFlags[1] & 0x02) != 0|] COORD_FIELD[controlFlags] OpTop;
    optional [|fieldFlags.Count > 1 && (fieldFlags[1] & 0x04) != 0|] COORD_FIELD[controlFlags] OpRight;
    optional [|fieldFlags.Count > 1 && (fieldFlags[1] & 0x08) != 0|] COORD_FIELD[controlFlags] OpBottom;
    optional [|fieldFlags.Count > 1 && (fieldFlags[1] & 0x10) != 0|] COORD_FIELD[controlFlags] X;
    optional [|fieldFlags.Count > 1 && (fieldFlags[1] & 0x20) != 0|] COORD_FIELD[controlFlags] Y;
    optional [|fieldFlags.Count > 1 && (fieldFlags[1] & 0x40) != 0|] VARIABLE1_FIELD VariableBytes;
}

type FDrawing
{
    AcceleratorFlags flAccel;
    byte ulCharInc;
}

type FASTGLYPH_ORDER[ControlFlags controlFlags, array<byte> fieldFlags]
{
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x01) != 0|] byte cacheId where ValidationCheckValueInRange((value == nothing || (value as byte <= 9 && value as byte >= 0)), null, true, ReferenceType.Type, "RDPBCGR", "cacheId", "FASTGLYPH_ORDER", 0, 9, value);
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x02) != 0|] FDrawing fDrawing;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x04) != 0|] TS_COLOR BackColor;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x08) != 0|] TS_COLOR ForeColor;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x10) != 0|] COORD_FIELD[controlFlags] BkLeft;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x20) != 0|] COORD_FIELD[controlFlags] BkTop;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x40) != 0|] COORD_FIELD[controlFlags] BkRight;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x80) != 0|] COORD_FIELD[controlFlags] BkBottom;
    optional [|fieldFlags.Count > 1 && (fieldFlags[1] & 0x01) != 0|] COORD_FIELD[controlFlags] OpLeft;
    optional [|fieldFlags.Count > 1 && (fieldFlags[1] & 0x02) != 0|] COORD_FIELD[controlFlags] OpTop;
    optional [|fieldFlags.Count > 1 && (fieldFlags[1] & 0x04) != 0|] COORD_FIELD[controlFlags] OpRight;
    optional [|fieldFlags.Count > 1 && (fieldFlags[1] & 0x08) != 0|] COORD_FIELD[controlFlags] OpBottom;
    optional [|fieldFlags.Count > 1 && (fieldFlags[1] & 0x10) != 0|] COORD_FIELD[controlFlags] X;
    optional [|fieldFlags.Count > 1 && (fieldFlags[1] & 0x20) != 0|] COORD_FIELD[controlFlags] Y;
    optional [|fieldFlags.Count > 1 && (fieldFlags[1] & 0x40) != 0|] VARIABLE1_FIELD VariableBytes;
}

type POLYGON_SC_ORDER[ControlFlags controlFlags, array<byte> fieldFlags]
{
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x01) != 0|] COORD_FIELD[controlFlags] xStart;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x02) != 0|] COORD_FIELD[controlFlags] yStart;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x04) != 0|] byte bRop2;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x08) != 0|] FILL_MODE FillMode;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x10) != 0|] TS_COLOR BrushColor;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x20) != 0|] byte NumDeltaEntries;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x40) != 0|] VARIABLE1_DELTA_PTS_FIELD[NumDeltaEntries] CodedDeltaList;
}

type POLYGON_CB_ORDER[ControlFlags controlFlags, array<byte> fieldFlags]
{
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x01) != 0|] COORD_FIELD[controlFlags] xStart;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x02) != 0|] COORD_FIELD[controlFlags] yStart;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x04) != 0|] byte bRop2;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x08) != 0|] FILL_MODE FillMode;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x10) != 0|] TS_COLOR BackColor;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x20) != 0|] TS_COLOR ForeColor;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x40) != 0|] sbyte BrushOrgX;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x80) != 0|] sbyte BrushOrgY;
    optional [|fieldFlags.Count > 1 && (fieldFlags[1] & 0x01) != 0|] byte BrushStyle with DisplayInfo{ToText = BrushStyleToString};
    optional [|fieldFlags.Count > 1 && (fieldFlags[1] & 0x02) != 0|] byte BrushHatch with DisplayInfo{ToText = GetToTextForBrushHatch(BrushStyle)};
    optional [|fieldFlags.Count > 1 && (fieldFlags[1] & 0x04) != 0|] array<byte> BrushExtra with BinaryEncoding{Length = 7};
    optional [|fieldFlags.Count > 1 && (fieldFlags[1] & 0x08) != 0|] byte NumDeltaEntries;
    optional [|fieldFlags.Count > 1 && (fieldFlags[1] & 0x10) != 0|] VARIABLE1_DELTA_PTS_FIELD[NumDeltaEntries] CodedDeltaList;
}

type POLYLINE_ORDER[ControlFlags controlFlags, array<byte> fieldFlags]
{
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x01) != 0|] COORD_FIELD[controlFlags] xStart;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x02) != 0|] COORD_FIELD[controlFlags] yStart;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x04) != 0|] byte bRop2;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x08) != 0|] ushort BrushCacheEntry where ValidationCheckZero(value == nothing || value as ushort == 0, null, false, ReferenceType.Type, "RDPBCGR", "BrushCacheEntry", "POLYLINE_ORDER", value);
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x10) != 0|] TS_COLOR PenColor;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x20) != 0|] byte NumDeltaEntries;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x40) != 0|] VARIABLE1_DELTA_PTS_FIELD[NumDeltaEntries] CodedDeltaList;
}

type ELLIPSE_SC_ORDER[ControlFlags controlFlags, array<byte> fieldFlags]
{
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x01) != 0|] COORD_FIELD[controlFlags] LeftRect;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x02) != 0|] COORD_FIELD[controlFlags] TopRect;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x04) != 0|] COORD_FIELD[controlFlags] RightRect;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x08) != 0|] COORD_FIELD[controlFlags] BottomRect;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x10) != 0|] byte bRop2;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x20) != 0|] EllipseSCFillMode FillMode where ValidationCheckEnumValue(value == nothing || InRange<EllipseSCFillMode>(value as byte), null, true, ReferenceType.Type, "RDPBCGR", "FillMode", "ELLIPSE_SC_ORDER", "0x00, 0x01, 0x02", value);
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x40) != 0|] TS_COLOR Color;
}

pattern EllipseSCFillMode = enum byte
{
    NOFILL      = 0x00,
    ALTERNATE   = 0x01,
    WINDING     = 0x02,
    ...
};

type ELLIPSE_CB_ORDER[ControlFlags controlFlags, array<byte> fieldFlags]
{
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x01) != 0|] COORD_FIELD[controlFlags] LeftRect;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x02) != 0|] COORD_FIELD[controlFlags] TopRect;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x04) != 0|] COORD_FIELD[controlFlags] RightRect;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x08) != 0|] COORD_FIELD[controlFlags] BottomRect;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x10) != 0|] byte bRop2;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x20) != 0|] FILL_MODE FillMode;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x40) != 0|] TS_COLOR BackColor;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x80) != 0|] TS_COLOR ForeColor;
    optional [|fieldFlags.Count > 1 && (fieldFlags[1] & 0x01) != 0|] sbyte BrushOrgX;
    optional [|fieldFlags.Count > 1 && (fieldFlags[1] & 0x02) != 0|] sbyte BrushOrgY;
    optional [|fieldFlags.Count > 1 && (fieldFlags[1] & 0x04) != 0|] byte BrushStyle with DisplayInfo{ToText = BrushStyleToString};
    optional [|fieldFlags.Count > 1 && (fieldFlags[1] & 0x08) != 0|] byte BrushHatch with DisplayInfo{ToText = GetToTextForBrushHatch(BrushStyle)};
    optional [|fieldFlags.Count > 1 && (fieldFlags[1] & 0x10) != 0|] array<byte> BrushExtra with BinaryEncoding{Length = 7};
}

type DRAWNINEGRID_ORDER[ControlFlags controlFlags, array<byte> fieldFlags]
{
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x01) != 0|] COORD_FIELD[controlFlags] srcLeft;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x02) != 0|] COORD_FIELD[controlFlags] srcTop;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x04) != 0|] COORD_FIELD[controlFlags] srcRight;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x08) != 0|] COORD_FIELD[controlFlags] srcBottom;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x10) != 0|] ushort bitmapId;
}

type MULTI_DRAWNINEGRID_ORDER[ControlFlags controlFlags, array<byte> fieldFlags]
{
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x01) != 0|] COORD_FIELD[controlFlags] srcLeft;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x02) != 0|] COORD_FIELD[controlFlags] srcTop;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x04) != 0|] COORD_FIELD[controlFlags] srcRight;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x08) != 0|] COORD_FIELD[controlFlags] srcBottom;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x10) != 0|] ushort bitmapId;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x20) != 0|] byte nDeltaEntries;
    optional [|fieldFlags.Count > 0 && (fieldFlags[0] & 0x40) != 0|] VARIABLE2_DELTA_RECTS_FIELD[nDeltaEntries] CodedDeltaList;
}

// [MS-RDPEGDI] 2.2.2.2.1.2 Secondary Drawing Orders
// Put the field "extraFlags" and "orderType" in each secondary drawing order definition, as "extraFlags" is specific to each secondary drawing order.
type SECONDARY_DRAWING_ORDER_HEADER
{
    ControlFlags controlFlags where ((value & ControlFlags.TS_STANDARD) != 0 && (value & ControlFlags.TS_SECONDARY) != 0);
    short orderLength;
}

pattern SecondaryDrawingOrderType = enum byte
{
    TS_CACHE_BITMAP_UNCOMPRESSED        = 0x00,
    TS_CACHE_COLOR_TABLE                = 0x01,
    TS_CACHE_BITMAP_COMPRESSED          = 0x02,
    TS_CACHE_GLYPH                      = 0x03,
    TS_CACHE_BITMAP_UNCOMPRESSED_REV2   = 0x04,
    TS_CACHE_BITMAP_COMPRESSED_REV2     = 0x05,
    TS_CACHE_BRUSH                      = 0x07,
    TS_CACHE_BITMAP_COMPRESSED_REV3     = 0x08,
    ...
};

type TWO_BYTE_UNSIGNED_ENCODING
{
    TWO_BYTE_ENCODING_C c with BinaryEncoding{Width = 1};
    byte val1 with BinaryEncoding{Width = 7};
    optional [|c == 1|] byte val2;

    ushort Value()
    {
        ushort v = val1;
        if (c == 1)
        {
            v = (v << 8) + (val2 as byte) as ushort;
        }
        return v;
    }
    
    override string ToString()
    {
        ushort v = Value();
        return v.ToString();
    }
}

pattern TWO_BYTE_ENCODING_C = enum byte
{
    ONE_BYTE_VAL    = 0,
    TWO_BYTE_VAL    = 1
};

type TWO_BYTE_SIGNED_ENCODING
{
    TWO_BYTE_ENCODING_C c with BinaryEncoding{Width = 1};
    TWO_BYTE_SIGNED_ENCODING_S s with BinaryEncoding{Width = 1};
    byte val1 with BinaryEncoding{Width = 6};
    optional [|c == 1|] byte val2;

    override string ToString()
    {
        int v = val1;
        if (c == 1)
        {
            v = (v << 8) + (val2 as byte);
        }
        if (s == 1)
        {
            v = -v;
        }
        return v.ToString();
    }
}

pattern TWO_BYTE_SIGNED_ENCODING_S = enum byte
{
    POSITIVE_VAL    = 0,
    NEGATIVE_VAL    = 1
};

type FOUR_BYTE_UNSIGNED_ENCODING
{
    FOUR_BYTE_ENCODING_C c with BinaryEncoding{Width = 2};
    byte val1 with BinaryEncoding{Width = 6};
    optional [|c >= 1|] byte val2;
    optional [|c >= 2|] byte val3;
    optional [|c == 3|] byte val4;
    
    uint Value()
    {
        uint v = val1;
        if (c >= 1)
        {
            v = (v << 8) + (val2 as byte) as uint;
        }
        if (c >= 2)
        {
            v = (v << 8) + (val3 as byte) as uint;
        }
        if (c == 3)
        {
            v = (v << 8) + (val4 as byte) as uint;
        }
        return v;
    }
    
    override string ToString()
    {
        uint v = Value();
        return v.ToString();
    }
}

pattern FOUR_BYTE_ENCODING_C = enum byte
{
    ONE_BTYE_VAL    = 0,
    TWO_BYTE_VAL    = 1,
    THREE_BYTE_VAL  = 2,
    FOUR_BYTE_VAL   = 3
};

// [MS-RDPEGDI] 2.2.2.2.1.2.2. Cache Bitmap - Revision 1 (CACHE_BITMAP_ORDER)
type CACHE_BITMAP_ORDER : SECONDARY_DRAWING_ORDER_HEADER
{
    CacheBitmapOrderExtraFlags extraFlags;
    SecondaryDrawingOrderType orderType where (value == SecondaryDrawingOrderType.TS_CACHE_BITMAP_UNCOMPRESSED || value == SecondaryDrawingOrderType.TS_CACHE_BITMAP_COMPRESSED);
    byte cacheId;
    byte pad1Octet;
    byte bitmapWidth;
    byte bitmapHeight;
    BitmapBitsPerPel bitmapBitsPerPel where ValidationCheckEnumValue(InRange<BitmapBitsPerPel>(value), null, true, ReferenceType.Type, "RDPBCGR", "bitmapBitsPerPel", "CACHE_BITMAP_ORDER", "0x08, 0x10, 0x18, 0x20", value);
    ushort bitmapLength;
    ushort cacheIndex; 
    optional [|orderType == SecondaryDrawingOrderType.TS_CACHE_BITMAP_COMPRESSED && (extraFlags & CacheBitmapOrderExtraFlags.NO_BITMAP_COMPRESSION_HDR) == 0|] TSCDHeader bitmapComprHdr;
    binary bitmapDataStream with BinaryEncoding{Length = bitmapComprHdr == nothing ? (bitmapLength) : ((bitmapLength - 8))};
}

pattern BitmapBitsPerPel = enum byte
{
    CBR_8BPP   = 0x08,
    CBR_16BPP  = 0x10,
    CBR_24BPP  = 0x18,
    CBR_32BPP  = 0x20,
    ...
};

pattern CacheBitmapOrderExtraFlags = flags ushort
{
    NO_BITMAP_COMPRESSION_HDR   = 0x0400,
    ...
};

// [MS-RDPEGDI] 2.2.2.2.1.2.2. Cache Bitmap - Revision 2 (CACHE_BITMAP_REV2_ORDER)
type CACHE_BITMAP_REV2_ORDER : SECONDARY_DRAWING_ORDER_HEADER
{
    CacheBitmapRev2OrderExtraFlags extraFlags;
    SecondaryDrawingOrderType orderType where (value == SecondaryDrawingOrderType.TS_CACHE_BITMAP_UNCOMPRESSED_REV2 || value == SecondaryDrawingOrderType.TS_CACHE_BITMAP_COMPRESSED_REV2);
    optional [|(extraFlags.$"flags" & OperationalFlags.CBR2_PERSISTENT_KEY_PRESENT) != 0|] uint key1;
    optional [|(extraFlags.$"flags" & OperationalFlags.CBR2_PERSISTENT_KEY_PRESENT) != 0|] uint key2;
    TWO_BYTE_UNSIGNED_ENCODING bitmapWidth;
    optional [|(extraFlags.$"flags" & OperationalFlags.CBR2_HEIGHT_SAME_AS_WIDTH) == 0|] TWO_BYTE_UNSIGNED_ENCODING bitmapHeight;
    FOUR_BYTE_UNSIGNED_ENCODING bitmapLength;
    TWO_BYTE_UNSIGNED_ENCODING cacheIndex;
    optional [|orderType == SecondaryDrawingOrderType.TS_CACHE_BITMAP_COMPRESSED_REV2 && (extraFlags.$"flags" & OperationalFlags.CBR2_NO_BITMAP_COMPRESSION_HDR) == 0|] TSCDHeader bitmapComprHdr;
    binary bitmapDataStream with BinaryEncoding{Length = bitmapComprHdr == nothing ? bitmapLength.Value() : ((bitmapLength.Value() - 8))};
}

type CacheBitmapRev2OrderExtraFlags
{
    OperationalFlags $"flags" where ValidationCheckCombinationValueIncludeZero(InRange<OperationalFlags>(value), null, false, ReferenceType.Type, "RDPBCGR", "flags", "CacheBitmapRev2OrderExtraFlags", "0x01, 0x02, 0x08, 0x10", value) 
        with BinaryEncoding{Endian = Endian.Big, Width = 9};
    BitsPerPixelId2 bitsPerPixelId where ValidationCheckEnumValue(InRange<BitsPerPixelId2>(value), null, true, ReferenceType.Type, "RDPBCGR", "bitsPerPixelId", "CacheBitmapRev2OrderExtraFlags", "0x3, 0x4, 0x5, 0x6", value) 
        with BinaryEncoding{Width = 4};
    byte cacheId with BinaryEncoding{Width = 3};
} with BinaryEncoding{WidthForComposedType = 16, DecodeAsUnit = true};

pattern BitsPerPixelId2 = enum byte
{
    CBR2_8BPP   = 0x3,
    CBR2_16BPP  = 0x4,
    CBR2_24BPP  = 0x5,
    CBR2_32BPP  = 0x6,
    ...
};

pattern OperationalFlags = flags ushort
{
    CBR2_HEIGHT_SAME_AS_WIDTH       = 0x01,
    CBR2_PERSISTENT_KEY_PRESENT     = 0x02,
    CBR2_NO_BITMAP_COMPRESSION_HDR  = 0x08,
    CBR2_DO_NOT_CACHE               = 0x10,
    ...
};

// [MS-RDPEGDI] 2.2.2.2.1.2.4 Cache Color Table (CACHE_COLOR_TABLE_ORDER)
type CACHE_COLOR_TABLE_ORDER : SECONDARY_DRAWING_ORDER_HEADER
{
    ushort extraFlags;
    SecondaryDrawingOrderType orderType where (value == SecondaryDrawingOrderType.TS_CACHE_COLOR_TABLE);
    byte cacheIndex;
    ushort numberColors where ValidationCheckValue(value == 256, null, true, ReferenceType.Type, "RDPBCGR", "numberColors", "CACHE_COLOR_TABLE_ORDER", 256, value);
    array<TS_COLOR_QUAD> colorTable with BinaryEncoding{Length = numberColors};
}

type TS_COLOR_QUAD
{
    byte blue;
    byte green;
    byte red;
    byte pad1Octet;
}

// [MS-RDPEGDI] 2.2.2.2.1.2.5 Cache Glyph - Revision 1 (CACHE_GLYPH_ORDER)
type CACHE_GLYPH_ORDER : SECONDARY_DRAWING_ORDER_HEADER
{
    CacheGlyphOrderExtraFlags extraFlags;
    SecondaryDrawingOrderType orderType where (value == SecondaryDrawingOrderType.TS_CACHE_GLYPH);
    byte cacheId;
    byte cGlyphs;
    array<TS_CACHE_GLYPH_DATA> glyphData with BinaryEncoding{Length = cGlyphs};
    string unicodeCharacters with BinaryEncoding{TextEncoding= TextEncoding.Unicode, Length = cGlyphs};
}

pattern CacheGlyphOrderExtraFlags = flags ushort
{
    CG_GLYPH_UNICODE_PRESENT    = 0x0100,
    ...
};

type TS_CACHE_GLYPH_DATA
{
    ushort cacheIndex;
    short x;
    short y;
    ushort cx;
    ushort cy;
    array<byte> aj with BinaryEncoding{Length = ((((cx + 7) / 8) * cy + 3) / 4) * 4};
}

// [MS-RDPEGDI] 2.2.2.2.1.2.6 Cache Glyph - Revision 2 (CACHE_GLYPH_REV2_ORDER)
type CACHE_GLYPH_REV2_ORDER : SECONDARY_DRAWING_ORDER_HEADER
{
    CacheClyphRev2OrderExtraFlags extraFlags;
    SecondaryDrawingOrderType orderType where (value == SecondaryDrawingOrderType.TS_CACHE_GLYPH);
    array<TS_CACHE_GLYPH_DATA_REV2> glyphDataRev2 with BinaryEncoding{Length = extraFlags.cGlyphs};
    string unicodeCharaters with BinaryEncoding{TextEncoding= TextEncoding.Unicode, Length = extraFlags.cGlyphs};
}

type CacheClyphRev2OrderExtraFlags
{
    OperationalFlags2 $"flags" where (ValidationCheckCombinationValueIncludeZero(InRange<OperationalFlags2>(value), null, false, ReferenceType.Type, "RDPBCGR", "flags", "CacheClyphRev2OrderExtraFlags", "0x1, 0x2", value) && (value & OperationalFlags2.GLY_ORDER_REV2) != 0)
         with BinaryEncoding{Width = 4};
    byte cacheId with BinaryEncoding{Width = 4};
    byte cGlyphs;
}

pattern OperationalFlags2 = flags byte
{
    CG2_GLYPH_UNOCODE_PRESENT   = 0x1,
    GLY_ORDER_REV2              = 0x2,
    ...
};

type TS_CACHE_GLYPH_DATA_REV2
{
    byte cacheIndex;
    TWO_BYTE_SIGNED_ENCODING x;
    TWO_BYTE_SIGNED_ENCODING y;
    TWO_BYTE_UNSIGNED_ENCODING cx;
    TWO_BYTE_UNSIGNED_ENCODING cy;
    array<byte> aj with BinaryEncoding{Length = ((((cx.Value() + 7) / 8) * cy.Value() + 3) / 4) * 4};
}

// [MS-RDPEGDI] 2.2.2.2.1.2.7 Cache Brush (CACHE_BRUSH_ORDER)
type CACHE_BRUSH_ORDER : SECONDARY_DRAWING_ORDER_HEADER
{
    ushort extraFlags;
    SecondaryDrawingOrderType orderType where (value == SecondaryDrawingOrderType.TS_CACHE_BRUSH);
    byte cacheEntry where ValidationCheckValueInRange(value >= 0 && value <= 63, null, true, ReferenceType.Type, "RDPBCGR", "cacheEntry", "CACHE_BRUSH_ORDER", 0, 63, value);
    CacheBrushOrderIBitmapFormat iBitmapFormat where ValidationCheckEnumValue(InRange<CacheBrushOrderIBitmapFormat>(value), null, true, ReferenceType.Type, "RDPBCGR", "iBitmapFormat", "CACHE_BRUSH_ORDER", "0x01, 0x03, 0x04, 0x05, 0x06", value);
    byte cx;
    byte cy;
    byte Style where ValidationCheckZero(value == 0, null, false, ReferenceType.Type, "RDPBCGR", "Style", "CACHE_BRUSH_ORDER", value);
    byte iBytes;
    array<byte> brushData with BinaryEncoding{Length = iBytes};
}

pattern CacheBrushOrderIBitmapFormat = enum byte
{
    BMF_1BPP        = 0x01,
    BMF_8BPP        = 0x03,
    BMF_16BPP       = 0x04,
    BMF_24BPP       = 0x05,
    BMF_32BPP       = 0x06,
    ...
};

// [MS-RDPEGDI] 2.2.2.2.1.2.8 Cache Bitmap - Revision 3 (CACHE_BITMAP_REV3_ORDER)
type CACHE_BITMAP_REV3_ORDER : SECONDARY_DRAWING_ORDER_HEADER
{
    CacheBitmapRev3OrderExtraFlags extraFlags;
    SecondaryDrawingOrderType orderType where (value == SecondaryDrawingOrderType.TS_CACHE_BITMAP_COMPRESSED_REV3);
    ushort cacheIndex;
    uint key1;
    uint key2;
    TSBitmapDataEX bitmapDataStream;
}

type CacheBitmapRev3OrderExtraFlags
{
    OperationalFlags3 $"flags" where ValidationCheckCombinationValueIncludeZero(InRange<OperationalFlags3>(value), null, false, ReferenceType.Type, "RDPBCGR", "flags", "CacheBitmapRev3OrderExtraFlags", "0x08, 0x10", value)
        with BinaryEncoding{Width = 9, Endian = Endian.Big};
    BitsPerPixelId3 bitsPerPixelId where ValidationCheckEnumValue(InRange<BitsPerPixelId3>(value), null, true, ReferenceType.Type, "RDPBCGR", "bitsPerPixelId", "CacheBitmapRev3OrderExtraFlags", "0x3, 0x4, 0x5, 0x6", value)
        with BinaryEncoding{Width = 4};
    byte cacheId with BinaryEncoding{Width = 3};
} with BinaryEncoding{WidthForComposedType = 16, DecodeAsUnit = true};

pattern OperationalFlags3 = flags ushort
{
    CBR3_IGNORABLE_FLAG = 0x08,
    CBR3_DO_NOT_CACHE   = 0x10,
    ...
};

pattern BitsPerPixelId3 = enum byte
{
    CBR23_8BPP  = 0x3,
    CBR23_16BPP = 0x4,
    CBR23_24BPP = 0x5,
    CBR23_32BPP = 0x6,
    ...
};

// [MS-RDPEGDI] 2.2.2.2.1.3 Alternate Secondary Drawing Orders
type AltSecDrawingOrderControlFlags
{
    AltSecDrawingOrderType orderType with BinaryEncoding{Width = 6};
    byte class where value == 0x02 with BinaryEncoding{Width = 2};
}

pattern AltSecDrawingOrderType = enum byte
{
    TS_ALTSEC_SWITCH_SURFACE            = 0x00,
    TS_ALTSEC_CREATE_OFFSCR_BITMAP      = 0x01,
    TS_ALTSEC_STREAM_BITMAP_FIRST       = 0x02,
    TS_ALTSEC_STREAM_BITMAP_NEXT        = 0x03,
    TS_ALTSEC_CREATE_NINEGRID_BITMAP    = 0x04,
    TS_ALTSEC_GDIP_FIRST                = 0x05,
    TS_ALTSEC_GDIP_NEXT                 = 0x06,
    TS_ALTSEC_GDIP_END                  = 0x07,
    TS_ALTSEC_GDIP_CACHE_FIRST          = 0x08,
    TS_ALTSEC_GDIP_CACHE_NEXT           = 0x09,
    TS_ALTSEC_GDIP_CACHE_END            = 0x0A,
    TS_ALTSEC_WINDOW                    = 0x0B,
    TS_ALTSEC_COMPDESK_FIRST            = 0x0C,
    TS_ALTSEC_FRAME_MARKER              = 0x0D, 
};

// [MS-RDPEGDI] 2.2.2.2.1.3.2 Create Offscreen Bitmap (CREATE_OFFSCR_BITMAP_ORDER)
type CREATE_OFFSCR_BITMAP_ORDER
{
    AltSecDrawingOrderControlFlags controlFlags where value.orderType == AltSecDrawingOrderType.TS_ALTSEC_CREATE_OFFSCR_BITMAP;
    CreateOffscrBitmapOrderFlags $"flags";
    ushort cx;
    ushort cy;
    optional [|$"flags".d != 0|] OFFSRC_DELETE_LIST deleteList;
}

type CreateOffscrBitmapOrderFlags
{
    byte d with BinaryEncoding{Width = 1};
    ushort offscreenBitmapId with BinaryEncoding{Width = 15, Endian = Endian.Big};
} with BinaryEncoding{WidthForComposedType = 16, DecodeAsUnit = true};

type OFFSRC_DELETE_LIST
{
    ushort cIndices;
    array<ushort> indices with BinaryEncoding{Length = cIndices};
}

// [MS-RDPEGDI] 2.2.2.2.1.3.3 Switch Surface (SWITCH_SURFACE_ORDER)
type SWITCH_SURFACE_ORDER
{
    AltSecDrawingOrderControlFlags controlFlags where value.orderType == AltSecDrawingOrderType.TS_ALTSEC_SWITCH_SURFACE;
    ushort bitmapId;
}

// [MS-RDPEGDI] 2.2.2.2.1.3.4 Create NineGrid Bitmap (CREATE_NINEGRID_BITMAP_ORDER)
type CREATE_NINEGRID_BITMAP_ORDER
{
    AltSecDrawingOrderControlFlags controlFlags where value.orderType == AltSecDrawingOrderType.TS_ALTSEC_CREATE_NINEGRID_BITMAP;
    byte BitmapBpp where ValidationCheckValue(value == 0x20, null, true, ReferenceType.Type, "RDPBCGR", "BitmapBpp", "CREATE_NINEGRID_BITMAP_ORDER", 0x20, value);
    ushort BitmapId;
    ushort cx;
    ushort cy;
    NINEGRID_BITMAP_INFO nineGridInfo;
}

type NINEGRID_BITMAP_INFO
{
    NineGridBitmapInfoFlags flFlags where ValidationCheckCombinationValueTooManyItems(InRange<NineGridBitmapInfoFlags>(value), null, false, ReferenceType.Type, "RDPBCGR", "flFlags", "NINEGRID_BITMAP_INFO", "NINEGRID_BITMAP_INFO", "[MS-RDPEGDI]");
    ushort ulLeftWidth;
    ushort ulRightWidth;
    ushort ulTopHeight;
    ushort ulBottomHeight;
    TS_COLORREF crTransparent;
}

pattern NineGridBitmapInfoFlags = flags uint
{
    DSDNG_STRETCH           = 0x00000001,
    DSDNG_TILE              = 0x00000002,
    DSDNG_PERPIXLELALPHA    = 0x00000004,
    DSDNG_TRANSPARENT       = 0x00000008,
    DSDNG_MUSTFLIP          = 0x00000010,
    DSDNG_TRUESIZE          = 0x00000020,
    ...
};

type TS_COLORREF
{
    byte red;
    byte green;
    byte blue;
    byte zeroPad;
}

// [MS-RDPEGDI] 2.2.2.2.1.3.5 Stream Bitmap Orders
// [MS-RDPEGDI] 2.2.2.2.1.3.5.1 Stream Bitmap First (STREAM_BITMAP_FIRST_ORDER)
type STREAM_BITMAP_FIRST_ORDER
{
    AltSecDrawingOrderControlFlags controlFlags where value.orderType == AltSecDrawingOrderType.TS_ALTSEC_STREAM_BITMAP_FIRST;
    StreamBitmapFirstOrderBitmapFlags BitmapFlags where ValidationCheckCombinationValueIncludeZero(InRange<StreamBitmapFirstOrderBitmapFlags>(value), null, false, ReferenceType.Type, "RDPBCGR", "BitmapFlags", "STREAM_BITMAP_FIRST_ORDER", "0x01, 0x02, 0x04", value);
    byte BitmapBpp;
    StreamBitmapFirstOrderBitmapType BitmapType where ValidationCheckValue(value == 0x0001, null, false, ReferenceType.Type, "RDPBCGR", "BitmapType", "STREAM_BITMAP_FIRST_ORDER", 0x0001, value);
    ushort BitmapWidth;
    ushort BitmapHeight;
    ([|(BitmapFlags & StreamBitmapFirstOrderBitmapFlags.STREAM_BITMAP_REV2) != 0|] uint | ushort ) BitmapSize;
    ushort BitmapBlockSize;
    array<byte> BitmapBlock with BinaryEncoding{Length = BitmapBlockSize};
}

pattern StreamBitmapFirstOrderBitmapFlags = flags byte
{
    STREAM_BITMAP_END           = 0x01,
    STREAM_BITMAP_COMPRESSED    = 0x02,
    STREAM_BITMAP_REV2          = 0x04,
    ...
};

pattern StreamBitmapFirstOrderBitmapType = enum ushort
{
    TS_DRAW_NINEGRID_BITMAP_CACHE   = 0x0001,
    ...
};

// [MS-RDPEGDI] 2.2.2.2.1.3.5.2 Stream Bitmap Next (STREAM_BITMAP_NEXT_ORDER)
type STREAM_BITMAP_NEXT_ORDER
{
    AltSecDrawingOrderControlFlags controlFlags where value.orderType == AltSecDrawingOrderType.TS_ALTSEC_STREAM_BITMAP_NEXT;
    StreamBitmapNextOrderBitmapFlags BitmapFlags where ValidationCheckCombinationValueIncludeZero(InRange<StreamBitmapNextOrderBitmapFlags>(value), null, false, ReferenceType.Type, "RDPBCGR", "BitmapFlags", "STREAM_BITMAP_NEXT_ORDER", "0x01, 0x02", value);
    StreamBitmapNextOrderBitmapType BitmapType where ValidationCheckValue(value == 0x0001, null, false, ReferenceType.Type, "RDPBCGR", "BitmapType", "STREAM_BITMAP_NEXT_ORDER", 0x0001, value);
    ushort BitmapBlockSize;
    array<byte> BitmapBlock with BinaryEncoding{Length = BitmapBlockSize};
}

pattern StreamBitmapNextOrderBitmapFlags = flags byte
{
    STREAM_BITMAP_END           = 0x01,
    STREAM_BITMAP_COMPRESSED    = 0x02,
    ...
};

pattern StreamBitmapNextOrderBitmapType = enum ushort
{
    TS_DRAW_NINEGRID_BITMAP_CACHE   = 0x0001,
    ...
};

// [MS-RDPEGDI] 2.2.2.2.1.3.6 GDI+ Orders
type DRAW_GDIPLUS_CACHE_TYPE
{
    DrawGDIPlusCacheType cacheType where ValidationCheckEnumValue(InRange<DrawGDIPlusCacheType>(value), null, false, ReferenceType.Type, "RDPBCGR", "cacheType", "DRAW_GDIPLUS_CACHE_TYPE", "0x0001, 0x0002, 0x0003, 0x0004, 0x0005", value);
}

pattern DrawGDIPlusCacheType = enum ushort
{
    GDIP_CACHE_GRAPHICS_DATA            = 0x0001,
    GDIP_CACHE_OBJECT_BRUSH             = 0x0002,
    GDIP_CACHE_OBJECT_PEN               = 0x0003,
    GDIP_CACHE_OBJECT_IMAGE             = 0x0004,
    GDIP_CACHE_OBJECT_IMAGEATTRIBUTES   = 0x0005,
    ...
};

// [MS-RDPEGDI] 2.2.2.2.1.3.6.2 Draw GDI+ Cache First (DRAW_GDIPLUS_CACHE_FIRST_ORDER)
type DRAW_GDIPLUS_CACHE_FIRST_ORDER
{
    AltSecDrawingOrderControlFlags controlFlags where value.orderType == AltSecDrawingOrderType.TS_ALTSEC_GDIP_CACHE_FIRST;
    DrawGDIPlusCacheOrderFlags Flags where ValidationCheckCombinationValueIncludeZero(InRange<DrawGDIPlusCacheOrderFlags>(value), null, false, ReferenceType.Type, "RDPBCGR", "Flags", "DRAW_GDIPLUS_CACHE_FIRST_ORDER", "0x01", value);
    DRAW_GDIPLUS_CACHE_TYPE CacheType;
    ushort CacheIndex;
    ushort cbSize;
    uint cbTotalSize;
    array<EMFRecord> emfRecords with BinaryEncoding{WidthForComposedType = cbSize * 8};
}

pattern DrawGDIPlusCacheOrderFlags = flags byte
{
    GDIP_REMOVE_CACHEENTRY  = 0x01,
    ...
};

// [MS-RDPEGDI] 2.2.2.2.1.3.6.3 Draw GDI+ Cache Next (DRAW_GDIPLUS_CACHE_NEXT_ORDER)
type DRAW_GDIPLUS_CACHE_NEXT_ORDER
{
    AltSecDrawingOrderControlFlags controlFlags where value.orderType == AltSecDrawingOrderType.TS_ALTSEC_GDIP_CACHE_NEXT;
    DrawGDIPlusCacheOrderFlags Flags;
    DRAW_GDIPLUS_CACHE_TYPE CacheType;
    ushort CacheIndex;
    ushort cbSize;
    array<EMFRecord> emfRecords with BinaryEncoding{WidthForComposedType = cbSize * 8};
}

// [MS-RDPEGDI] 2.2.2.2.1.3.6.4 Draw GDI+ Cache End (DRAW_GDIPLUS_CACHE_END_ORDER)
type DRAW_GDIPLUS_CACHE_END_ORDER
{
    AltSecDrawingOrderControlFlags controlFlags where value.orderType == AltSecDrawingOrderType.TS_ALTSEC_GDIP_CACHE_END;
    DrawGDIPlusCacheOrderFlags Flags;
    DRAW_GDIPLUS_CACHE_TYPE CacheType;
    ushort CacheIndex;
    ushort cbSize;
    uint cbTotalSize;
    array<EMFRecord> emfRecords with BinaryEncoding{WidthForComposedType = cbSize * 8};
}

// [MS-RDPEGDI] 2.2.2.2.1.3.6.5 Draw GDI+ First (DRAW_GDIPLUS_FIRST_ORDER)
type DRAW_GDIPLUS_FIRST_ORDER
{
    AltSecDrawingOrderControlFlags controlFlags where value.orderType == AltSecDrawingOrderType.TS_ALTSEC_GDIP_FIRST;
    byte pad1Octet;
    ushort cbSize;
    uint cbTotalSize;
    uint cbTotalEmfSize;
    array<DRAW_GDIPLUS_EMF_Record | EMFRecord> emfRecords with BinaryEncoding{WidthForComposedType = cbSize * 8};
}

type DRAW_GDIPLUS_EMF_Record
{
    RecordType Type;
    ushort Flags;
    uint Size where ((value & 0x80000000) != 0);
    uint DataSize;
    ushort CacheIndex;    
}

// [MS-RDPEGDI] 2.2.2.2.1.3.6.6 Draw GDI+ Next (DRAW_GDIPLUS_NEXT_ORDER)
type DRAW_GDIPLUS_NEXT_ORDER
{
    AltSecDrawingOrderControlFlags controlFlags where value.orderType == AltSecDrawingOrderType.TS_ALTSEC_GDIP_NEXT;
    byte pad1Octet;
    ushort cbSize;
    array<DRAW_GDIPLUS_EMF_Record | EMFRecord> emfRecords with BinaryEncoding{WidthForComposedType = cbSize * 8};
}

// [MS-RDPEGDI] 2.2.2.2.1.3.6.7 Draw GDI+ End (DRAW_GDIPLUS_END_ORDER)
type DRAW_GDIPLUS_END_ORDER
{
    AltSecDrawingOrderControlFlags controlFlags where value.orderType == AltSecDrawingOrderType.TS_ALTSEC_GDIP_END;
    byte pad1Octet;
    ushort cbSize;
    uint cbTotalSize;
    uint cbTotalEmfSize;
    array<DRAW_GDIPLUS_EMF_Record | EMFRecord> emfRecords with BinaryEncoding{WidthForComposedType = cbSize * 8};
}

// [MS-RDPEGDI] 2.2.2.2.1.3.7 Frame Marker
type FRAME_MARKER_ORDER
{
    AltSecDrawingOrderControlFlags controlFlags where value.orderType == AltSecDrawingOrderType.TS_ALTSEC_FRAME_MARKER;
    FrameMarkerAction action where ValidationCheckEnumValue(InRange<FrameMarkerAction>(value), null, false, ReferenceType.Type, "RDPBCGR", "action", "FRAME_MARKER_ORDER", "0x00000000, 0x00000001", value);
}

pattern FrameMarkerAction = enum uint
{
    TS_FRAME_START  = 0x00000000,
    TS_FRAME_END    = 0x00000001,
    ...
};

optional any DecodingOrderData(stream data, byte orderType)
{
    byte controlFlags = data.PeekBytes(data.BitPosition, 1)[0];
    // Primary Drawing Orders
    if ((controlFlags & ControlFlags.TS_STANDARD) != 0 && (controlFlags & ControlFlags.TS_SECONDARY) == 0)
    {
        return BinaryDecoder<PRIMARY_DRAWING_ORDER[orderType]>(data);
    }
    // Secondary Drawing Orders
    else if ((controlFlags & ControlFlags.TS_STANDARD) != 0 && (controlFlags & ControlFlags.TS_SECONDARY) != 0)
    {
        if (data.RemainingByteLength < 6)
        {
            return nothing;
        }
        byte secOrderType = data.PeekBytes(data.BitPosition + 40, 1)[0];
        switch (secOrderType)
        {
            
            case SecondaryDrawingOrderType.TS_CACHE_BITMAP_UNCOMPRESSED =>
                return BinaryDecoder<CACHE_BITMAP_ORDER>(data);
            case SecondaryDrawingOrderType.TS_CACHE_COLOR_TABLE =>
                return BinaryDecoder<CACHE_COLOR_TABLE_ORDER>(data);
            case SecondaryDrawingOrderType.TS_CACHE_BITMAP_COMPRESSED =>
                return BinaryDecoder<CACHE_BITMAP_ORDER>(data);
            case SecondaryDrawingOrderType.TS_CACHE_GLYPH =>
                switch (data)
                {
                    case order:CACHE_GLYPH_REV2_ORDER from BinaryDecoder<CACHE_GLYPH_REV2_ORDER> =>
                        return order;
                    case order:CACHE_GLYPH_ORDER from BinaryDecoder<CACHE_GLYPH_ORDER> =>
                        return order;
                    default =>
                        return nothing;
                }
            case SecondaryDrawingOrderType.TS_CACHE_BITMAP_UNCOMPRESSED_REV2 =>
                return BinaryDecoder<CACHE_BITMAP_REV2_ORDER>(data);
            case SecondaryDrawingOrderType.TS_CACHE_BITMAP_COMPRESSED_REV2 =>
                return BinaryDecoder<CACHE_BITMAP_REV2_ORDER>(data);
            case SecondaryDrawingOrderType.TS_CACHE_BRUSH =>
                return BinaryDecoder<CACHE_BRUSH_ORDER>(data);
            case SecondaryDrawingOrderType.TS_CACHE_BITMAP_COMPRESSED_REV3 =>
                return BinaryDecoder<CACHE_BITMAP_REV3_ORDER>(data);
            default =>
                return nothing;
        }
    }
    // Alternate Secondary Drawing Orders
    else
    {
        switch (data)
        {
            case order:CREATE_OFFSCR_BITMAP_ORDER from BinaryDecoder<CREATE_OFFSCR_BITMAP_ORDER> =>
                return order;
            case order:SWITCH_SURFACE_ORDER from BinaryDecoder<SWITCH_SURFACE_ORDER> =>
                return order;
            case order:CREATE_NINEGRID_BITMAP_ORDER from BinaryDecoder<CREATE_NINEGRID_BITMAP_ORDER> =>
                return order;
            case order:STREAM_BITMAP_FIRST_ORDER from BinaryDecoder<STREAM_BITMAP_FIRST_ORDER> =>
                return order;
            case order:STREAM_BITMAP_NEXT_ORDER from BinaryDecoder<STREAM_BITMAP_NEXT_ORDER> =>
                return order;
            case order:DRAW_GDIPLUS_CACHE_FIRST_ORDER from BinaryDecoder<DRAW_GDIPLUS_CACHE_FIRST_ORDER> =>
                return order;
            case order:DRAW_GDIPLUS_CACHE_NEXT_ORDER from BinaryDecoder<DRAW_GDIPLUS_CACHE_NEXT_ORDER> =>
                return order;
            case order:DRAW_GDIPLUS_CACHE_END_ORDER from BinaryDecoder<DRAW_GDIPLUS_CACHE_END_ORDER> =>
                return order;
            case order:DRAW_GDIPLUS_FIRST_ORDER from BinaryDecoder<DRAW_GDIPLUS_FIRST_ORDER> =>
                return order;
            case order:DRAW_GDIPLUS_NEXT_ORDER from BinaryDecoder<DRAW_GDIPLUS_NEXT_ORDER> =>
                return order;
            case order:DRAW_GDIPLUS_END_ORDER from BinaryDecoder<DRAW_GDIPLUS_END_ORDER> =>
                return order;
            case order:FRAME_MARKER_ORDER from BinaryDecoder<FRAME_MARKER_ORDER> =>
                return order;
            default =>
                return nothing;
        }
    }
}

// Types in [MS-RDPERP], This should be removed after RDPERP is implemented
// [MS-RDPERP] 2.2.1.1.1   Remote Programs Capability Set
type TSRemoteProgramsCapabilitySet
{
    ushort CapabilitySetType where value == 0x0017
        with Documentation
           {Description = "An unsigned 16-bit integer. The type of the capability set. This field MUST be set to 0x0017 (CAPSETTYPE_RAIL)."};
           
    ushort LengthCapability
        with Documentation
           {Description = "A 16-bit, unsigned integer. The length, in bytes, of the capability data, including the size of the capabilitySetType and lengthCapability fields."};
           
    uint RailSupportLevel        
        with Documentation
           {Description = "A 4 byte bitfield specifying support for Remote Programs and the Docked Language Bar for Remote Programs."};
}               
with Documentation
       {Applicability = "2.2.1.1.1",
        Description = "The Remote Programs Capability Set is sent by the server in the Demand Active PDU and by the client in the Confirm Active PDU, as specified in [MS-RDPBCGR] section 2.2.1.13. It indicates that the client and server are capable of communicating RAIL PDUs over the RAIL static virtual channel."};

// [MS-RDPERP] 2.2.1.1.2   Window List Capability Set
pattern WndSupportLevelValue = enum uint
{
    TS_WINDOW_LEVEL_NOT_SUPPORTED = 0x00000000
        with Documentation
           {Description = "The client or server is not capable of supporting Windowing Alternate Secondary Drawing Orders."},
           
    TS_WINDOW_LEVEL_SUPPORTED = 0x00000001
        with Documentation
           {Description = "The client or server is capable of supporting Windowing Alternate Secondary Drawing Orders."},
           
    TS_WINDOW_LEVEL_SUPPORTED_EX = 0x00000002
        with Documentation
           {Description = "The client or server is capable of supporting Windowing Alternate Secondary Drawing Orders and the following flags: WINDOW_ORDER_FIELD_CLIENTAREASIZE, WINDOW_ORDER_FIELD_RPCONTENT, WINDOW_ORDER_FIELD_ROOTPARENT."}
}with Documentation {EmbeddedType = true};
         
type TSWindowListCapabilitySet
{
    ushort CapabilitySetType where value == 0x0018
        with Documentation
           {Description = "An unsigned 16-bit integer. The type of capability set. This field MUST be set to 0x0018 (CAPSETTYPE_WINDOW)."};
           
    ushort LengthCapability
        with Documentation
           {Description = "A 16-bit, unsigned integer. The length, in bytes, of the capability data, including the size of the capabilitySetType and lengthCapability fields."};
    
    WndSupportLevelValue WndSupportLevel
        with Documentation
           {Description = "An unsigned 32-bit integer. The windowing support level. This field MUST be set to one of the following values."};
            
    byte NumIconCaches 
        with Documentation
           {Description = "An unsigned 8-bit integer. The number of icon caches requested by the server (Demand Active PDU) or supported by the client (Confirm Active PDU)."};  
           
    ushort NumIconCacheEntries  
        with Documentation
           {Description = "An unsigned 16-bit integer. The number of entries within each icon cache requested by the server (Demand Active PDU) or supported by the client (Confirm Active PDU)."};            
}
with Documentation
       {Applicability = "2.2.1.1.2",
        Description = "The Window List Capability Set is sent by the server in the Demand Active PDU and by the client in the Confirm Active PDU, as specified in [MS-RDPBCGR] section 2.2.1.13. It indicates that the client and server are capable of communicating Windowing Alternate Secondary Drawing Orders as extensions to the core RDP protocol drawing orders (see section 2.2.1.3)."};
                                                     
type DecodingCache : DecodingCacheBase
{
    void(ISOTS.TPKT) TPKTDispatcher;
    void(TSFPInputEventPdu) AcceptFPPDUDispatcher;
    void(TSFPUpdatePdu) IssueFPPDUDispatcher;

    // The initial value for the orderType agreed on by both the server and client is TS_ENC_PATBLT_ORDER(0x01).
    byte OrderType = PrimaryDrawingOrderType.TS_ENC_PATBLT_ORDER;
    
    uint BufferCount()
    {
        if (Buffer == null)
            return 0;
        return Buffer.Count as uint;
    }
        
    void TryDecodeMsgAndDispatch(bool IsAccepted)
    {
        while (BufferCount() >= 4)
        {
            stream s = Buffer;
            if (s.PeekBytes(0, 2) == $[0300] && (((Buffer[2] as ushort) << 8) + Buffer[3] as ushort) > 4)
            {
                ushort msgLength = ((Buffer[2] as ushort) << 8) + Buffer[3] as ushort;
                if (msgLength > s.ByteLength)
                {                    
                    return;
                }
                // Guarantee never decode failed.
                ISOTS.TPKT tpkt = BinaryDecoder<ISOTS.TPKT>(s) as ISOTS.TPKT; 
                tpkt.Origins = Origins;
                if (Origins.Count > 0 &&
                    Origins[0] is vds:VirtualDataSegment)
                {
                    tpkt#SourcePort = vds.SourcePort;
                    tpkt#DestinationPort = vds.DestinationPort;
                }
                TPKTDispatcher(tpkt);
                Reset(s);
            }
            else
            {
                int msgLength = 0;
                int Length1 = Buffer[1] & 0x7F;
                if ((Buffer[1] & 0x80) == 0x00)
                {
                    msgLength = Length1;
                }
                else
                {
                    msgLength = (Length1 << 8) + (Buffer[2] as int);
                }           
                
                // If length is illegal, clear cache so as not to affect following message
                if (msgLength < 3)
				{
				    Clear();
				    return;
				}
				
				if (IsAccepted)
				{
					if (msgLength > s.ByteLength)
					{
						return;
					}
					binary data = (BinaryDecoder<Blob[msgLength as uint]>(s) as Blob[msgLength as uint]).Data;			
					TSFPInputEventPdu inputEventPdu = BinaryDecoder<TSFPInputEventPdu>(data) as TSFPInputEventPdu;
					if (inputEventPdu != nothing)
					{
						AcceptFPPDUDispatcher(inputEventPdu);
					}
					else
					{
						// If decode failed, clear cache so as not to affect following message
						Clear();
						ThrowDecodingException("RDPBCGR", "TSFPInputEventPdu");
					}
				}
				else
				{
				    if ((Buffer[0] & 0x3f) == 0)
					{	
						if (msgLength > s.ByteLength)
						{
							return;
						}
						binary data = (BinaryDecoder<Blob[msgLength as uint]>(s) as Blob[msgLength as uint]).Data;
						TSFPUpdatePdu updatePdu = BinaryDecoder<TSFPUpdatePdu>(data) as TSFPUpdatePdu;
						if (updatePdu != nothing)
						{
                            if (updatePdu.FPOutputUpdates != nothing)
                            {
                                var updates = updatePdu.FPOutputUpdates as array<TSFPUpdate>;
                                foreach (var update in updates)
                                {
                                    if (update is orderUpdate:TSFPUpdateOrders)
                                    {
                                        if (orderUpdate.OrderData == nothing)
                                        {
                                            break;
                                        }                                        
                                        binary orderData = orderUpdate.OrderData as binary;
                                        stream str = orderData;
                                        array<any> orders = [];
                                        while (str.RemainingByteLength > 0)
                                        {
                                            var order = DecodingOrderData(str, OrderType);
                                            if (order != nothing)
                                            {
                                                orders += [order];
                                                if (order is o:PRIMARY_DRAWING_ORDER && o.orderType != nothing)
                                                {
                                                    OrderType = o.orderType as byte;
                                                }
                                            }
                                            else
                                            {
                                                uint len = str.RemainingByteLength as uint;
                                                orders += [(BinaryDecoder<Blob[len]>(str) as Blob[len]).Data];
                                                ValidationCheck(false, null, DiagnosisLevel.Error, () => Format(RDPBCGR_ORDER_DECODE_ERROR_STR, ["TSFPUpdateOrders"]));
                                                break;
                                            }
                                        }
                                        orderUpdate.OrderData = orders;
                                    }
                                }
                            }
							IssueFPPDUDispatcher(updatePdu);
						}
						else
						{
						    //If decode failed, clear cache so as not to affect following message
					        Clear();
							ThrowDecodingException("RDPBCGR", "TSFPUpdatePdu");
						}
					}
					else
					{
                        if (HasSegmentLost || HasIncompleteSegments)
                        {
                            ValidationCheck(false, null, DiagnosisLevel.Warning, RDPBCGR_TCP_SEGMENT_LOST);
                        }
                        Clear();
                        return;
					}
				}
				Reset(s);
			}         
        }
    }
        
    override optional any message DecodePartialMessage()
    {
        if (BufferCount() < 4)
        {
            return nothing;
        }
        if (Buffer.Segment(0, 2) != $[0300])
        {
            return nothing;
        }
        // Guarantee partial message always decode successfuly.
        ISOTS.IncompleteTPKT partial = BinaryDecoder<ISOTS.IncompleteTPKT>(Buffer) as ISOTS.IncompleteTPKT;
        ReportInsufficientData(partial, DiagnosisLevel.Warning, 
                "ISOTS: Incomplete ISOTS payload for full reassembly, missing contiguous message. Expected length: " + 
                partial.PacketLength.ToString() + ", Acutal length: " + (partial.TPDU.Count + 4).ToString() + ".");
        return partial;
    }
}

bool IsAutoDetectMsg(binary payload, TSUDSCSec1EncryptionLevel encryptionLevel, TSUDSCSec1EncryptionMethod encryptionMethod, RDPBCGRMsgType msgType)
{
    int msgOffset = 0;
    byte securityFlag = payload[msgOffset + 1];
    if (encryptionLevel == TSUDSCSec1EncryptionLevel.EncryptionLevelLow || encryptionLevel == TSUDSCSec1EncryptionLevel.EncryptionLevelNone)
    {
        msgOffset = msgOffset + 4;
    }
    else if (encryptionMethod in {TSUDSCSec1EncryptionMethod.EncryptionMethod40Bit,
                                    TSUDSCSec1EncryptionMethod.EncryptionMethod128Bit,
                                    TSUDSCSec1EncryptionMethod.EncryptionMethod56Bit})
    {
        msgOffset = msgOffset + 12;
    }
    else if (encryptionMethod == TSUDSCSec1EncryptionMethod.EncryptionMethodFips)
    {
        msgOffset = msgOffset + 16;
    }
    if (((msgType == RDPBCGRMsgType.ServerAutoDetectRequestPdu) && 
            ((securityFlag & 0x10) == 0x10)) ||
       ((msgType == RDPBCGRMsgType.ClientAutoDetectResponsePdu) &&
            ((securityFlag & 0x20) == 0x20)))
        return true;
    else
        return false;
}

pattern Unicode = string with BinaryEncoding{TextEncoding = TextEncoding.UTF16};
string BinaryToUnicode(any input)
{
    binary b = input as binary;

    switch(b)
    {
        case s:Unicode from BinaryDecoder=>
            return s;
        default=>
            return b.ToString();
    }
}

string BinaryToTSBitmapCodecCodecGUID(any input)
{
    binary b = input as binary;
    if (b == TSBitmapCodecCodecGUID.CodecGUIDNscodec)
    {
        return "CODEC_GUID_NSCODEC";
    }
    else if (b == TSBitmapCodecCodecGUID.CodecGUIDRemotefx)
    {
        return "CODEC_GUID_REMOTEFX";
    }
    else if (b == TSBitmapCodecCodecGUID.CodecGUIDImageRemotefx)
    {
        return "CODEC_GUID_IMAGE_REMOTEFX";
    }
    else if (b == TSBitmapCodecCodecGUID.CodecGUIDIgnore)
    {
        return "CODEC_GUID_IGNORE";
    }
    else
    {
        return "Unknow Codec GUID(" + b.ToString() + ")";
    }
}

// To decode extention for [MS-RDPELE], define some RDPELE type in RDPBCGR
// [MS-RDPELE] section 2.2.2.1   Server License Request (SERVER_LICENSE_REQUEST)
pattern KeyExchangeAlg = enum uint
{
    KEY_EXCHANGE_ALG_RSA = 0x00000001,
};

// [MS-RDPELE]:2.2.1.4.2   X.509 Certificate Chain (X509 _CERTIFICATE_CHAIN)
type X509CertificateChain
{
    uint NumCertBlobs;
    array<CertBlob> CertBlobArray with BinaryEncoding{Length = NumCertBlobs};
    array<byte> Padding with BinaryEncoding{Length = ((8 + (4 * NumCertBlobs)))};
}

// [MS-RDPELE]:2.2.1.4.2.1   CertBlob (CERT_BLOB)
type CertBlob
{
    uint CbCert;
    array<byte> AbCert with BinaryEncoding{Length = CbCert};
}

int GetbMsgType(binary payload, TSUDSCSec1EncryptionLevel encryptionLevel, TSUDSCSec1EncryptionMethod encryptionMethod, bool clientToServer, bool isSecEncrypt)
{
    int msgOffset = 0;
    // If the PDU is being sent from the server to the client
    if (!clientToServer)
    {
        if (!isSecEncrypt || encryptionLevel in {TSUDSCSec1EncryptionLevel.EncryptionLevelNone,
                                TSUDSCSec1EncryptionLevel.EncryptionLevelLow})
            msgOffset = msgOffset + 4;
        else if (isSecEncrypt && (encryptionLevel in {TSUDSCSec1EncryptionLevel.EncryptionLevelClientCompatible,
                                                     TSUDSCSec1EncryptionLevel.EncryptionLevelHigh}))
            msgOffset = msgOffset + 12;
        else if (isSecEncrypt && encryptionLevel == TSUDSCSec1EncryptionLevel.EncryptionLevelFips)
            msgOffset = msgOffset + 16;
    }
    // If the PDU is being sent from the client to the server
    else
    {
        if (isSecEncrypt && (encryptionLevel in {TSUDSCSec1EncryptionLevel.EncryptionLevelLow,
                                                     TSUDSCSec1EncryptionLevel.EncryptionLevelClientCompatible,
                                                     TSUDSCSec1EncryptionLevel.EncryptionLevelHigh}))
            msgOffset = msgOffset + 12;
        else
            msgOffset = msgOffset + 4;
    }

    if((msgOffset != 0) && (payload.Count > msgOffset))
        return payload[msgOffset];
    else
        return 0;
}
